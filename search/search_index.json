{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cpp2 and cppfront: An experimental 'C++ syntax 2' and its first compiler","text":""},{"location":"#welcome-getting-started","title":"Welcome &amp; getting started","text":"<ul> <li>Overview: What are Cpp2 and cppfront? How do I get and build cppfront?</li> <li>Hello, world!</li> <li>Adding cppfront to your existing C++ project</li> </ul>"},{"location":"#cpp2-reference","title":"Cpp2 reference","text":"<ul> <li>Common concepts</li> <li>Expressions</li> <li>Declarations and aliases</li> <li>Objects, initialization, and memory</li> <li>Functions, branches, and loops</li> <li>Contracts</li> <li>Types and inheritance</li> <li>Metafunctions and reflection</li> <li>Namespaces</li> <li>Safety and \"unchecked\"</li> </ul>"},{"location":"#cppfront-reference","title":"Cppfront reference","text":"<ul> <li>Using Cpp1 (today's syntax) and Cpp2 in the same source file</li> <li>Cppfront command line options</li> </ul>"},{"location":"#notes-and-supplemental-topics","title":"Notes and supplemental topics","text":"<ul> <li><code>@regex</code> status: Regular expression features</li> </ul>"},{"location":"cpp2/common/","title":"Common programming concepts","text":""},{"location":"cpp2/common/#main","title":"<code>main</code>","text":"<p>As always, <code>main</code> is the entry point of the program. For example:</p> <p><code>main</code> can have either:</p> <ul> <li> <p>No parameters: \u2003 <code>main: () /*etc.*/</code></p> </li> <li> <p>One parameter of implicit type named <code>args</code>: \u2003 <code>main: (args) /*etc.*/</code></p> <ul> <li> <p>The type of <code>args</code> cannot be explicitly specified. It is always <code>cpp2::args_t</code>, which behaves similarly to a <code>const std::array&lt;std::string_view&gt;</code>.</p> </li> <li> <p>Using <code>args</code> performs zero heap allocations. Every <code>string_view</code> is directly bound to the string storage provided by host environment.</p> </li> <li> <p><code>args.argc</code> and <code>args.argv</code> additionally provide access to the raw C/C++ <code>main</code> parameters.</p> </li> </ul> </li> </ul> main with (args)<pre><code>//  Print out command line arguments, then invoke\n//  a Qt event loop for a non-UI Qt application\nmain: (args) -&gt; int\n= {\n    for args do (arg) {\n        std::cout &lt;&lt; arg &lt;&lt; \"\\n\";\n    }\n\n    app: QCoreApplication = (args.argc, args.argv);\n    return app.exec();\n}\n</code></pre> <p><code>main</code> can return:</p> <ul> <li> <p><code>void</code>, the default return value for functions. No <code>return</code> statement is allowed in the body. In this case, the compiled Cpp1 code behaves as if <code>main</code> returned <code>int</code>.</p> </li> <li> <p><code>int</code>. If the body has no <code>return</code> statement, the default is to <code>return 0;</code> at the end of the function body.</p> </li> <li> <p>Some other type that your Cpp1 compiler(s) supports as a nonstandard extension.</p> </li> </ul>"},{"location":"cpp2/common/#comments","title":"Comments","text":"<p>The usual <code>// line comments</code> and <code>/* stream comments */</code> are supported. For example:</p> Writing comments<pre><code>//  A line comment: After //, the entire\n//  rest of the line is part of the comment\n\n/*\n    A stream comment: After /*, everything until the\n    next * / (without a space between) is part of the\n    comment. Note that stream comments do not nest.\n */\n</code></pre>"},{"location":"cpp2/common/#lists-and-commas","title":"Lists and commas","text":"<p>All lists use <code>,</code> commas between list items, and may be enclosed by</p> <ul> <li> <p><code>(</code> <code>)</code> parentheses, for most lists</p> </li> <li> <p><code>[</code> <code>]</code> brackets, for calling the subscript operator</p> </li> <li> <p><code>&lt;</code> <code>&gt;</code> angle brackets, for template parameter/argument lists</p> </li> </ul> <p>For example:</p> Lists<pre><code>print: &lt;T,U&gt; (t: T, u: U) = { std::cout &lt;&lt; t &lt;&lt; u &lt;&lt; \"\\n\"; }\n\nmain: () = {\n    array: std::array = ('A', 'B', 'C');\n\n    for (0, 1, 2) do (e) {\n        print( e, array[e] );\n    }\n    //  Prints:\n    //      0A\n    //      1B\n    //      2C\n}\n</code></pre> <p>An extra comma at the end of the list, before the closing <code>)</code> or <code>&gt;</code>, is always allowed but ignored if present (for details, see Design note: Commas).</p> <p>For example:</p> Lists, using optional trailing commas just because we can<pre><code>print: &lt;T,U,&gt; (t: T, u: U,) = { std::cout &lt;&lt; t &lt;&lt; u &lt;&lt; \"\\n\"; }\n\nmain: () = {\n    array: std::array = ('A', 'B', 'C',);\n\n    for (0, 1, 2,) do (e) {\n        print( e, array[e,], );\n    }\n    //  Prints:\n    //      0A\n    //      1B\n    //      2C\n}\n</code></pre>"},{"location":"cpp2/common/#contextual-keywords","title":"Contextual keywords","text":"<p>Cpp2 has very few globally reserved keywords; nearly all keywords are contextual, where they have their special meaning when they appear in a particular place in the grammar. For example:</p> <ul> <li> <p><code>new</code> is used as an ordinary function to do allocation (e.g., <code>shared.new&lt;widget&gt;(1, 2, 3)</code>).</p> </li> <li> <p><code>struct</code> and <code>enum</code> are used as function names in the metafunctions library.</p> </li> <li> <p><code>type</code> can be used as an ordinary name (e.g., <code>std::common_type&lt;T1,T2&gt;::type</code>).</p> </li> <li> <p>Unqualified <code>type_of(x)</code> is a synonym for Cpp1 <code>std::remove_cvref_t&lt;decltype(x)&gt;</code>.</p> </li> </ul> <p>In rare cases, usually when consuming code written in other languages, you may need to write a name that is a reserved keyword. The way to do that is to prefix it with <code>__identifer__</code>, which treats it as an ordinary identifier (without the prefix).</p>"},{"location":"cpp2/common/#fundamental-data-types","title":"Fundamental data types","text":"<p>Cpp2 supports the same fundamental types as today's Cpp1, but additionally provides the following aliases in namespace <code>cpp2</code>:</p> Fixed-width types Synonym for <code>i8</code> <code>std::int8_t</code> <code>i16</code> <code>std::int16_t</code> <code>i32</code> <code>std::int32_t</code> <code>i64</code> <code>std::int64_t</code> <code>u8</code> <code>std::uint8_t</code> <code>u16</code> <code>std::uint16_t</code> <code>u32</code> <code>std::uint32_t</code> <code>u64</code> <code>std::uint64_t</code> Variable-width types  (Cpp2-compatible single-word names) Synonym for (these multi-word names are not allowed in Cpp2) <code>ushort</code> <code>unsigned short</code> <code>uint</code> <code>unsigned int</code> <code>ulong</code> <code>unsigned long</code> <code>longlong</code> <code>long long</code> <code>ulonglong</code> <code>unsigned long long</code> <code>longdouble</code> <code>long double</code> For compatibility/interop only, so deliberately ugly names Synonym for (these multi-word names are not allowed in Cpp2) Notes <code>_schar</code> <code>signed char</code> Normally, prefer <code>i8</code> instead <code>_uchar</code> <code>unsigned char</code> Normally, prefer <code>u8</code> instead"},{"location":"cpp2/common/#type-qualifiers","title":"Type qualifiers","text":"<p>Types can be qualified with <code>const</code> and <code>*</code>. Types are written left-to-right, so a qualifier always applies to what immediately follows it. For example, to declare a <code>const</code> pointer to a non-<code>const</code> pointer to a <code>const i32</code> object, write:</p> Using type qualifiers<pre><code>//  A const pointer to a non-const pointer to a const i32 object\np: const * * const i32;\n</code></pre>"},{"location":"cpp2/common/#literals","title":"Literals","text":"<p>Cpp2 supports the same <code>'c'</code>haracter, <code>\"string\"</code>, binary, integer, and floating point literals as Cpp1, including most Unicode encoding prefixes and raw string literals.</p> <p>Cpp2 supports using Cpp1 user-defined literals for compatibility, to support seamlessly using existing libraries. However, because Cpp2 has unified function call syntax (UFCS), the preferred way to author the equivalent in Cpp2 is to just write a function or type name as a <code>.</code> call suffix. For example:</p> <ul> <li> <p>You can create a <code>u8</code> value by writing either <code>u8(123)</code> or <code>123.u8()</code>. <sup>1</sup></p> </li> <li> <p>You can write a 'constexpr' function like <code>nm: (value: i64) -&gt; my_nanometer_type == { /*...*/ }</code> that takes an integer and returns a value of a strongly typed \"nanometer\" type, and then create a <code>nm</code> value by writing either <code>nm(123)</code> or <code>123.nm()</code>.</p> </li> </ul> <p>Both <code>123.nm()</code> and <code>123.u8()</code> are very similar to user-defined literal syntax, and more general.</p>"},{"location":"cpp2/common/#operators","title":"Operators","text":"<p>Operators have the same precedence and associativity as in Cpp1, but some unary operators that are prefix (always or sometimes) in Cpp1 are postfix (always) in Cpp2.</p>"},{"location":"cpp2/common/#unary-operators","title":"Unary operators","text":"<p>The operators <code>!</code>, <code>+</code>, and <code>-</code> are prefix, as in Cpp1. For example:</p> Using prefix operators<pre><code>if !vec.empty() {\n    vec.emplace_back( -123.45 );\n}\n</code></pre> Unary operator Cpp2 example Cpp1 equivalent <code>!</code> <code>!vec.empty()</code> <code>!vec.empty()</code> <code>+</code> <code>+100</code> <code>+100</code> <code>-</code> <code>-100</code> <code>-100</code> <p>The operators <code>.</code>, <code>..</code>, <code>*</code>, <code>&amp;</code>, <code>~</code>, <code>++</code>, <code>--</code>, <code>()</code>, <code>[]</code>, <code>..&lt;</code>, <code>..=</code>, and <code>$</code> are postfix. For example:</p> Using postfix operators<pre><code>//  Cpp1 examples, from cppfront's own source code:\n//      address = &amp;(*tokens)[pos + num];\n//      is_void = *(*u)-&gt;identifier == \"void\";\n//  Cpp2 equivalents:\n        address = tokens*[pos + num]&amp;;\n        is_void = u**.identifier* == \"void\";\n</code></pre> <p>Postfix notation lets the code read fluidly left-to-right, in the same order in which the operators will be applied, and lets declaration syntax be consistent with usage syntax. For more details, see Design note: Postfix operators.</p> <p>Note: The function call syntax <code>f(x)</code> calls a namespace-scope function only. The function call syntax <code>x.f()</code> is a unified function call syntax (aka UFCS) that calls a type-scope function in the type of <code>x</code> if available, otherwise calls the same as <code>f(x)</code>. The function call syntax <code>x..f()</code> calls a type-scope function only. For details, see Design note: UFCS.</p> Unary operator Cpp2 example Cpp1 equivalent <code>.</code> <code>obj.f()</code> <code>obj.f()</code> <code>*</code> <code>pobj*.f()</code> <code>(*pobj).f()</code> or <code>pobj-&gt;f()</code> <code>&amp;</code> <code>obj&amp;</code> <code>&amp;obj</code> <code>~</code> <code>val~</code> <code>~val</code> <code>++</code> <code>iter++</code> <code>++iter</code> <code>--</code> <code>iter--</code> <code>--iter</code> <code>(</code> <code>)</code> <code>f( 1, 2, 3)</code> <code>f( 1, 2, 3)</code> <code>[</code> <code>]</code> <code>vec[123]</code> <code>vec[123]</code> <code>..&lt;</code> <code>v.begin()..&lt;v.end()</code> <code>std::ranges::subrange(v.begin(), v.end())</code> <code>..=</code> <code>1..=10</code> <code>std::views::iota(1, 11)</code> <code>$</code> <code>val$</code> reflection \u2014 no Cpp1 equivalent yet <p>Note: The <code>...</code> pack expansion syntax is also supported.</p> <p>Note: The <code>(</code> <code>)</code>, <code>[</code> <code>]</code>, <code>..&lt;</code>, and <code>..=</code> operators are treated as postfix unary operators, though they can take additional arguments.</p> <p>Note: Because <code>++</code> and <code>--</code> always have in-place update semantics, we never need to remember \"use prefix <code>++</code>/<code>--</code> unless you need a copy of the old value.\" If you do need a copy of the old value, just take the copy before calling <code>++</code>/<code>--</code>. When you write a copyable type that overloads <code>operator++</code> or <code>operator--</code>, cppfront generates also the copy-old-value overload of that function to support natural use of the type from Cpp1 code.</p>"},{"location":"cpp2/common/#binary-operators","title":"Binary operators","text":"<p>Binary operators are the same as in Cpp1. From highest to lowest precedence:</p> Binary operators grouped by precedence <code>*</code>, <code>/</code>, <code>%</code> <code>+</code>, <code>-</code> <code>&lt;&lt;</code>, <code>&gt;&gt;</code> <code>&lt;=&gt;</code> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>==</code>, <code>!=</code> <code>&amp;</code> <code>^</code> <code>|</code> <code>&amp;&amp;</code> <code>||</code> <code>=</code> and compound assignment <ol> <li> <p>Or <code>123.cpp2::u8()</code> if you aren't <code>using</code> the namespace or that specific name.\u00a0\u21a9</p> </li> </ol>"},{"location":"cpp2/contracts/","title":"Contracts","text":""},{"location":"cpp2/contracts/#overview","title":"Overview","text":"<p>Cpp2 currently supports three kinds of contracts:</p> <ul> <li> <p>Preconditions and postconditions. A function declaration can include <code>pre(condition)</code> and <code>post(condition)</code> before the <code>= /* function body */</code>. Before entering the function body, preconditions are fully evaluated and postconditions are captured as function expressions to be evaluated later (and perform their captures of values on entry, if any). Immediately before exiting the function body via a normal return, postconditions are evaluated. If the function exits via an exception, postconditions are not evaluated.</p> </li> <li> <p>Assertions. A function body can write <code>assert(condition)</code> assertion statements. Assertions are evaluated when control flow passes through them.</p> </li> </ul> <p>Notes:</p> <ul> <li> <p><code>condition</code> is an expression that evaluates to <code>true</code> or <code>false</code>. It will not be evaluated unless checking for this contract group is enabled (<code>group.is_active()</code> is <code>true</code>).</p> </li> <li> <p>Optionally, <code>condition</code> may be followed by <code>, \"message\"</code>, a message to include if a violation occurs. For example, <code>pre(condition, \"message\")</code>.</p> </li> <li> <p>Optionally, a <code>&lt;group, pred1, pred2&gt;</code> can be written inside <code>&lt;</code> <code>&gt;</code> angle brackets immediately before the <code>(</code>, to designate that this test is part of the contract group named <code>group</code> and (also optionally) contract predicates <code>pred1</code> and <code>pred2</code>. If a violation occurs, <code>Group.report_violation()</code> will be called. For example, <code>pre&lt;group&gt;(condition)</code>. If no contract group is specified, the contract defaults to being part of the <code>default</code> group (spelled <code>cpp2_default</code> when used from Cpp1 code).</p> </li> </ul> <p>The order of evaluation is:</p> <ul> <li> <p>First, if the contract group is <code>unevaluated</code> then the contract is ignored; <code>condition</code> is never evaluated. This special group designates conditions intended for use by static analyzers only, and the only requirement is that the condition be grammatically valid.</p> </li> <li> <p>Next, predicates are evaluated in order. If any predicate evaluates to <code>false</code>, stop.</p> </li> <li> <p>Next, <code>group.is_active()</code> is evaluated. If that evaluates to <code>false</code>, stop.</p> </li> <li> <p>Next, <code>condition</code> is evaluated. If that evaluates to <code>true</code>, stop.</p> </li> <li> <p>Finally, if all the predicates were true and the group is active and the condition was false, <code>group.report_violation()</code> is called.</p> </li> </ul> <p>For example:</p> Precondition and postcondition examples<pre><code>insert_at: (container, where: int, val: int)\n    pre&lt;bounds_safety&gt;( 0 &lt;= where &lt;= container.ssize(), \"position (where)$ is outside 'container'\" )\n    post              ( container.ssize() == container.ssize()$ + 1 )\n= {\n    _ = container.insert( container.begin()+where, val );\n}\n</code></pre> <p>In this example:</p> <ul> <li> <p>The <code>$</code> captures are performed before entering the function.</p> </li> <li> <p>The precondition is part of the <code>bounds_safety</code> contract group and is checked before entering the function. If the check fails, say because <code>where</code> is <code>-1</code>, then <code>cpp2::bounds_safety.report_violation(\"position -1 is outside 'container'\")</code> is called.</p> </li> <li> <p>The postcondition is part of the <code>default</code> safety contract group.  If the check fails, then <code>cpp2::default.report_violation()</code> is called.</p> </li> </ul>"},{"location":"cpp2/contracts/#contract-groups","title":"Contract groups","text":"<p>Contract groups are useful to enable or disable or set custom handlers independently for different groups of contracts. A contract group <code>grp</code> is just the name of an object that can be called with:</p> <ul> <li> <p><code>grp.report_violation()</code> and <code>grp.report_violation(message)</code>, where <code>message</code> is a <code>* const char</code> C-style text string</p> </li> <li> <p><code>grp.is_active()</code>, which returns <code>true</code> if and only if the group is enabled</p> </li> </ul> <p>You can create new contract groups just by creating new objects that have a <code>.report_violation</code> function. The object's name is the contract group's name. The object can be at any scope: local, global, or heap.</p> <p>For example, here are some ways to use contract groups of type <code>cpp2::contract_group</code>, which is a convenient group type:</p> Using contract groups<pre><code>group_a: cpp2::contract_group = ();          // a global group\n\nfunc: () = {\n    group_b: cpp2::contract_group = ();      // a local group\n\n    group_c := new&lt;cpp2::contract_group&gt;();  // a dynamically allocated group\n\n    // ...\n\n    assert&lt;group_a &gt;( some    &amp;&amp; condition );\n    assert&lt;group_g &gt;( another || condition );\n    assert&lt;group_c*&gt;( another &amp;&amp; condition );\n}\n</code></pre> <p>You can make all the objects in a class hierarchy into a contract group by having a <code>.report_violation</code> function in a base class, and then writing contracts in that hierarchy using <code>&lt;this&gt;</code> as desired. This technique is used in cppfront's own reflection API:</p> Example of using 'this' as a contract group, from cppfront 'reflect.h2'<pre><code>function_declaration: @copyable type =\n{\n    // inherits from a base class that provides '.report_violation'\n\n    // ...\n\n    add_initializer: (inout this, source: std::string_view)\n        pre&lt;this&gt; (!has_initializer(), \"cannot add an initializer to a function that already has one\")\n        pre&lt;this&gt; (parent_is_type(),   \"cannot add an initializer to a function that isn't in a type scope\")\n    = { /*...*/ }\n\n    // ...\n\n}\n</code></pre>"},{"location":"cpp2/contracts/#contract-predicates","title":"Contract predicates","text":"<p>Contract predicates are useful to conditionally check specific contracts as a static or dynamic property. Importantly, if any predicate is <code>false</code>, the check's conditional expression will not be evaluated.</p> <p>For example:</p> Using contract predicates<pre><code>is_checked_build: bool == SEE_BUILD_FLAG;   // a static (compile-time) predicate\n\nchecking_enabled: bool =  /*...*/ ;         // a dynamic (run-time) predicate,\n                                            // could change as the program runs\n\nfunc: () = {\n    assert&lt;audit, is_checked_build, checking_enabled&gt;( condition );\n}\n</code></pre> <p>In this example, the order of evaluation is:</p> <ul> <li> <p><code>is_checked_build</code> is evaluated. Since it is a compile-time value, the evaluation can happen at compile time. If it evaluates to <code>false</code>, then stop; the entire contract could be optimized away by the compiler.</p> </li> <li> <p>Otherwise, next <code>checking_enabled</code> is evaluated at run time. If it evaluates to <code>false</code>, then stop.</p> </li> <li> <p>Otherwise, next <code>audit.is_active()</code> is evaluated. If it evaluates to <code>false</code>, then stop.</p> </li> <li> <p>Otherwise, next <code>condition</code> is evaluated. If it evaluates to <code>true</code>, then stop.</p> </li> <li> <p>Otherwise, <code>audit.report_violation()</code> is called.</p> </li> </ul>"},{"location":"cpp2/contracts/#cpp2contract_group-and-customizable-violation-handling","title":"<code>cpp2::contract_group</code>, and customizable violation handling","text":"<p>The contract group object could also provide additional functionality. For example, Cpp2 comes with the <code>cpp2::contract_group</code> type which allows installing a customizable handler for each object. Each object can only have one handler at a time, but the handler can change during the course of the program. <code>contract_group</code> supports:</p> <ul> <li> <p><code>.set_handler(pfunc)</code> accepts a pointer to a handler function with signature <code>* (* const char)</code>.</p> </li> <li> <p><code>.get_handler()</code> returns the current handler function pointer, or null if none is installed.</p> </li> <li> <p><code>.is_active()</code> returns whether there is a current handler installed.</p> </li> <li> <p><code>.enforce(condition, message)</code> evaluates <code>condition</code>, and if it is <code>false</code> then calls <code>.report_violation(message)</code>.</p> </li> </ul> <p>Cpp2 comes with five predefined <code>contract group</code> global objects in namespace <code>cpp2</code>:</p> <ul> <li> <p><code>default</code>, which is used as the default contract group for contracts that don't specify a group.</p> </li> <li> <p><code>type_safety</code> for type safety checks.</p> </li> <li> <p><code>bounds_safety</code> for bounds safety checks.</p> </li> <li> <p><code>null_safety</code> for null safety checks.</p> </li> <li> <p><code>testing</code> for general test checks.</p> </li> </ul> <p>For these groups, the default handler is <code>cpp2::report_and_terminate</code>, which prints information about the violation to <code>std::cerr</code> and then calls <code>std::terminate()</code>. But you can customize it to do anything you want, including to integrate with any third-party or in-house error reporting system your project is already using. For example:</p> Example of customized contract violation handler<pre><code>main: () -&gt; int = {\n    cpp2::default.set_handler(call_my_framework&amp;);\n    assert&lt;default&gt;(false, \"this is a test, this is only a test\");\n    std::cout &lt;&lt; \"done\\n\";\n}\n\ncall_my_framework: (msg: * const char) = {\n    //  You can do anything you like here, including arbitrary work\n    //  and integration with your current error reporting libraries,\n    //  log-and-continue, throw an exception, whatever is wanted...\n    std::cout\n        &lt;&lt; \"sending error to my framework... [\"\n        &lt;&lt; msg &lt;&lt; \"]\\n\";\n    exit(0);\n}\n//  Prints:\n//      sending error to my framework... [this is a test, this is only a test]\n</code></pre>"},{"location":"cpp2/declarations/","title":"Declarations and aliases","text":""},{"location":"cpp2/declarations/#unified-declarations","title":"Unified declarations","text":"<p>All Cpp2 declarations are written as \"name <code>:</code> kind <code>=</code> statement\".</p> <ul> <li> <p>The name must be a valid identifier (start with a letter, and consist of letters, digits, or <code>_</code>). The name can be variadic (be a name for a list of zero or more things) by writing a <code>...</code> suffix at the end of the name.</p> </li> <li> <p>The <code>:</code> is pronounced \"is a.\"</p> </li> <li> <p>The kind can start with template parameters and end with <code>requires</code> constraints.</p> </li> <li> <p>The <code>=</code> is pronounced \"defined as.\" For the definition of something that will always have the same value, write <code>==</code>, pronounced \"defined as a synonym for\".</p> </li> <li> <p>The statement is typically an expression statement (e.g., <code>a + b();</code>) or a compound statement (e.g., <code>{ /*...*/ return c(d) / e; }</code>).</p> </li> </ul> <p>Various parts of the syntax allow a <code>_</code> \"don't care\" wildcard or can be omitted entirely to accept a default (e.g., <code>x: int = 0;</code> can be equivalently written <code>x: _ = 0;</code> or <code>x := 0;</code> both of which deduce the type).</p> <p>Notes:</p> <ul> <li> <p>When the type is omitted, whitespace does not matter, and writing <code>x: = 0;</code> or <code>x : = 0;</code> or <code>x := 0;</code> or other whitespace is just a stylistic choice. This documentation's style uses the last one, except when there are multiple adjacent declaration lines this style lines up their <code>:</code> and <code>=</code>.</p> </li> <li> <p><code>==</code> stresses that this name will always have the given value, to express aliases and side-effect-free 'constexpr' function aliases.</p> </li> </ul>"},{"location":"cpp2/declarations/#unnamed-declaration-expressions","title":"Unnamed declaration expressions","text":"<p>In an expression, most declarations can be written without a name (just starting with <code>:</code>). Such unnamed declaration expressions are useful for single-use temporary variables or 'lambda' functions that don't need a name to be reused elsewhere. For example:</p> <ul> <li> <p><code>:widget = 42</code> is an unnamed expression-local (aka temporary) object of type <code>widget</code> defined as having the initial value <code>42</code>. It uses the same general syntax, just without declaring a name.</p> </li> <li> <p><code>:(x) = std::cout &lt;&lt; x</code> is an unnamed expression-local generic function expression (aka lambda) defined as having the given one-statement body. The body can include captures.</p> </li> </ul> <p>Both just omit the name and make the final <code>;</code> optional. Otherwise, they have the identical syntax and meaning as if you declared the same thing with a name outside expression scope (e.g., <code>w: widget = 42;</code> or <code>f: (x) = std::cout &lt;&lt; x;</code>) and then used the name in the expression.</p> <p>Note: Throughout Cpp2, every declaration is written with <code>:</code>, and every use of <code>:</code> is a declaration.</p>"},{"location":"cpp2/declarations/#from-functions-to-local-scopes-and-back-again","title":"From functions to local scopes, and back again","text":"<p>The function syntax is deliberately designed to be general, so you can omit parts. This means Cpp2 has no special \"lambda function\" syntax for unnamed functions; an unnamed function is really an unnamed function, written using the ordinary function just without a name. This scales all the way down to ordinary blocks and statements, which are written the same as functions that have no name or parameters.</p> <p>We can illustrate this in two directions. First, let's start with a full function, and successively omit optional parts that we aren't currently using:</p> Start with a full function, and successively omit optional parts if unused<pre><code>// Full named function\nf:(x: int = init) = { /*...*/ }     // x is a parameter to the function\nf:(x: int = init) = statement;      // same, except return type is deduced\n\n// Omit name =&gt; anonymous function (aka 'lambda')\n :(x: int = init) = { /*...*/ }     // x is a parameter to the function\n :(x: int = init) = statement;      // same, except return type is deduced\n\n// Omit declaration =&gt; local and immediate (aka 'let' in other languages)\n  (x: int = init)   { /*...*/ }     // x is a parameter to this\n  (x: int = init)   statement;      //  compound or single-statement\n\n// Omit parameters =&gt; ordinary block or statement\n                    { /*...*/ }     // ordinary compound statement\n                    statement;      // ordinary statement\n</code></pre> <p>Conversely, we can start with an ordinary block or statement, and successively build it up to make it more powerful:</p> Start with an ordinary block or statement, and successively add parts<pre><code>// Ordinary block or statement\n                    { /*...*/ }     // ordinary compound statement\n                    statement;      // ordinary statement\n\n// Add parameters =&gt; more RAII locally-scoped variables\n  (x: int = init)   { /*...*/ }     // x is destroyed after this\n  (x: int = init)   statement;      //  compound or single-statement\n\n// Add declaration =&gt; treat the code as a callable object\n :(x: int = init) = { /*...*/ }     // x is a parameter to the function\n :(x: int = init) = statement;      // same, except return type is deduced\n\n// Add name =&gt; full named function\nf:(x: int = init) = { /*...*/ }     // x is a parameter to the function\nf:(x: int = init) = statement;      // same, except return type is deduced\n</code></pre>"},{"location":"cpp2/declarations/#template-parameters","title":"Template parameters","text":"<p>A template parameter list is a list enclosed by <code>&lt;</code> <code>&gt;</code> angle brackets, and the parameters separated by commas. Each parameter is declared using the same syntax as any type or object. If a parameter's <code>:</code> kind is not specified, the default is <code>: type</code>.</p> <p>For example:</p> Declaring template parameters<pre><code>array: &lt;T: type, size: i32&gt; type\n    // parameter T is a type\n    // parameter size is a 32-bit int\n= {\n    // ...\n}\n\ntuple: &lt;Ts...: type&gt; type\n    // parameter Ts is variadic list of zero or more types\n= {\n    // ...\n}\n</code></pre>"},{"location":"cpp2/declarations/#requires-constraints","title":"<code>requires</code> constraints","text":"<p>A <code>requires</code> condition constraint appears at the end of the kind of a templated declaration. If the condition evaluates to <code>false</code>, that specialization of the template is ignored as if not declared.</p> <p>For example:</p> A requires constraint on a variadic function<pre><code>print: &lt;Args...: type&gt;\n       (inout out: std::ostream, args...: Args)\n       requires sizeof...(Args) &gt;= 1u\n= {\n    (out &lt;&lt; ... &lt;&lt; args);\n}\n</code></pre>"},{"location":"cpp2/declarations/#examples","title":"Examples","text":"Consistent declarations \u2014 name : kind = statement<pre><code>//  n is a namespace defined as the following scope\nn: namespace\n= {\n    //  shape is a templated type with one type parameter T\n    //  (equivalent to '&lt;T: type&gt;') defined as the following scope\n    shape: &lt;T&gt; type\n    = {\n        //  point is a type defined as being always the same as\n        //  (i.e., an alias for) T\n        point_type: type == T;\n\n        //  points is an object of type std::vector&lt;point_type&gt;,\n        //  defined as having an empty default value\n        //  (type-scope objects are private by default)\n        points: std::vector&lt;point_type&gt; = ();\n\n        //  draw is a function taking 'this' and 'canvas' parameters\n        //  and returning bool, defined as the following body\n        //  (type-scope functions are public by default)\n        //\n        //  this is an object of type shape (as if written 'this: shape')\n        //\n        //  where is an object of type canvas\n        draw: (this, where: canvas) -&gt; bool\n        = {\n            //  pen is an object of deduced (omitted) type 'color',\n            //  defined as having initial value 'color::red'\n            pen := color::red;\n\n            //  success is an object of deduced (omitted) type bool,\n            //  defined as having initial value 'false'\n            success := false;\n\n            // ...\n\n            return success;\n        }\n\n        //  count is a function taking 'this' and returning a type\n        //  deduced from its body, defined as a single-expression body\n        //  (equivalent to '= { return points.ssize(); }' but omitting\n        //  syntax where we're using the language defaults)\n        count: (this) -&gt; _ = points.ssize();\n\n        //  ...\n    }\n\n    //  color is an @enum type (see Note) defined as having these enumerators\n    color: @enum type = { red; green; blue; }\n\n    //  calc_next_year is a function defined as always returning the same\n    //  value for the same input (i.e., 'constexpr', side effect-free)\n    calc_next_year: (year: i32) -&gt; i32 == year + 1;\n}\n</code></pre> <p>Note: <code>@enum</code> is a metafunction, which provides an easy way to opt into a group of defaults, constraints, and generated functions. For details, see <code>@enum</code>.</p>"},{"location":"cpp2/declarations/#aliases","title":"Aliases","text":"<p>Aliases are pronounced \"synonym for\", and written using the same name <code>:</code> kind <code>=</code> value declaration syntax as everything in Cpp2:</p> <ul> <li> <p>name is declared to be a synonym for value.</p> </li> <li> <p>kind can be any of the kinds: <code>namespace</code>, <code>type</code>, a function signature, or a type.</p> </li> <li> <p><code>==</code>, pronounced \"defined as a synonym for\", always precedes the value. The <code>==</code> syntax stresses that during compilation every use of the name could be equivalently replaced with the value.</p> </li> <li> <p>value is the expression that the name is a synonym for.</p> </li> </ul>"},{"location":"cpp2/declarations/#namespace-aliases","title":"Namespace aliases","text":"<p>A namespace alias is written the same way as a namespace, but using <code>==</code> and with the name of another namespace as its value. For example:</p> Namespace aliases<pre><code>//  'chr' is a namespace defined as a synonym for 'std::chrono'\nchr    : namespace == std::chrono;\n\n//  'chrlit' is a namespace defined as a synonym for 'std::chrono_literals'\nchrlit : namespace == std::chrono_literals;\n\nmain: () = {\n    using chrlit::_ ;\n\n    //  The next two lines are equivalent\n    std::cout &lt;&lt; \"1s is (std::chrono::nanoseconds(1s).count())$ns\\n\";\n    std::cout &lt;&lt; \"1s is (chr::nanoseconds(1s).count())$ns\\n\";\n}\n//  Prints:\n//      1s is 1000000000ns\n//      1s is 1000000000ns\n</code></pre>"},{"location":"cpp2/declarations/#type-aliases","title":"Type aliases","text":"<p>A type alias is written the same way as a type, but using <code>==</code> and with the name of another type as its value. For example:</p> Type aliases<pre><code>//  'imap&lt;T&gt;' is a type defined as a synonym for 'std::map&lt;i32, T&gt;'\nimap : &lt;T&gt; type == std::map&lt;i32, T&gt;;\n\nmain: () = {\n    //  The next two lines declare two objects with identical type\n    map1: std::map&lt;i32, std::string&gt; = ();\n    map2: imap&lt;std::string&gt; = ();\n\n    //  Assertion they are the same type, using the same_as concept\n    static_assert( std::same_as&lt; decltype(map1), decltype(map2) &gt; );\n}\n</code></pre>"},{"location":"cpp2/declarations/#function-aliases","title":"Function aliases","text":"<p>A function alias is written the same way as a function, but using <code>==</code> and with a side-effect-free body as its value; the body must always return the same value for the same input arguments. For example:</p> Function aliases<pre><code>//  'square' is a function defined as a synonym for the value of 'i * i'\nsquare: (i: i32) -&gt; _ == i * i;\n\nmain: () = {\n    //  It can be used at compile time, with compile time values\n    ints: std::array&lt;i32, square(4)&gt; = ();\n\n    //  Assertion that the size is the square of 4\n    static_assert( ints.size() == 16 );\n\n    //  And it can be used at run time, with run time values\n    std::cout &lt;&lt; \"the square of 4 is (square(4))$\\n\";\n}\n//  Prints:\n//      the square of 4 is 16\n</code></pre> <p>Note: A function alias is compiled to a Cpp1 <code>constexpr</code> function.</p>"},{"location":"cpp2/declarations/#object-aliases","title":"Object aliases","text":"<p>An object alias is written the same way as an object, but using <code>==</code> and with a side-effect-free value. For example:</p> Function aliases<pre><code>//  'BufferSize' is an object defined as a synonym for the value 1'000'000\nBufferSize: i32 == 1'000'000;\n\nmain: () = {\n    buf: std::array&lt;std::byte, BufferSize&gt; = ();\n    static_assert( buf.size() == BufferSize );\n}\n</code></pre> <p>Note: An object alias is compiled to a Cpp1 <code>constexpr</code> object.</p>"},{"location":"cpp2/expressions/","title":"Common expressions","text":""},{"location":"cpp2/expressions/#calling-functions-fx-syntax-xf-ufcs-syntax-and-xf-members-only-syntax","title":"Calling functions: <code>f(x)</code> syntax, <code>x.f()</code> UFCS syntax, and <code>x..f()</code> members-only syntax","text":"<p>A function argument list is a list of arguments enclosed by <code>(</code> <code>)</code> parentheses.</p> <p>A function call like <code>f(x)</code> is a normal function call that will call non-member functions only, as usual in C++.</p> <p>A function call like <code>x.f()</code> is a unified function call syntax (aka UFCS) call. It will call a member function if one is available, and otherwise will call <code>f(x)</code>. Having UFCS is important for generic code that may want to call a member or a non-member function, whichever is available. It's also important to enable fluid programming styles and natural IDE autocompletion support.</p> <p>An operator notation call like <code>a + b</code> will call an overloaded operator function if one is available, as usual in C++.</p> <p>A function call like <code>x..f()</code> will consider member functions only.</p> <p>For example:</p> Function calls<pre><code>//  Generic function to log something\n//  This calls operator&lt;&lt; using operator notation\nlog: (x) = { clog &lt;&lt; x; }\n\nf: ( v : std::vector&lt;widget&gt; ) = {\n    //  This calls log() with the result of std::vector::size()\n    log( v.size() );\n\n    //  This calls log() with the result of std::ssize(v), because\n    //  v doesn't have a .ssize member function\n    log( v.ssize() );\n}\n\n//  Generic function to use standard I/O to print any printable types\n//  safely using string interpolation (instead of type-unsafe format strings)\nhello: (name, height: float) = {\n    //  Using UFCS to make direct calls to C functions as if they were members\n    stdout.fprintf(\"%s\", (\"Hi (name)$, your height is (height:.1f)$\\\"!\\n\").c_str());\n    //  Equivalent using iostreams:\n    //        std::cout &lt;&lt; \"Hello (name)$, your height is (height:.1f)$ inches!\\n\";\n\n    //  The C and C++ standard libraries are not only fully available,\n    //  but safer (and arguably nicer) when used from Cpp2 syntax code\n}\n\nmain: () = {\n    hello(\"Flimnap\", 6.5);\n    hello(\"Goliath\", 115);\n    hello(\"Polyphemus\", 180);\n}\n//  Sample output:\n//      Hi Flimnap, your height is 6.5\"!\n//      Hi Goliath, your height is 115.0\"!\n//      Hi Polyphemus, your height is 180.0\"!\n</code></pre> <p>To explicitly treat an object name passed as an argument as <code>move</code> or <code>out</code>, write that keyword before the variable name.</p> <ul> <li> <p>Explicit <code>move</code> is rarely needed. Every definite last use of a local variable will apply <code>move</code> by default. Writing <code>move</code> from an object before its definite last use means that later uses may see a moved-from state.</p> </li> <li> <p>Explicit <code>out</code> is needed only when initializing a local variable separately from its declaration using a call to a function with an <code>out</code> parameter. For details, see Guaranteed initialization.</p> </li> </ul> <p>For example:</p>"},{"location":"cpp2/expressions/#_-the-dont-care-wildcard-including-explicit-discard","title":"<code>_</code> \u2014 the \"don't care\" wildcard, including explicit discard","text":"<p><code>_</code> is pronounced \"don't care\" and allowed as a wildcard in most contexts. For example:</p> Using the _ wildcard<pre><code>//  We don't care about the guard variable's name\n_ : std::lock_guard = mut;\n\n//  If we don't care to write the variable's type, deduce it\nx : _ = 42;\n    // in cases like this, _ can be omitted...\n    // this is equivalent to \"x := 42;\"\n\nreturn inspect v -&gt; std::string {\n    is std::vector = \"v is a std::vector\";\n    is _ = \"unknown\";   // don't care what else, match anything\n};\n</code></pre> <p>Cpp2 treats all function outputs (return values, and results produced via <code>inout</code> and <code>out</code> parameters) as important, and does not let them be silently discarded by default. To explicitly discard such a value, assign it to <code>_</code>. For example:</p> Using _ for explicit discard<pre><code>_ = vec.emplace_back(1,2,3);\n    // \"_ =\" is required to explicitly discard emplace_back's\n    // return value (which is non-void since C++17)\n\n{\n    x := my_vector.begin();\n    std::advance(x, 2);\n    _ = x;  // required to explicitly discard x's new value,\n            // because std::advance modifies x's value\n}\n</code></pre> <p>For details, see Design note: Explicit discard. In Cpp2, data is always initialized, data is never silently lost, data flow is always visible. Data is precious, and it's always safe.</p>"},{"location":"cpp2/expressions/#typevalue-queries-and-casts","title":"Type/value queries and casts","text":""},{"location":"cpp2/expressions/#is-safe-typevalue-queries","title":"<code>is</code> \u2014 safe type/value queries","text":"<p>An <code>x is C</code> expression allows safe type and value queries, and evaluates to <code>true</code> if <code>x</code> matches constraint <code>C</code>. It supports both static and dynamic queries, including customization, with support for standard library dynamic types like <code>std::variant</code>, <code>std::optional</code>, <code>std::expected</code>, and <code>std::any</code> provided out of the box.</p> <p>There are two kinds of <code>is</code>:</p> <ul> <li>A type query, where <code>C</code> is a type constraint: a type, a template name, a concept, or a type predicate. Here <code>x</code> may be a type, or an object or expression; if it is an object or expression, the query refers to <code>x</code>'s type.</li> </ul> Type constraint kind Example Static type query <code>x is int</code> Dynamic type query <code>ptr* is Shape</code> Static template type query <code>x is std::vector</code> Static concept query <code>x is std::integral</code> <ul> <li>A value query, where <code>C</code> is a value constraint: a value, or a value predicate. Here <code>x</code> must be an object or expression.</li> </ul> Value constraint kind Example Value <code>x is 0</code> Value predicate <code>x is (in(10, 20))</code> <p><code>is</code> is useful throughout the language, including in <code>inspect</code> pattern matching alternatives. <code>is</code> is extensible, and works out of the box with <code>std::variant</code>, <code>std::optional</code>, <code>std::expected</code>, and <code>std::any</code>. For examples, see:</p> <ul> <li><code>mixed-inspect-templates.cpp2</code></li> <li><code>mixed-inspect-values.cpp2</code></li> <li><code>mixed-inspect-values-2.cpp2</code></li> <li><code>mixed-type-safety-1.cpp2</code></li> <li><code>pure2-enum.cpp2</code></li> <li><code>pure2-inspect-expression-in-generic-function-multiple-types.cpp2</code></li> <li><code>pure2-inspect-fallback-with-variant-any-optional.cpp2</code></li> <li><code>pure2-type-safety-1.cpp2</code></li> <li><code>pure2-type-safety-2-with-inspect-expression.cpp2</code></li> </ul> <p>Here are some <code>is</code> queries with their Cpp1 equivalents. In this table, uppercase names are type names, lowercase names are objects, <code>v</code> is a <code>std::variant</code> where one alternative is <code>T</code>, <code>o</code> is a <code>std::optional&lt;T&gt;</code>, and <code>a</code> is a <code>std::any</code>:</p> Some sample <code>is</code> queries Cpp1 equivalent <code>X is Y &amp;&amp; Y is X</code> <code>std::is_same_v&lt;X,Y&gt;</code> <code>D is B</code> <code>std::is_base_of&lt;B,D&gt;</code> <code>pb is *D</code> <code>dynamic_cast&lt;D*&gt;(pb) != nullptr</code> <code>v is T</code> <code>std::holds_alternative&lt;T&gt;(v)</code> <code>a is T</code> <code>a.type() == typeid(T)</code> <code>o is T</code> <code>o.has_value()</code> <p>Note: <code>is</code> unifies a variety of differently-named Cpp1 language and library queries under one syntax, and supports only the type-safe ones.</p>"},{"location":"cpp2/expressions/#as-safe-casts-and-conversions","title":"<code>as</code> \u2014 safe casts and conversions","text":"<p>An <code>x as T</code> expression allows safe type casts. <code>x</code> must be an object or expression, and <code>T</code> must be a type. Like <code>is</code>, <code>as</code> supports both static and dynamic typing, including customization, with support for standard library dynamic types like <code>std::variant</code>, <code>std::optional</code>, <code>std::expected</code>, and <code>std::any</code> provided out of the box. For example:</p> Using as<pre><code>main: () = {\n    a: std::any = 0;                // a's type is now int, value 0\n    test(a);                        // prints \"zero\"\n    a = \"plugh\" as std::string;     // a's type is now std::string, value \"plugh\"\n    test(a);                        // prints \"plugh\"\n    test(\"xyzzy\" as std::string);   // prints \"xyzzy\"\n}\n\n//  A generic function that takes an argument 'x' of any type,\n//  same as \"void test( auto const&amp; x )\" in C++20 syntax\ntest: (x) = {\n    std::cout &lt;&lt; inspect x -&gt; std::string {\n        is 0           = \"zero\";\n        is std::string = x as std::string;\n        is _           = \"(no match)\";\n    } &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Here are some <code>as</code> casts with their Cpp1 equivalents. In this table, uppercase names are type names, lowercase names are objects, <code>v</code> is a <code>std::variant</code> where one alternative is <code>T</code>, <code>o</code> is a <code>std::optional&lt;T&gt;</code>, and <code>a</code> is a <code>std::any</code>:</p> Some sample <code>as</code> casts Cpp1 equivalent <code>x as Y</code> <code>Y{x}</code> <code>pb as *D</code> <code>dynamic_cast&lt;D*&gt;(pb)</code> <code>v as T</code> <code>std::get&lt;T&gt;(v)</code> <code>a as T</code> <code>std::any_cast&lt;T&gt;(a)</code> <code>o as T</code> <code>o.value()</code> <p>Note: <code>as</code> unifies a variety of differently-named Cpp1 language and library casts and conversions under one syntax, and supports only the type-safe ones.</p>"},{"location":"cpp2/expressions/#unchecked-explicitly-type-unsafe-casts","title":"Unchecked (explicitly type-unsafe) casts","text":"<p>Casts that are not known to be type-safe at compile time must always be explicit.</p> <p>To perform a numeric narrowing cast, such as <code>i32</code> to <code>i16</code> or <code>u32</code>, use <code>unchecked_narrow&lt;To&gt;(from)</code>. Otherwise, if you must perform any other type-unsafe cast, use <code>unchecked_cast&lt;To&gt;(from)</code>. For example:</p> Type-unsafe narrowing and casts must be explicit<pre><code>f: (i: i32, inout s: std::string) = {\n    // j := i as i16;                     // error, maybe-lossy narrowing\n    j := unchecked_narrow&lt;i16&gt;(i);           // ok, 'unchecked' is explicit\n\n    pv: *void = s&amp;;\n    // pi := pv as *std::string;          // error, type-unsafe cast\n    pi := unchecked_cast&lt;*std::string&gt;(pv);  // ok, 'unchecked' is explicit\n}\n</code></pre>"},{"location":"cpp2/expressions/#inspect-pattern-matching","title":"<code>inspect</code> \u2014 pattern matching","text":"<p>An <code>inspect expr -&gt; Type = { /* alternatives */ }</code> expression allows pattern matching using <code>is</code>.</p> <ul> <li> <p><code>expr</code> is evaluated once.</p> </li> <li> <p>Each alternative is spelled <code>is C = statement;</code> and are evaluated in order. Each <code>is C</code> is evaluated as if called with <code>expr is C</code>, and if it evaluates to <code>true</code>, then its <code>= alternative;</code> body is used as the value of the entire <code>inspect</code> expression, and the meaning is the same as if the entire <code>inspect</code> expression had been written as just <code>:Type = alternative;</code> \u2014 i.e., an unnamed object expression (aka 'temporary object') of type <code>Type</code> initialized with <code>alternative</code>.</p> </li> <li> <p>A catchall <code>is _</code> is required.</p> </li> </ul> <p>For example:</p> Using inspect<pre><code>//  A generic function that takes an argument 'x' of any type\n//  and inspects various things about `x`\ntest: (x) = {\n    forty_two := 42;\n    std::cout\n        &lt;&lt; inspect x -&gt; std::string {\n            is 0           = \"zero\";            // == 0\n            is (forty_two) = \"the answer\";      // == 42\n            is int         = \"integer\";         // is type int (and not 0 or 42)\n            is std::string = x as std::string;  // is type std::string\n            is std::vector = \"a std::vector\";   // is a vector&lt;/*of-some-type*/&gt;\n            is _           = \"(no match)\";      // is something else\n        }\n        &lt;&lt; \"\\n\";\n}\n\n//  Sample call site\ntest(42);\n    //  Behaves as if the following function were called:\n    //      test: (x) = { std::cout &lt;&lt; (:std::string = \"the answer\") &lt;&lt; \"\\n\"; }\n    //  (and that's why inspect alternatives are introduced with '=')\n</code></pre> <p>For more examples, see also the examples in the previous two sections on <code>is</code> and <code>as</code>, many of which use <code>inspect</code>.</p>"},{"location":"cpp2/expressions/#and-range-operators","title":"<code>..&lt;</code> and <code>..=</code> \u2014 range operators","text":"<p><code>..&lt;</code> and <code>..=</code> designate a range of things. Use <code>begin ..&lt; end</code> for a half-open range (that does not include <code>end</code>) and <code>first ..= last</code> for a closed range (that does include <code>last</code>, and <code>last</code> must be a valid value and must be valid to increment once). These operators work for any type that supports <code>++</code>; they start with the <code>first</code> value, and use <code>++</code> to increment until they reach the <code>last</code> value (which is included by <code>..=</code>, and not included by <code>..&lt;</code>).</p> <p>Note: For all numeric ranges, <code>last</code>'s value must be reachable by incrementing <code>first</code> a finite number of times. For <code>..=</code> closed numeric ranges, <code>last</code> must not be <code>std::numeric_limits&lt;size_t&gt;::max()</code> or <code>std::numeric_limits&lt;ptrdiff_t&gt;::max()</code>.</p> <p>For example:</p> Using ..&lt; and ..= for ranges<pre><code>test: (v: std::vector&lt;std::string&gt;) =\n{\n    //  Print strings from \"Nonesuch\" (if present) onward\n    i1 := v.std::ranges::find(\"Nonesuch\");\n    for i1 ..&lt; v.end() do (e) {\n        std::cout &lt;&lt; \"  (e*)$\\n\";\n    }\n\n    if v.ssize() &gt; 2 {\n        //  Print indexes 1 and 2 of v\n        for 1 ..= 2 do (e) {\n            std::cout &lt;&lt; \"  (e)$  (v[e])$\\n\";\n        }\n    }\n\n    std::cout &lt;&lt; \"  ((1 ..= 100).sum())$ \\n\";\n    std::cout &lt;&lt; \"  ((1 ..&lt; 100).contains(99))$ \\n\";\n    std::cout &lt;&lt; \"  ((1 ..&lt; 100).contains(100))$ \\n\";\n}\n\nmain: () = {\n    vec: std::vector&lt;std::string&gt; = (\"Beholder\", \"Grue\", \"Nonesuch\", \"Wumpus\");\n    test( vec );\n}\n//  Prints:\n//    Nonesuch\n//    Wumpus\n//    1  Grue\n//    2  Nonesuch\n//    5050\n//    true\n//    false\n</code></pre>"},{"location":"cpp2/expressions/#captures-including-interpolations","title":"<code>$</code> \u2014 captures, including interpolations","text":"<p>Suffix <code>$</code> is pronounced \"paste the value of\" and captures the value of an expression at the point when the expression where the capture is written is evaluated. Depending on the complexity of the capture expression <code>expr$</code> and where it is used, parentheses <code>(expr)$</code> may be required for precedence or to show the boundaries of the expression.</p> <p><code>x$</code> always captures <code>x</code> by value. To capture by reference, take the address and capture a pointer using <code>x&amp;$</code>. If the value is immediately used, dereference again; for example <code>:(val) total&amp;$* += val</code> adds to the <code>total</code> local variable itself, not a copy.</p> <p>Captures are evaluated at the point where they are written in function expressions, contract postconditions, and string literals. The stored captured value can then be used later when evaluating its context, such as when the function expression body containing the captured value is actually called later (one or more times), when the postcondition containing the captured value is evaluated later when the function returns, or when the string literal containing the captured value is read later.</p> <p>The design and syntax are selected so that capture is spelled the same way in all contexts. For details, see Design note: Capture.</p>"},{"location":"cpp2/expressions/#capture-in-function-expressions-aka-lambdas","title":"Capture in function expressions (aka lambdas)","text":"<p>Any capture in a function expression body is evaluated at the point where the function expression is written, at the declaration of the function expression. The function expression itself is then evaluated each time the function is invoked, and can reference the captured value.</p> <p>For example:</p> Capture in an unnamed function expression (aka lambda)<pre><code>main: () = {\n    s := \"-ish\\n\";\n    vec: std::vector = (1, 2, 3, 5, 8, 13 );\n\n    std::ranges::for_each(\n        vec,\n        :(i) = std::cout &lt;&lt; i &lt;&lt; s$\n        //  Function capture: Paste the value of 's'\n    );\n}\n\n//  prints:\n//      1-ish\n//      2-ish\n//      3-ish\n//      5-ish\n//      8-ish\n//      13-ish\n</code></pre> <p>Another example:</p> Capture in a named function expression (aka lambda)<pre><code>main: () = {\n    price := 100;\n    func := // Note: 'func' is a named variable of deduced type initialized to ...\n        :() = { std::cout &lt;&lt; \"Price = \" &lt;&lt; price$ &lt;&lt; \"\\n\"; }  // ... this lambda\n        ;   // This is a way to declare 'local functions', which can also capture\n            // (In the future, Cpp2 may directly support local functions)\n    func();\n    price = 200;\n    func();\n}\n\n//  prints:\n//      Price = 100\n//      Price = 100\n</code></pre>"},{"location":"cpp2/expressions/#capture-in-contract-postconditions","title":"Capture in contract postconditions","text":"<p>Any capture in a postcondition is evaluated at the point where the postcondition is written, at the beginning (entry) of the function. The postcondition itself is then evaluated when the function returns, and can reference the captured value.</p> <p>For example:</p> Capture in contract postconditions<pre><code>push_back: (coll, value)\n    post(coll.ssize() == coll.ssize()$ + 1)\n    //  Paste the value of `coll.ssize()`\n= {\n    // ...\n}\n</code></pre>"},{"location":"cpp2/expressions/#capture-in-string-interpolation","title":"Capture in string interpolation","text":"<p>A string literal can capture the value of an expression <code>expr</code> by writing <code>(expr)$</code> inside the string literal. The <code>(</code> <code>)</code> are required, and cannot be nested. A string literal has type <code>std::string</code> if it performs any captures, otherwise it is a normal C/C++ string literal (array of characters).</p> <p>Any capture in a string literal is evaluated at the point where the string literal is written. The string literal can be used repeatedly later, and includes the captured value.</p> <p>For example:</p> Capture for string interpolation<pre><code>x := 0;\nstd::cout &lt;&lt; \"x is (x)$\\n\";\n        // Paste the value of `x`\nx = 1;\nstd::cout &lt;&lt; \"now x+2 is (x+2)$\\n\";\n        // Paste the value of `x+2`\n\n//  prints:\n//      x is 0\n//      now x+2 is 3\n</code></pre> <p>A string literal capture can include a <code>:suffix</code> where the suffix is a standard C++ format specification. For example, <code>(x.price(): &lt;10.2f)$</code> evaluates <code>x.price()</code> and converts the result to a string with 10-character width, 2 digits of precision, and left-justified.</p>"},{"location":"cpp2/functions/","title":"Functions","text":""},{"location":"cpp2/functions/#overview","title":"Overview","text":"<p>A function is defined by writing a function signature after the <code>:</code> and a statement (expression or <code>{</code> <code>}</code> compound statement) after the <code>=</code>. After the optional template parameters available for all declarations, a function signature consists of a possibly-empty parameter list, and one or more optional return values.</p> <p>For example, the minimal function named <code>func</code> that takes no parameters and returns nothing (<code>void</code>) is:</p> A minimal function<pre><code>func: ( /* no parameters */ ) = { /* empty body */ }\n</code></pre>"},{"location":"cpp2/functions/#function-signatures-parameters-returns-and-using-function-types","title":"Function signatures: Parameters, returns, and using function types","text":""},{"location":"cpp2/functions/#overview_1","title":"Overview","text":"<p>There are six kinds of function parameters, and two of them are the kinds of functions returns:</p> Kind Parameter Return <code>in</code> \u2b50 <code>inout</code> \u2705 <code>out</code> \u2705 <code>copy</code> \u2705 <code>move</code> \u2705 \u2705 <code>forward</code> \u2705 \u2b50 <p>The two cases marked \u2b50 can automatically pass/return by value or by reference, and so they can be optionally written with <code>_ref</code> to require pass/return by reference and not by value (i.e., <code>in_ref</code>, <code>-&gt; forward_ref</code>).</p> <p>That's it. For details, see below.</p>"},{"location":"cpp2/functions/#parameters","title":"Parameters","text":"<p>The parameter list is a list enclosed by <code>(</code> <code>)</code> parentheses. Each parameter is declared using the same unified syntax as used for all declarations. For example:</p> Declaring parameters<pre><code>func: (\n    x: i32,                         // parameter x is a 32-bit int\n    y: std::string,                 // parameter y is a std::string\n    z: std::map&lt;i32, std::string&gt;   // parameter z is a std::map\n    )\n= {\n    // ...\n}\n</code></pre> <p>The parameter type can be deduced by writing <code>_</code> (the default, so it can be omitted). You can use <code>is</code> to declare a type constraint (e.g., a concept) that a deduced type must match, in which case <code>_</code> is required. For example:</p> Declaring a parameter of constrained deduced type<pre><code>//  ordinary generic function, x's type is deduced\nprint: (x: _) = { std::cout &lt;&lt; x; }\nprint: (x)    = { std::cout &lt;&lt; x; } // same, using the _ default\n\n//  number's type is deduced, but must match the std::integral concept\ncalc: (number: _ is std::integral) = { /*...*/ }\n</code></pre> <p>There are six ways to pass parameters that cover all use cases, that can be written before the parameter name:</p> Parameter\u00a0kind \"Pass an <code>x</code> the function ______\" Accepts arguments that are Special semantics kind <code>x: X</code> compiles\u00a0to\u00a0Cpp1\u00a0as <code>in</code> (default) can read from anything always <code>const</code><p>automatically passes by value if cheaply copyableto guarantee a by-reference passing, use <code>in_ref</code> <code>X const x</code> or  <code>X const&amp; x</code> <code>copy</code> gets a copy of anything acts like a normal local variable initialized with the argument <code>X x</code> <code>inout</code> can read from and write to lvalues <code>X&amp; x</code> <code>out</code> writes to (including construct) lvalues (including uninitialized) must <code>=</code> assign/construct before other uses <code>cpp2::impl::out&lt;X&gt;</code> <code>move</code> moves from (consume the value of) rvalues automatically moves from every definite last use <code>X&amp;&amp;</code> <code>forward</code> forwards anything automatically forwards from every definite last use <code>auto&amp;&amp;</code>, and if a specific type is named also a <code>requires</code>-constraint requiring convertibilty to that type <p>Note: All parameters and other objects in Cpp2 are <code>const</code> by default, except for local variables. For details, see Design note: <code>const</code> objects by default.</p> <p>For example:</p> Declaring parameter kinds<pre><code>append_x_to_y: (\n    x       : i32,          // an i32 I can read from (i.e., const)\n    inout y : std::string   // a string I can read from and write to\n    )\n= {\n    y = y + to_string(x);   // read x, read and write y\n}\n\nwrap_f: (\n    forward x               // a generic value of deduced type I can forward\n)                           //  (omitting x's  type means the same as ': _')\n= {\n    global_counter += x;    // ok to read x\n    f(x);                   // last use: automatically does 'std::forward&lt;T&gt;(x)'\n}\n</code></pre>"},{"location":"cpp2/functions/#return-values","title":"Return values","text":"<p>A function can return either a single anonymous return value, or a return parameter list containing named return value(s). The default is <code>-&gt; void</code>.</p>"},{"location":"cpp2/functions/#single-anonymous-return-values","title":"Single anonymous return values","text":"<p><code>-&gt;</code> kind <code>X</code> to return a single unnamed value of type <code>X</code> using the same kinds as in the parameters syntax, but where the only legal kinds are <code>move</code> (the default) or <code>forward</code> (with optional <code>forward_ref</code>; see below).  The type can be  <code>-&gt; void</code> to signify the function has no return value. If <code>X</code> is not <code>void</code>, the function body must have a <code>return /*value*/;</code> statement that returns a value of type <code>X</code> on every path that exits the function, or must be a single expression of type <code>X</code>.</p> <p>To deduce the return type, write <code>_</code>:</p> <ul> <li><code>-&gt; _</code> deduces by-value return.</li> <li><code>-&gt; forward _</code> deduces by-value return (if the function returns a prvalue or type member object) or by-reference return (everything else), based on the <code>decltype</code> of the returned expression.</li> <li><code>-&gt; forward_ref _</code> deduces by-reference return only.</li> </ul> <p>A function whose body is a single expression <code>= expr;</code> defaults to <code>-&gt; forward _ = { return expr; }</code>.</p> <p>For example:</p> Functions with an unnamed return value<pre><code>//  A function returning no value (void)\nincrement_in_place: (inout a: i32) -&gt; void = { a++; }\n//  Or, using syntactic defaults, the following has identical meaning:\nincrement_in_place: (inout a: i32) = { a++; }\n\n//  A function returning a single value of type i32\nadd_one: (a: i32) -&gt; i32 = { return a+1; }\n//  Or, using syntactic defaults, the following has identical meaning:\nadd_one: (a: i32) -&gt; i32 = a+1;\n\n//  A generic function returning a single value of deduced type\nadd: &lt;T: type, U: type&gt; (a:T, b:U) -&gt; forward _ = { return a+b; }\n//  Or, using syntactic defaults, the following have identical meaning:\nadd: (a, b) -&gt; forward _ = a+b;\nadd: (a, b) a+b;\n\n//  A generic function expression returning a single value of deduced type\nvec.std::ranges::sort( :(x:_, y:_) -&gt; forward _ = { return y&lt;x; } );\n//  Or, using syntactic defaults, the following has identical meaning:\nvec.std::ranges::sort( :(x,y) = y&lt;x );\n//  Both are identical to this, which uses the most verbose possible syntax:\nvec.std::ranges::sort( :&lt;X:type, Y:type&gt; (x:X, y:Y) -&gt; forward _ = { return y&lt;x; } );\n</code></pre>"},{"location":"cpp2/functions/#return-parameter-lists-nameable-return-values","title":"Return parameter lists: Nameable return value(s)","text":"<p><code>-&gt; ( /* parameter list */ )</code> to return a list of named return parameters using the same parameters syntax, but where the only needed kinds are <code>out</code> (the default, which moves where possible) or <code>forward</code>. The function body must initialize the value of each return-parameter <code>ret</code> in its body the same way as any other local variable. An explicit return statement is written just <code>return;</code> and returns the named values; the function has an implicit <code>return;</code> at the end. If only a single return parameter is in the list, it is emitted in the lowered Cpp1 code the same way as a single anonymous return value above, so its name is only available inside the function body.</p> <p>For example:</p> Function with multiple/named return values<pre><code>divide: (dividend: int, divisor: int) -&gt; (quotient: int, remainder: int) = {\n    if divisor == 0 {\n        quotient  = 0;                      // constructs quotient\n        remainder = 0;                      // constructs remainder\n    }\n    else {\n        quotient = dividend / divisor;      // constructs quotient\n        remainder = dividend % divisor;     // constructs remainder\n    }\n}\n\nmain: () = {\n    div := divide(11, 5);\n    std::cout &lt;&lt; \"(div.quotient)$, (div.remainder)$\\n\";\n}\n//  Prints:\n//     2, 1\n</code></pre> <p>This next example declares a member function with multiple return values in a type named <code>set</code>:</p> Member function with multiple/named return values<pre><code>set: &lt;Key&gt; type = {\n    container: std::set&lt;Key&gt;;\n    iterator : type == std::set&lt;Key&gt;::iterator;\n\n    //  A std::set::insert-like function using named return values\n    //  instead of just a std::pair/tuple\n    insert: (inout this, value: Key) -&gt; (where: iterator, inserted: bool) = {\n        set_returned := container.insert(value);\n        where    = set_returned.first;\n        inserted = set_returned.second;\n    }\n\n    ssize: (this) -&gt; i64 = std::ssize(container);\n\n    // ...\n}\n\nuse_inserted_position: (_) = { }\n\nmain: () = {\n    m: set&lt;std::string&gt; = ();\n    ret := m.insert(\"xyzzy\");\n    if ret.inserted {\n        use_inserted_position( ret.where );\n    }\n    assert( m.ssize() == 1 );\n}\n</code></pre>"},{"location":"cpp2/functions/#function-outputs-are-not-implicitly-discardable","title":"Function outputs are not implicitly discardable","text":"<p>A function's outputs are its return values, and the \"out\" state of any <code>out</code> and <code>inout</code> parameters.</p> <p>Function outputs cannot be silently discarded. To explicitly discard a function output, assign it to <code>_</code>. For example:</p> No silent discard<pre><code>f: ()             -&gt; void = { }\ng: ()             -&gt; int  = { return 10; }\nh: (inout x: int) -&gt; void = { x = 20; }\n\nmain: ()\n= {\n    f();                    // ok, no return value\n\n    std::cout &lt;&lt; g();       // ok, use return value\n\n    _ = g();                // ok, explicitly discard return value\n\n    g();                    // ERROR, return value is ignored\n\n    {\n        x := 0;\n        h( x );             // ok, x is referred to again...\n        std::cout &lt;&lt; x;     // ... here, so its new value is used\n    }\n\n    {\n        x := 0;\n        h( x );             // ok, x is referred to again...\n        _ = x;              // ... here where its value explicitly discarded\n    }\n\n    {\n        x := 0;\n        h( x );             // ERROR, this is a definite last use of x\n    }                       // so x is not referred to again, and its\n                            // 'out' value can't be implicitly discarded\n}\n</code></pre> <p>Cpp2 imbues Cpp1 code with nondiscardable semantics, while staying fully compatible as usual:</p> <ul> <li> <p>A function written in Cpp2 syntax that returns something other than <code>void</code> is always compiled to Cpp1 with <code>[[nodiscard]]</code>.</p> </li> <li> <p>A function call written in Cpp2 <code>x.f()</code> member call syntax always treats a non-<code>void</code> return type as not discardable, even if the function was written in Cpp1 syntax that did not write <code>[[nodiscard]]</code>.</p> </li> </ul> <p>For details and rationale, see Design note: Explicit discard.</p>"},{"location":"cpp2/functions/#using-function-types","title":"Using function types","text":"<p>The same function parameter/return syntax can be used as a function type, for example to instantiate <code>std::function</code> or to declare a pointer to function variable. For example:</p> Using function types with std::function and *pfunc<pre><code>decorate_int: (i: i32) -&gt; std::string = \"--&gt; (i)$ &lt;--\";\n\nmain: () = {\n    pf1: std::function&lt; (i: i32) -&gt; std::string &gt; = decorate_int&amp;;\n    std::cout &lt;&lt; \"pf1(123) returned \\\"(pf1(123))$\\\"\\n\";\n\n    pf2: * (i: i32) -&gt; std::string = decorate_int&amp;;\n    std::cout &lt;&lt; \"pf2(456) returned \\\"(pf2(456))$\\\"\\n\";\n}\n//  Prints:\n//    pf1 returned \"--&gt; 123 &lt;--\"\n//    pf2 returned \"--&gt; 456 &lt;--\"\n</code></pre>"},{"location":"cpp2/functions/#control-flow","title":"Control flow","text":""},{"location":"cpp2/functions/#if-else-branches","title":"<code>if</code>, <code>else</code> \u2014 Branches","text":"<p><code>if</code> and <code>else</code> are like always in C++, except that <code>(</code> <code>)</code> parentheses around the condition are not required. Instead, <code>{</code> <code>}</code> braces around a branch body are required. For example:</p> Using if and else<pre><code>if vec.ssize() &gt; 100 {\n    do_general_algorithm( container );\n}\nelse {\n    do_linear_scan( vec );\n}\n</code></pre>"},{"location":"cpp2/functions/#for-while-do-loops","title":"<code>for</code>, <code>while</code>, <code>do</code> \u2014 Loops","text":"<p><code>do</code> and <code>while</code> are like always in C++, except that <code>(</code> <code>)</code> parentheses around the condition are not required. Instead, <code>{</code> <code>}</code> braces around the loop body are required.</p> <p><code>for range do (e)</code> statement says \"for each element in <code>range</code>, call it <code>e</code> and perform the statement.\" The loop parameter <code>(e)</code> is an ordinary parameter that can be passed using any parameter kinds; as always, the default is <code>in</code>, which is read-only and expresses a read-only loop. The statement is not required to be enclosed in braces.</p> <p>Every loop can have a <code>next</code> clause, that is performed at the end of each loop body execution. This makes it easy to have a counter for any loop, including a range <code>for</code> loop.</p> <p>Note: Whitespace is just a stylistic choice. This documentation's style generally puts each keyword on its own line and lines up what follows.</p> <p>For example:</p> Using loops<pre><code>words: std::vector&lt;std::string&gt; = (\"Adam\", \"Betty\");\ni := 0;\n\nwhile i &lt; words.ssize() // while this condition is true\nnext  i++               // and increment i after each loop body is run\n{                       // do this loop body\n    std::cout &lt;&lt; \"word: (words[i])$\\n\";\n}\n//  prints:\n//      word: Adam\n//      word: Betty\n\ndo {                    // do this loop body\n    std::cout &lt;&lt; \"**\\n\";\n}\nnext  i--               // and decrement i after each loop body is run\nwhile i &gt; 0;            // while this condition is true\n//  prints:\n//      **\n//      **\n\nfor  words              // for each element in 'words'\nnext i++                // and increment i after each loop body is run\ndo   (inout word)       // declare via 'inout' the loop can change the contents\n{                       // do this loop body\n    word = \"[\" + word + \"]\";\n    std::cout &lt;&lt; \"counter: (i)$, word: (word)$\\n\";\n}\n//  prints:\n//      counter: 0, word: [Adam]\n//      counter: 1, word: [Betty]\n</code></pre> <p>There is no special \"select\" or \"where\" to perform the loop body for only a subset of matches, because this can naturally be expressed with <code>if</code>. For example:</p> Using loops + if<pre><code>//  Continuing the previous example\ni = 0;\n\nfor  words\nnext i++\ndo   (word)\nif   i % 2 == 1         // if i is odd\n{                       // do this loop body\n    std::cout &lt;&lt; \"counter: (i)$, word: (word)$\\n\";\n}\n//  prints:\n//      counter: 1, word: [Betty]\n</code></pre> <p>Here is the equivalent of the Cpp1 code <code>for ( int i = 0; i &lt; 10; ++i ){ std::cout &lt;&lt; i; }</code>:</p> Equivalent of Cpp1 'for ( int i = 0; i &lt; 10; ++i ){ std::cout &lt;&lt; i; }'<pre><code>(copy i := 0)\nwhile i &lt; 10\nnext  i++ {\n    std::cout &lt;&lt; i;\n}\n</code></pre> <p>Line by line:</p> <ul> <li><code>(copy i := 0)</code>: Any statement can have statement-local parameters, and this is declaring <code>i</code> as an <code>int</code> that's local to the loop. Parameters by default are <code>const</code>, and for not-cheap-to-copy types they bind to the original value; so because we want to modify <code>i</code> we say <code>copy</code> to explicitly declare this is the loop's own mutable scratch variable.</li> <li><code>while i &lt; 10</code>: The termination condition.</li> <li><code>next i++</code>: The end-of-loop-iteration statement. Note <code>++</code> is always postfix in Cpp2.</li> </ul>"},{"location":"cpp2/functions/#loop-names-break-and-continue","title":"Loop names, <code>break</code>, and <code>continue</code>","text":"<p>Loops can be named using the usual name <code>:</code> syntax that introduces all names, and <code>break</code> and <code>continue</code> can refer to those names. For example:</p> Using named break and continue<pre><code>outer: while i&lt;M next i++ {      // loop named \"outer\"\n    // ...\n    inner: while j&lt;N next j++ {  // loop named \"inner\"\n        // ...\n        if something() {\n            continue inner;      // continue the inner loop\n        }\n        // ...\n        if something_else() {\n            break outer;         // break the outer loop\n        }\n        // ...\n    }\n    // ...\n}\n</code></pre>"},{"location":"cpp2/functions/#throw-try-catch-exceptions","title":"<code>throw</code>, <code>try</code>, <code>catch</code> \u2014 Exceptions","text":"<p><code>throw</code>, <code>try</code> and <code>catch</code> are like always in C++, except:</p> <ul> <li><code>throw(something)</code> requires parentheses around the thrown value</li> <li><code>catch</code> uses Cpp2's usual parameter syntax, so you can write <code>catch(obj: type)</code> to catch an exception of a specific type, and <code>catch(_)</code> to catch any thrown exception</li> </ul> <p>For example:</p> Throw, try, catch<pre><code>//  This program will print \"caught something else\"\nmain: () = {\n    try {\n        throw( \"xyzzy\" );\n    }\n    catch( i: int ) {\n        std::cout &lt;&lt; \"caught int with value \" &lt;&lt; i;\n    }\n    catch( _ ) {\n        std::cout &lt;&lt; \"caught something else\";\n    }\n}\n</code></pre>"},{"location":"cpp2/functions/#static-global-variables-inside-functions","title":"<code>static</code> \u2014 Global variables inside functions","text":"<p><code>static</code> can be specified as the first token of a local variable declaration at function scope, to denote that the variable is a global value initialized thread-safely the first time the line is executed (aka C++ \"function local static,\" aka \"magic static\").</p> <p>For example (see also <code>@singleton</code>):</p> static variable (function local scope only)<pre><code>//  For exposition only - normally, use @singleton for convenience\nmy_singleton: type = {\n    value    : int = 42;\n\n    print    : (this) = std::cout &lt;&lt; \"(value)$\\n\";\n\n    //--------------------------------------------------------------------\n    //  writing '@singleton type' above would generate these two functions\n    //  but this example shows them for exposition of 'static'\n    //\n    private\n    operator=: (out this) = { }\n\n    instance : () -&gt; forward my_singleton = { \n        static _instance: my_singleton = ();    // singleton variable\n        return _instance; \n    }\n    //--------------------------------------------------------------------\n}\n\nmain: () = {\n    my_singleton::instance().print();\n}\n</code></pre>"},{"location":"cpp2/functions/#moveforward-from-definite-last-use","title":"Move/forward from definite last use","text":"<p>In a function body, a definite last use of a local name is a single use of that name in a statement that is not in a loop, where no control flow path after that statement mentions the name again.</p> <p>For each definite last use:</p> <ul> <li> <p>If the name is a <code>copy</code> or <code>move</code> parameter or is a local object whose name does not start with <code>guard</code>, we know the object will not be used again before being destroyed, and so the object is automatically treated as an rvalue (move candidate). If the expression that contains the last use is able to move from the rvalue, the move will happen automatically.</p> </li> <li> <p>If the name is a <code>forward</code> parameter, the object is automatically forwarded to preserve its constness and value category (<code>std::forward</code>-ed).</p> </li> </ul> <p>Note: This gives language meaning to a naming convention of <code>guard</code> as a name prefix for \"guard\" stack objects, such as local <code>std::scoped_lock</code> objects, whose destructors are always the object's real last use.</p> <p>For example:</p> Definite last uses<pre><code>f: (\n    copy    x: some_type,\n    move    y: some_type,\n    forward z: some_type\n    )\n= {\n    w: some_type = \"y\";\n\n    prepare(x);                     // NOT a definite last use\n\n    if something() {\n        process(y);\n        z.process(x);               // definite last uses of x and z\n    }\n    else {\n        cout &lt;&lt; z;                  // definite last use of z\n    }\n\n    transfer(y);                    // definite last use of y\n\n    offload(w);                     // definite last use of w\n}\n</code></pre> <p>In this example:</p> <ul> <li> <p><code>x</code> has a definite last use on one path, but not another. Line 13 is a definite last use that automatically treats <code>x</code> as an rvalue. However, if the <code>else</code> is taken, <code>x</code> gets no special automatic handling. Line 9 is not a definite last use because <code>x</code> could be used again where it is mentioned later on line 13.</p> </li> <li> <p><code>y</code> has a definite last use on every path, in this case the same on all executions of the function. Line 19 is a definite last use that automatically treats <code>x</code> as an rvalue.</p> </li> <li> <p><code>z</code> has a definite last use on every path, but unlike <code>y</code> it can be a different last use on different executions of the function. That's fine, each of lines 13 and 16 is a definite last use that automatically forwards the constness and value category of <code>z</code>.</p> </li> <li> <p><code>w</code> has a definite last use on every path, in this case the same on all executions of the function. Line 21 is a definite last use that automatically treats <code>w</code> as an rvalue.</p> </li> </ul>"},{"location":"cpp2/functions/#generality-note-summary-of-function-defaults","title":"Generality note: Summary of function defaults","text":"<p>There is a single function syntax, designed so we can just omit the parts we're not currently using.</p> <p>For example, let's express in full verbose detail that <code>equals</code> is a function template that has two type parameters <code>T</code> and <code>U</code>, two ordinary <code>in</code> parameters <code>a</code> and <code>b</code> of type <code>T</code> and <code>U</code> respectively, and a deduced return type, and its body returns the result of <code>a == b</code>:</p> equals: A generic function written in full detail (using no defaults)<pre><code>equals: &lt;T: type, U: type&gt; (in a: T, in b: U) -&gt; _ = { return a == b; }\n</code></pre> <p>We can write all that, but we don't have to.</p> <p>First, <code>: type</code> is the default for template parameters, so we can omit it since that's what we want:</p> equals: Identical meaning, now using the :type default for template parameters<pre><code>equals: &lt;T, U&gt; (in a: T, in b: U) -&gt; _ = { return a == b; }\n</code></pre> <p>So far, the return type is already using one common default available throughout Cpp2: the wildcard <code>_</code> (pronounced \"don't care\"). Since this function's body doesn't actually use the parameter type names <code>T</code> and <code>U</code>, we can just use wildcards for the parameter types too:</p> equals: Identical meaning, now using the _ wildcard also for the parameter types<pre><code>equals: (in a: _, in b: _) -&gt; _ = { return a == b; }\n</code></pre> <p>Next, <code>: _</code> is also the default parameter type, so we don't need to write even that:</p> equals: Identical meaning, now using the :_ default parameter type<pre><code>equals: (in a, in b) -&gt; _ = { return a == b; }\n</code></pre> <p>Next, <code>in</code> is the default parameter kind. So we can use that default too:</p> equals: Identical meaning, now using the 'in' default parameter kind<pre><code>equals: (a, b) -&gt; _ = { return a == b; }\n</code></pre> <p>We already saw that <code>{ return</code> ... <code>; }</code> is the default for a single-expression function body that deduces its return type:</p> equals: Identical meaning, now using the { return ... } default body decoration<pre><code>equals: (a, b) -&gt; _ = a == b;\n</code></pre> <p>Next, <code>-&gt; forward _</code> (fully deduced return type) is the default for single-expression functions that return something, and in this case will have the same meaning as <code>-&gt; _</code> :</p> equals: Identical meaning, now using the -&gt; _ = default for functions that return something<pre><code>equals: (a, b) = a == b;\n</code></pre> <p>Finally, at expression scope (aka \"lambda/temporary\") functions/objects aren't named, and the trailing <code>;</code> is optional:</p> (not) 'equals': Identical meaning, but without a name as an unnamed function at expression scope<pre><code>:(a, b) = a == b\n</code></pre> <p>Here are some additional examples of unnamed function expressions:</p> Some more examples of unnamed function expressions<pre><code>std::ranges::for_each( a, :(x) = std::cout &lt;&lt; x );\n\nstd::ranges::transform( a, std::back_inserter(b), :(x) = x+1 );\n\nwhere_is = std::ranges::find_if( b, :(x) = x == waldo$ );\n</code></pre> <p>Note: Cpp2 doesn't have a separate \"lambda\" syntax; you just use the regular function syntax at expression scope to write an unnamed function, and the syntactic defaults are chosen to make such function expressions convenient to write. And because in Cpp2 every local variable capture (for example, <code>waldo$</code> above) is written in the body, it doesn't affect the function syntax.</p>"},{"location":"cpp2/metafunctions/","title":"Metafunctions","text":""},{"location":"cpp2/metafunctions/#overview","title":"Overview","text":"<p>A metafunction is a compile-time function that can participate in interpreting the meaning of a declaration, and can:</p> <ul> <li> <p>apply defaults (e.g., <code>interface</code> makes functions virtual by default)</p> </li> <li> <p>enforce constraints (e.g., <code>value</code> enforces that the type has no virtual functions)</p> </li> <li> <p>generate additional functions and other code (e.g., <code>value</code> generates copy/move/comparison operations for a type if it didn't write them explicitly)</p> </li> </ul> <p>The most important thing about metafunctions is that they are not hardwired language features \u2014 they are compile-time library code that uses the reflection and code generation API, that lets the author of an ordinary type easily opt into a named set of defaults, requirements, and generated contents. This approach is essential to making the language simpler, because it lets us avoid hardwiring special \"extra\" types into the language and compiler.</p>"},{"location":"cpp2/metafunctions/#applying-metafunctions-using","title":"Applying metafunctions using <code>@</code>","text":"<p>Metafunctions provide an easy way for a type author to opt into a group of defaults, constraints, and generated functions: Just write <code>@name</code> afer the <code>:</code> of a declaration, where <code>name</code> is the name of the metafunction. This lets the type author declare (and the human reader see) the intent up front: \"This isn't just any <code>type</code>, this is a <code>@value type</code>\" which automatically gives the type default/copy/move construction and assignment, <code>&lt;=&gt;</code> with <code>std::strong_ordering</code> comparisons, and guarantees that it has a public destructor and no protected or virtual functions:</p> Using the value metafunction when writing a type<pre><code>point2d: @value type = {\n    x: i32 = 0;\n    y: i32 = 0;\n    // @value automatically generates default/copy/move\n    // construction/assignment and &lt;=&gt; strong_ordering comparison,\n    // and emits an error if you try to write a non-public\n    // destructor or any protected or virtual function\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#generating-source-code-at-compile-time","title":"Generating source code at compile time","text":"<p>A metafunction applied to a definition using <code>@</code> gets to participate in interpreting the meaning of the definition by inspecting and manipulating the definition's parse tree. For example:</p> shape.cpp2: Using @interface @print<pre><code>shape: @interface @print type = {\n    draw   : (this);\n    move_by: (this, dx: double, dy: double);\n}\n</code></pre> <p>The above code:</p> <ul> <li> <p>applies <code>@interface</code>, which makes functions pure virtual by default and defines a virtual destructor with a do-nothing body if there isn't already a virtual destructor (among other things), and</p> </li> <li> <p>then applies <code>@print</code>, which pretty-prints the resulting parse tree as source code to the console so that we can see the results of what the first metafunction did.</p> </li> </ul> <p>The result of compiling this is the following cppfront output, which is the <code>@interface</code>-modified Cpp2 source code as printed by <code>@print</code>:</p> 'cppfront shape.cpp2' output to the console, from @print<pre><code>shape:/* @interface @print */ type =\n{\n    public draw:(virtual in this);\n\n    public move_by:(\n        virtual in this,\n        in dx: double,\n        in dy: double\n    );\n\n    operator=:(virtual move this) =\n    {\n    }\n}\n</code></pre> <p>Finally, cppfront also emits the following in <code>shape.cpp</code>:</p> 'cppfront shape.cpp' output to 'shape.cpp'<pre><code>class shape {\n    public: virtual auto draw() const -&gt; void = 0;\n    public: virtual auto move_by(cpp2::in&lt;double&gt; dx, cpp2::in&lt;double&gt; dy) const -&gt; void = 0;\n    public: virtual ~shape() noexcept;\n\n    public: shape() = default;\n    public: shape(shape const&amp;) = delete; /* No 'that' constructor, suppress copy */\n    public: auto operator=(shape const&amp;) -&gt; void = delete;\n\n};\n\nshape::~shape() noexcept{}\n</code></pre>"},{"location":"cpp2/metafunctions/#built-in-metafunctions","title":"Built-in metafunctions","text":"<p>The following metafunctions are provided in the box with cppfront.</p>"},{"location":"cpp2/metafunctions/#for-regular-value-like-types-copyable-comparable","title":"For regular value-like types (copyable, comparable)","text":""},{"location":"cpp2/metafunctions/#ordered-weakly_ordered-partially_ordered","title":"<code>ordered</code>, <code>weakly_ordered</code>, <code>partially_ordered</code>","text":"<p>An <code>ordered</code> (or <code>weakly_ordered</code> or <code>partially_ordered</code>) type has an <code>operator&lt;=&gt;</code> three-way comparison operator that returns <code>std::strong_ordering</code> (or <code>std::weak_ordering</code> or <code>std::partial_ordering</code>, respectively). This means objects of this type can be used in all binary comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&gt;</code>.</p> <p>If the user explicitly writes <code>operator&lt;=&gt;</code>, its return type must be the same as the one implied by the metafunction they chose.</p> <p>If the user doesn't explicitly write <code>operator&lt;=&gt;</code>, a default memberwise <code>operator&lt;=&gt;: (this, that) -&gt; /* appropriate _ordering */;</code> will be generated for the type.</p> <p>These metafunctions will emit a compile-time error if:</p> <ul> <li>a user-written <code>operator&lt;=&gt;</code> returns a different type than the one implied by the metafunction they chose</li> </ul> <p>Note: This feature derived from Cpp2 was already adopted into Standard C++ via paper P0515, so most of the heavy lifting is done by the Cpp1 C++20/23 compiler, including the memberwise default semantics. In contrast, cppfront has to do the work itself for default memberwise semantics for operator= assignment as those aren't yet part of Standard C++.</p>"},{"location":"cpp2/metafunctions/#copyable","title":"<code>copyable</code>","text":"<p>A <code>copyable</code> type has (copy and move) x (construction and assignment).</p> <p>If the user explicitly writes any of the copy/move <code>operator=</code> functions, they must also write the most general one that takes <code>(out this, that)</code>.</p> <p>If the user doesn't write any of the copy/move <code>operator=</code> functions, a default general memberwise <code>operator=: (out this, that) = { }</code> will be generated for the type.</p> <p><code>copyable</code> will emit a compile-time error if:</p> <ul> <li>there is a user-written <code>operator=</code> but no user-written <code>operator=: (out this, that)</code></li> </ul>"},{"location":"cpp2/metafunctions/#basic_value-value-weakly_ordered_value-partially_ordered_value","title":"<code>basic_value</code>, <code>value</code>, <code>weakly_ordered_value</code>, <code>partially_ordered_value</code>","text":"<p>A <code>basic_value</code> type is a regular type: <code>copyable</code>, default constructible, and not polymorphic (no protected or virtual functions).</p> <p>A <code>value</code> (or <code>weakly_ordered_value</code> or <code>partially_ordered_value</code>) is a <code>basic_value</code> that is also <code>ordered</code> (or <code>weakly_ordered</code> or <code>partially_ordered</code>, respectively).</p> <pre><code>graph TD;\n    value----&gt;basic_value;\n    weakly_ordered_value----&gt;basic_value;\n    partially_ordered_value----&gt;basic_value;\n    basic_value--&gt;copyable;\n    value--&gt;ordered;\n    partially_ordered_value--&gt;partially_ordered;\n    weakly_ordered_value--&gt;weakly_ordered;</code></pre> <p>These metafunctions will emit a compile-time error if:</p> <ul> <li> <p>any function is protected or virtual</p> </li> <li> <p>the type has a destructor that is not public</p> </li> </ul>"},{"location":"cpp2/metafunctions/#struct","title":"<code>struct</code>","text":"<p>A <code>struct</code> is a type with only public bases, objects, and functions, with no virtual functions, and with no user-defined constructors (i.e., no invariants) or assignment or destructors.</p> <p><code>struct</code> is implemented in terms of <code>cpp1_rule_of_zero</code>.</p> <p><code>struct</code> will emit a compile-time error if:</p> <ul> <li> <p>any member is non-public</p> </li> <li> <p>any function is virtual</p> </li> <li> <p>there is a user-written <code>operator=</code></p> </li> </ul>"},{"location":"cpp2/metafunctions/#hashable","title":"<code>hashable</code>","text":"<p>A <code>hashable</code> type provides a <code>hash: (this) -&gt; size_t</code> function that performs a memberwise hash of its data members using <code>std::hash</code>.</p>"},{"location":"cpp2/metafunctions/#for-polymorphic-types-interfaces-base-classes","title":"For polymorphic types (interfaces, base classes)","text":""},{"location":"cpp2/metafunctions/#interface","title":"<code>interface</code>","text":"<p>An <code>interface</code> type is an abstract base class having only pure virtual functions.</p> <p>Cpp2 has no <code>interface</code> feature hardwired into the language, as C# and Java do. Instead you apply the <code>@interface</code> metafunction when writing an ordinary <code>type</code>. For a detailed example, see the <code>shape</code> example above.</p> <p><code>interface</code> will emit a compile-time error if:</p> <ul> <li> <p>the type contains a data object</p> </li> <li> <p>the type has a copy or move function (the diagnostic message will suggest a virtual <code>clone</code> function instead)</p> </li> <li> <p>any function has a body</p> </li> <li> <p>any function is nonpublic</p> </li> </ul>"},{"location":"cpp2/metafunctions/#polymorphic_base","title":"<code>polymorphic_base</code>","text":"<p>A <code>polymorphic_base</code> type is a pure polymorphic base type that is not copyable, and whose destructor is either public and virtual or protected and nonvirtual.</p> <p>Unlike an interface, it can have nonpublic and nonvirtual functions.</p> <p><code>polymorphic_base</code> will emit a compile-time error if:</p> <ul> <li> <p>the type has a copy or move function (the diagnostic message will suggest a virtual <code>clone</code> function instead)</p> </li> <li> <p>the type has a destructor that is not public and virtual, and also not protected and nonvirtual</p> </li> </ul>"},{"location":"cpp2/metafunctions/#for-enumeration-types","title":"For enumeration types","text":""},{"location":"cpp2/metafunctions/#enum","title":"<code>enum</code>","text":"<p>Cpp2 has no <code>enum</code> feature hardwired into the language. Instead you apply the <code>@enum</code> metafunction when writing an ordinary <code>type</code>.</p> <p><code>enum</code> will emit a compile-time error if:</p> <ul> <li> <p>any member has the reserved name <code>operator=</code> or <code>operator&lt;=&gt;</code>, as these will be generated by the metafunction</p> </li> <li> <p>an enumerator is not public or does not have a deduced type</p> </li> </ul> <p>For example:</p> Using the @enum metafunction when writing a type<pre><code>// skat_game is declaratively a safe enumeration type: it has\n// default/copy/move construction/assignment and &lt;=&gt; with\n// std::strong_ordering, a minimal-size signed underlying type\n// by default if the user didn't specify a type, no implicit\n// conversion to/from the underlying type, in fact no public\n// construction except copy construction so that it can never\n// have a value different from its listed enumerators, inline\n// constexpr enumerators with values that automatically start\n// at 1 and increment by 1 if the user didn't write their own\n// value, and conveniences like to_string()... the word \"enum\"\n// carries all that meaning as a convenient and readable\n// opt-in, without hardwiring \"enum\" specially into the language\n//\nskat_game: @enum&lt;i16&gt; type = {\n    diamonds := 9;\n    hearts;  // 10\n    spades;  // 11\n    clubs;   // 12\n    grand    := 20;\n    null     := 23;\n}\n</code></pre> <p>Consider <code>hearts</code>: It's a member object declaration, but it doesn't have a type (or a default value) which is normally illegal, but here it's okay because the <code>@enum&lt;i16&gt;</code> metafunction fills them in: It iterates over all the data members and gives each one the underlying type (here explicitly specified as <code>i16</code>, otherwise it would be computed as the smallest signed type that's big enough), and an initializer (by default one higher than the previous enumerator).</p> <p>Unlike C <code>enum</code>, this <code>@enum</code> is scoped and strongly typed (does not implicitly convert to the underlying type).</p> <p>Unlike C++11 <code>enum class</code>, it's \"just a <code>type</code>\" which means it can naturally also have member functions and other things that a type can have:</p> An @enum type with a member function<pre><code>janus: @enum type = {\n    past;\n    future;\n\n    flip: (inout this) == {\n        if this == past { this = future; }\n        else { this = past; }\n    }\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#flag_enum","title":"<code>flag_enum</code>","text":"<p><code>flag_enum</code> is a variation on <code>enum</code> that has power-of-two default enumerator values, a default signed underlying type that is large enough to hold the values, and supports bitwise operators to combine and test values.</p> <p><code>flag_enum</code> will emit a compile-time error if:</p> <ul> <li> <p>any member has the reserved name <code>operator=</code>, <code>operator&lt;=&gt;</code>, <code>has</code>, <code>set</code>, <code>clear</code>, <code>to_string</code>, <code>get_raw_value</code>, or <code>none</code>, as these will be generated by the metafunction</p> </li> <li> <p>an enumerator is not public or does not have a deduced type</p> </li> <li> <p>the values are outside the range that can be represented by the largest default underlying type</p> </li> </ul> <p>For example:</p> Using the @flag_enum metafunction when writing a type<pre><code>// file_attributes is declaratively a safe flag enum type:\n// same as enum, but with a minimal-size unsigned underlying\n// type by default, and values that automatically start at 1\n// and rise by powers of two if the user didn't write their\n// own value, and bitwise operations plus .has(flags),\n// .set(flags), and .clear(flags)... the word \"flag_enum\"\n// carries all that meaning as a convenient and readable\n// opt-in without hardwiring \"[Flags]\" specially into the\n// language\n//\nfile_attributes: @flag_enum&lt;u8&gt; type = {\n    cached;     // 1\n    current;    // 2\n    obsolete;   // 4\n    cached_and_current := cached | current;\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#for-dynamic-types","title":"For dynamic types","text":""},{"location":"cpp2/metafunctions/#union","title":"<code>union</code>","text":"<p><code>@union</code> declaratively opts into writing a safe discriminated union/variant dynamic type.</p> <p><code>union</code> will emit a compile-time error if:</p> <ul> <li> <p>any alternative is not public or has an initializer</p> </li> <li> <p>any member starts with the reserved name prefix <code>is_</code> or <code>set_</code>, as these will be generated by the metafunction</p> </li> </ul> <p>For example:</p> Using the @union metafunction when writing a type<pre><code>// name_or_number is declaratively a safe union/variant type:\n// it has a discriminant that enforces only one alternative\n// can be active at a time, members always have a name, and\n// each member has .is_member(), .set_member(), and .member()\n// accessors using the member name... the word \"union\"\n// carries all that meaning as a convenient and readable\n// opt-in without hardwiring \"union\" specially into the\n// language\n//\nname_or_number: @union type = {\n    name: std::string;\n    num : i32;\n}\n\nmain: () = {\n    x: name_or_number = ();\n\n    x.set_name(\"xyzzy\");            // now x is a string\n    assert( x.is_name() );\n    std::cout &lt;&lt; x.name();          // prints the string\n\n    // trying to use x.num() here would cause a Type safety\n    // contract violation, because x is currently a string\n\n    x.set_num( 120 );               // now x is a number\n    std::cout &lt;&lt; x.num() + 3;       // prints 123\n}\n</code></pre> <p>Unlike C <code>union</code>, this <code>@union</code> is safe to use because it always ensures only the active type is accessed.</p> <p>Unlike C++11 <code>std::variant</code>, this <code>@union</code> is easier to use because its alternatives are anonymous, and safer to use because each union type is a distinct type. <sup>1</sup></p> <p>Each <code>@union</code> type has its own type-safe name, has clear and unambiguous named members, and safely encapsulates a discriminator to rule them all. It uses type-unsafe casts in the implementation, but they are fully encapsulated, where they can be tested once and be safe in all uses.</p> <p>Because a <code>@union type</code> is still a <code>type</code>, it can naturally have other things normal types can have, such as template parameter lists and member functions:</p> A templated custom safe union type<pre><code>name_or_other: @union &lt;T:type&gt; type\n= {\n    name  : std::string;\n    other : T;\n\n    // a custom member function\n    to_string: (this) -&gt; std::string = {\n        if is_name()       { return name(); }\n        else if is_other() { return other() as std::string; }\n        else               { return \"invalid value\"; }\n    }\n}\n\nmain: () = {\n    x: name_or_other&lt;int&gt; = ();\n    x.set_other(42);\n    std::cout &lt;&lt; x.other() * 3.14 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; x.to_string(); // prints \"42\" here, but is legal\n                                // whichever alternative is active\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#for-other-common-types","title":"For other common types","text":""},{"location":"cpp2/metafunctions/#encapsulated","title":"<code>encapsulated</code>","text":"<p>An <code>encapsulated</code> type is one that has no public data members.</p>"},{"location":"cpp2/metafunctions/#noncopyable","title":"<code>noncopyable</code>","text":"<p>A <code>noncopyable</code> type is one that has no user-defined copy or move functions (<code>operator=</code> with <code>this</code> and <code>that</code> parameters).</p>"},{"location":"cpp2/metafunctions/#singleton","title":"<code>singleton</code>","text":"<p>A <code>singleton</code> type is one that has only one global object (instance) in the whole program. The single object is initialized lazily the first time it is accessed. A singleton type has no constructors other than a generated default constructor (note: therefore all data members must have default values), and provides a generated <code>instance()</code> function to create and give access to the global instance.</p> <p>For example:</p> A templated custom safe union type<pre><code>my_singleton: @singleton type = {\n    value: int = 42;\n    print: (this) = std::cout &lt;&lt; \"(value)$\\n\";\n}\n\nmain: () = {\n    my_singleton::instance().print();\n}\n</code></pre>"},{"location":"cpp2/metafunctions/#for-computational-and-functional-types","title":"For computational and functional types","text":""},{"location":"cpp2/metafunctions/#autodiff","title":"<code>autodiff</code>","text":"<p>An <code>autodiff</code> type is extended so that derivatives can be computed. The metafunction adds for each function and member function a differentiated version. This is a proof of concept implementation. Expect it to break. A simple hello diff example is:</p> <pre><code>ad: @autodiff type = {\n    func: (x: double) -&gt; (r: double) = {\n        r = x * x;\n    }\n}\n\nmain: (args) = {\n    x := 3.0;\n    x_d := 1.0;\n\n    r := ad::func_d(x, x_d);\n\n    std::cout &lt;&lt; \"Derivative of 'x*x' at (x)$ is (r.r_d)$\" &lt;&lt; std::endl;\n}\n</code></pre> <p>The <code>@autodiff</code> metafunction mostly supports the forward mode of algorithmic differentiation. The reverse mode is only partly implemented and not yet well tested. See Supported autodiff features for a list of supported language features.</p> <p>Options can be given by text template arguments, e.g. <code>@autodiff&lt;\"reverse\"&gt;</code> enables the reverse mode. | Option | Description | | <code>\"reverse\"</code> | Reverse mode algorithmic differentiation. Default suffix <code>_b</code>. | | <code>\"order=&lt;n&gt;\"</code> | Higher order derivatives. <code>&lt;n&gt;</code> can be arbitrary. See <code>regression-tests/pure2-autodiff-higher-order.cpp2</code> for examples. | | <code>\"suffix=&lt;s&gt;\"</code> | Change the forward mode suffix. Can be used to apply autodiff multiple times. E.g. <code>@autodiff @autodiff&lt;\"suffix=_d2\"&gt;</code>. | | <code>\"rws_suffix=&lt;s&gt;\"</code> | Change the reverse mode suffix. |</p>"},{"location":"cpp2/metafunctions/#regex","title":"<code>regex</code>","text":"<p>A <code>regex</code> type has data members that are regular expression objects. This metafunction replaces all of the type's data members named <code>regex</code> or <code>regex_*</code> with regular expression objects of the same type. For example:</p> Regular expression example<pre><code>name_matcher: @regex type\n= {\n    regex         := R\"((\\w+) (\\w+))\";  // for example: Margaret Hamilton\n    regex_no_case := R\"(/(ab)+/i)\";     // case insensitive match of \"ab\"+\n}\n\nmain: (args) = {\n    m: name_matcher = ();\n\n    data: std::string = \"Donald Duck\";\n    if args.ssize() &gt;= 2 {\n        data = args[1];\n    }\n\n    //  regex.match requires matches to match the entire string, from start to end\n    result := m.regex.match(data);\n    if result.matched {\n        //  We found a match; reverse the order of the substrings\n        std::cout &lt;&lt; \"Hello (result.group(2))$, (result.group(1))$!\\n\";\n    }\n    else {\n        std::cout &lt;&lt; \"I only know names of the form: &lt;name&gt; &lt;family name&gt;.\\n\";\n    }\n\n    //  regex.search finds a match anywhere within the target string\n    std::cout &lt;&lt; \"Case insensitive match: \"\n                 \"(m.regex_no_case.search(\\\"blubabABblah\\\").group(0))$\\n\";\n}\n//  Prints:\n//      Hello Duck, Donald!\n//      Case insensitive match: abAB\n</code></pre> <p>The <code>@regex</code> metafunction currently supports most of Perl regex syntax, except for Unicode characters and the syntax tokens associated with them. See Supported regular expression features for a list of regex options.</p> <p>Each regex object has the type <code>cpp2::regex::regular_expression</code>, which is defined in <code>include/cpp2regex.h2</code>. The member functions are:</p> Member functions for regular expressions<pre><code>//  .match() requires matches to match the entire string, from start to end\n//  .search() finds a match anywhere within the target string\n\nmatch :        (this, str: std::string_view)                -&gt; search_return;\nsearch:        (this, str: std::string_view)                -&gt; search_return;\n\nmatch :        (this, str: std::string_view, start)         -&gt; search_return;\nsearch:        (this, str: std::string_view, start)         -&gt; search_return;\n\nmatch :        (this, str: std::string_view, start, length) -&gt; search_return;\nsearch:        (this, str: std::string_view, start, length) -&gt; search_return;\n\nmatch : &lt;Iter&gt; (this, start: Iter, end: Iter)               -&gt; search_return;\nsearch: &lt;Iter&gt; (this, start: Iter, end: Iter)               -&gt; search_return;\n</code></pre> <p>The return type <code>search_return</code> is defined in <code>cpp2::regex::regular_expression</code>. It has these members:</p> Members of a regular expression result<pre><code>matched: bool;\npos:     int;\n\n//  Functions to access groups by number\ngroup_number: (this) -&gt; size_t;;\ngroup:        (this, g: int) -&gt; std::string;\ngroup_start:  (this, g: int) -&gt; int;\ngroup_end:    (this, g: int) -&gt; int;\n\n//  Functions to access groups by name\ngroup:        (this, g: bstring&lt;CharT&gt;) -&gt; std::string;\ngroup_start:  (this, g: bstring&lt;CharT&gt;) -&gt; int;\ngroup_end:    (this, g: bstring&lt;CharT&gt;) -&gt; int;\n</code></pre>"},{"location":"cpp2/metafunctions/#helpers-and-utilities","title":"Helpers and utilities","text":""},{"location":"cpp2/metafunctions/#cpp1_rule_of_zero","title":"<code>cpp1_rule_of_zero</code>","text":"<p>A <code>cpp1_rule_of_zero</code> type is one that has no user-written copy/move/destructor functions, and for which Cpp2 should generate nothing so that the Cpp1 defaults for generated special member functions are accepted.</p> <p>C.20: If you can avoid defining default operations, do. Reason: It's the simplest and gives the cleanest semantics. This is known as \"the rule of zero\". \u2014 Stroustrup, Sutter, et al. (C++ Core Guidelines)</p>"},{"location":"cpp2/metafunctions/#print","title":"<code>print</code>","text":"<p><code>print</code> prints a pretty-printed visualization of the type to the console.</p> <p>This is most useful for debugging metafunctions, and otherwise seeing the results of applying previous metafunctions.</p> <p>For a detailed example, see the <code>shape</code> example above.</p> <ol> <li> <p>With <code>variant</code>, there's no way to distinguish in the type system between a <code>variant&lt;int,string&gt;</code> that stores either an employee id or employee name, and a <code>variant&lt;int,string&gt;</code> that stores either a lucky number or a pet unicorn's dominant color.\u00a0\u21a9</p> </li> </ol>"},{"location":"cpp2/namespaces/","title":"Namespaces","text":""},{"location":"cpp2/namespaces/#overview","title":"Overview","text":"<p>A namespace <code>N</code> can contain declarations that are then accessed by writing <code>N::</code> or <code>using</code> the namespace or declaration. For example:</p> Declaring some things in a namespace<pre><code>//  A namespace to put all the names provided by a widget library\nwidgetlib: namespace = {\n    widget: type = { /*...*/ }\n    // ... more things ...\n}\n\nmain: () = {\n    w: widgetlib::widget = /*...*/;\n}\n</code></pre>"},{"location":"cpp2/namespaces/#using","title":"<code>using</code>","text":"<p>A <code>using</code> statement brings names declared in another namespace into the current scope as if they had been declared in the current scope.</p> <p><code>using a_namespace::a_name ;</code> brings the single name <code>a_name</code> into scope.</p> <p><code>using a_namespace::_ ;</code> brings all the namespace's names into scope using the <code>_</code> wildcard.</p> <p>For example:</p> using statements<pre><code>//  A namespace to put all the names provided by a widget library\nwidgetlib: namespace = {\n    widget: type = { /*...*/ }\n    // ... more things ...\n}\n\nmain: () = {\n    //  Explicit name qualification\n    w: widgetlib::widget = /*...*/;\n\n    {\n        //  Using the specific name, no widgetlib:: qualification needed\n        using widgetlib::widget;\n        w2: widget = /*...*/;\n        // ...\n    }\n\n    {\n        //  Using the whole namespace, no widgetlib:: qualification needed\n        using widgetlib::_;\n        w3: widget = /*...*/;\n        // ...\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/objects/","title":"Objects, initialization, and memory","text":""},{"location":"cpp2/objects/#overview","title":"Overview","text":"<p>An object can be declared at any scope: in a namespace, in a <code>type</code>, in a function, in an expression.</p> <p>Its declaration is written using the same name <code>:</code> kind <code>=</code> value declaration syntax as everything in Cpp2:</p> <ul> <li> <p>name starts with a letter and is followed by other letters, digits, or <code>_</code>. Examples: <code>count</code>, <code>skat_game</code>, <code>Point2D</code> are valid names.</p> </li> <li> <p>kind is the object's type. In most places, except type scopes, you can write the <code>_</code> wildcard as the type (or omit the type entirely) to ask for the type to be deduced. When the type is a template, the templated arguments can be inferred from the constructor (via CTAD).</p> </li> <li> <p>value is the object's initial value. To use the default-constructed value, write <code>()</code>.</p> </li> </ul> <p>For example:</p> Declaring some objects<pre><code>//  numbers is an object of type std::vector&lt;int&gt;,\n//  defined as having the initial contents 1, 2, 3\nnumbers: std::vector&lt;int&gt; = (1, 2, 3);\nnumbers: std::vector = (1, 2, 3);       // same, deducing the vector's type\n\n//  count is an object of type int, defined as having initial value -1\ncount: int = -1;\ncount: _ = -1;      // same, deducing the object's type with the _ wildcard\ncount := -1;        // same, deducing the object's type by just omitting it\n\n//  pi is a variable template; == signifies the value never changes (constexpr)\npi: &lt;T: type&gt; T == 3.14159'26535'89793'23846L;\npi: _ == 3.14159'26535'89793'23846L;    // same, deducing the object's type\n</code></pre> <p>The object type can be deduced by writing <code>_</code> (the default, so it can be omitted). You can use <code>is</code> to declare a type constraint (e.g., a concept) that a deduced type must match, in which case <code>_</code> is required. For example:</p> Declaring an object of constrained deduced type<pre><code>//  number's type is deduced, but must match the std::regular concept\nnumber: _ is std::regular = some_factory_function();\n</code></pre>"},{"location":"cpp2/objects/#guaranteed-initialization","title":"Guaranteed initialization","text":"<p>Every object must be initialized using <code>=</code> before it is used.</p> <p>An object in any scope can be initialized at its declaration. For example:</p> Initializing objects when they are declared<pre><code>shape: type = {\n    //  An object at type scope (data member)\n    //  initialized with its type's default value\n    points: std::vector&lt;point2d&gt; = ();\n\n    draw: (this, where: canvas) -&gt; bool\n    = {\n        //  An object at function scope (local variable)\n        //  initialized with color::red\n        pen := color::red;\n\n        // ...\n    }\n\n    //  ...\n}\n</code></pre> <p>Additionally, at function local scope an object <code>obj</code> can be initialized separately from its declaration. This can be useful when the object must be declared before a program-meaningful initial value is known (to avoid a dead write of a wrong 'dummy' value), and/or when the object may be initialized in more than one way depending on other logic (e.g., by using different constructors on different paths). The way to do this is:</p> <ul> <li> <p>Declare <code>obj</code> without an <code>= initializer</code> value, for example: <code>obj: some_type;</code>. This allocates stack space for the object, but does not construct it.</p> </li> <li> <p><code>obj</code> must have a definite first use on every <code>if</code>/<code>else</code> branch path (and that first use must not be inside any loop), and</p> </li> <li> <p>that definite first use must be of the form <code>obj = value;</code> which is a constructor call, or else pass <code>obj</code> as an <code>out</code> argument to an <code>out</code> parameter (which is also effectively a constructor call, and performs the construction in the callee).</p> </li> </ul> <p>For example:</p> Initializing local objects after they are declared<pre><code>f: () = {\n    buf: std::array&lt;std::byte, 1024&gt;;   // uninitialized\n    //  ... calculate some things ...\n    //  ...  no uses of buf here  ...\n    buf = some_calculated_value;        // constructs (not assigns) buf\n    //  ...\n    std::cout &lt;&lt; buf[0];                // ok, a has been initialized\n}\n\ng: () = {\n    buf: std::array&lt;std::byte, 1024&gt;;   // uninitialized\n    if flip_coin_is_heads() {\n        if heads_default_is_available {\n            buf = copy_heads_default(); // constructs buf\n        }\n        else {\n            buf = (other, constructor); // constructs buf\n        }\n    }\n    else {\n        load_from_disk( out buf );      // constructs buf (*)\n    }\n    std::cout &lt;&lt; buf[0];                // ok, a has been initialized\n}\n\nload_from_disk: (out x) = {\n    x = /* data read from disk */ ;     // when `buffer` is uninitialized,\n}                                       // constructs it; otherwise, assigns\n</code></pre> <p>In the above example, note the simple rule for branches: The local variable must be initialized on both the <code>if</code> and <code>else</code> branches, or neither branch.</p>"},{"location":"cpp2/objects/#heap-objects","title":"Heap objects","text":"<p>Objects can also be allocated on the heap using <code>xxx.new &lt;T&gt; (/*initializer, arguments*/)</code> where <code>xxx</code> is any object that acts as a memory allocator and provides a <code>.new</code> function template. Two memory allocators objects are provided in namespace <code>cpp2</code>:</p> <ul> <li> <p><code>unique.new&lt;T&gt;</code> calls <code>std::make_unique&lt;T&gt;</code> and returns a <code>std::unique_ptr&lt;T&gt;</code>.</p> </li> <li> <p><code>shared.new&lt;T&gt;</code> calls <code>std::make_shared&lt;T&gt;</code> and returns a <code>std::shared_ptr&lt;T&gt;</code>.</p> </li> </ul> <p>The default is <code>unique.new</code> if you don't specify an allocator object.</p> <p>For example (see types for more details about writing types):</p> Heap allocation<pre><code>f: () -&gt; std::shared_ptr&lt;widget&gt;\n= {\n    //  Dynamically allocate an object owned by a std::unique_ptr\n    //  'vec' is a unique_ptr&lt;vector&lt;i32&gt;&gt; containing three values\n    vec := new&lt;std::vector&lt;i32&gt;&gt;(1, 2, 3);\n            // shorthand for 'unique.new&lt;...&gt;(...)'\n    std::cout &lt;&lt; vec*.ssize();  // prints 3\n                    // note that * dereference is a suffix operator\n\n    //  Dynamically allocate an object with shared ownership\n    wid := cpp2::shared.new&lt;widget&gt;();\n    store_a_copy( wid );        // store a copy of 'wid' somewhere\n    return wid;                 // and move-return a copy too\n\n} // as always in C++, vec is destroyed here automatically, which\n  // destroys the heap vector and deallocates its dynamic memory\n</code></pre>"},{"location":"cpp2/safety/","title":"Safety and unchecked code","text":"<p>Cpp2 aims to be safe by default, usually entirely at compile time, and when needed at run time.</p> <p>When Cpp2 rejects unsafe code (e.g., signed/unsigned comparison) or ensuring safety can require run-time checks (e.g., subscripts bounds checks), you can opt out as needed in two ways:</p> <ul> <li>at a specific place in your code, using <code>unchecked_*</code> functions (these are in namespace <code>cpp2::</code>, but can be used unqualified from Cpp2 code)</li> <li>for a whole source file, using <code>-no-*-checks</code> switches</li> </ul> <p>Nearly always, you should opt out at a specific place in your code where you are confident the result is okay, and if there is a run-time check you have measured that the performance difference matters such as in a hot loop.</p>"},{"location":"cpp2/safety/#integer-mixed-sign-and-compile-time-enforced","title":"Integer mixed-sign <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (compile-time enforced)","text":"<p>Comparing signed and unsigned integer values directly using <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code> can give wrong results, and so such comparisons are rejected at compile time.</p> <p>To disable this check at a specific place in your code, use the appropriate <code>unchecked_cmp_*</code> function instead of the operator notation: <code>unchecked_cmp_less</code>, <code>unchecked_cmp_less_eq</code>,<code>unchecked_cmp_greater</code>, or <code>unchecked_cmp_greater_eq</code>.</p> <p>For example:</p> Integer comparisons<pre><code>main: () = {\n    x: i32 = 42;\n    y: u32 = 43;\n\n    if x &lt; y { }                            // unsafe, therefore error by default\n\n    if unchecked_cmp_less(x,y) { }          // ok, explicit \"trust me\" opt-out\n}\n</code></pre> <p>To disable these checks for the entire source file, you can use cppfront's <code>-no-comparison-checks</code> switch:</p> Disable prevention of mixed-sign integer comparisons<pre><code>cppfront myfile.cpp2                        # mixed-sign int comparisons banned\n\ncppfront myfile.cpp2 -no-comparison-checks  # mixed-sign int comparisons allowed\n</code></pre>"},{"location":"cpp2/safety/#division-by-zero-run-time-checked","title":"Division by zero (run-time checked)","text":"<p>Dividing integers by zero is undefined behavior, and is rejected at run time by checking the denominator is nonzero.</p> <p>To disable this check at a specific place in your code, use <code>unchecked_div</code>. For example:</p> Division by zero<pre><code>main: () = {\n    x := 42;\n    y := 0;\n\n    z := x/y;                               // unsafe, therefore run-time checked\n\n    w := unchecked_div(x,y)                 // ok, explicit \"trust me\" opt-out\n}\n</code></pre> <p>To disable these checks for the entire source file, you can use cppfront's <code>-no-div-zero-checks</code> switch:</p> Disable prevention of division by zero<pre><code>cppfront myfile.cpp2                        # division by zero checked\n\ncppfront myfile.cpp2 -no-div-zero-checks    # division by zero not checked\n</code></pre>"},{"location":"cpp2/safety/#null-dereference-run-time-checked","title":"Null dereference (run-time checked)","text":"<p>Dereferencing a null pointer is undefined behavior, and is rejected at run time by checking the pointer is not null.</p> <p>To disable this check at a specific place in your code, use <code>unchecked_dereference</code>. For example:</p> Null dereference<pre><code>main: () = {\n    p: *int = cpp1_func();                  // could be initialized to null\n\n    p* = 42;                                // unsafe, therefore run-time checked\n\n    unchecked_dereference(p) = 42;          // ok, explicit \"trust me\" opt-out\n}\n</code></pre> <p>To disable these checks for the entire source file, you can use cppfront's <code>-no-null-checks</code> switch:</p> Disable prevention of null deference<pre><code>cppfront myfile.cpp2                        # null dereferences checked\n\ncppfront myfile.cpp2 -no-null-checks        # null dereferences not checked\n</code></pre>"},{"location":"cpp2/safety/#subscript-bounds-run-time-checked","title":"Subscript bounds (run-time checked)","text":"<p>Accessing an out of bounds subscript is undefined behavior, and is rejected at run time by checking the subscript is in bounds. For an expression <code>a[b]</code> where</p> <ul> <li><code>a</code> is contiguous and supports <code>std::size(a)</code>, and</li> <li><code>b</code> is an integral value</li> </ul> <p>the cppfront compiler injects a check that <code>0 &lt;= b &lt; std::size(a)</code> before the call to <code>a[b]</code>.</p> <p>To disable this check at a specific place in your code, use <code>unchecked_subscript</code>. For example:</p> Subscript bounds<pre><code>main: () = {\n    v: std::vector = ( 1, 2, 3, 4, 5 );\n    s: std::span   = v;\n\n    idx := calc_index(s);\n\n    v[idx] += 42;                           // unsafe, therefore run-time checked\n    s[idx] += 84;                           // unsafe, therefore run-time checked\n\n    // manually hoist the check and do it myself\n    if (0 ..&lt; v.size()).contains(idx) {\n        unchecked_subscript(v,idx) += 42;   // ok, explicit \"trust me\" opt-out\n        unchecked_subscript(s,idx) += 84;   // ok, explicit \"trust me\" opt-out\n    }\n}\n</code></pre> <p>To disable these checks for the entire source file, you can use cppfront's <code>-no-subscript-checks</code> switch:</p> Disable prevention of out-of-bounds subscripts<pre><code>cppfront myfile.cpp2                        # subscript bounds checked\n\ncppfront myfile.cpp2 -no-subscript-checks   # subscript bounds not checked\n</code></pre>"},{"location":"cpp2/types/","title":"Types","text":""},{"location":"cpp2/types/#overview","title":"Overview","text":"<p>A user-defined <code>type</code> is written using the same name <code>:</code> kind <code>=</code> value declaration syntax as everything in Cpp2. The type's \"value\" is a <code>{}</code>-enclosed body containing more declarations.</p> <p>In a <code>type</code>, data members are private by default, and functions and nested types are public by default. To explicitly declare a type scope declaration <code>public</code>, <code>protected</code>, or <code>private</code>, write that keyword at the beginning of the declaration.</p> Writing a simple type<pre><code>mytype: type =\n{\n    // data members are private by default\n    x: std::string;\n\n    // functions are public by default\n    protected f: (this) = { do_something_with(x); }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#this-the-parameter-name","title":"<code>this</code> \u2014 The parameter name","text":"<p><code>this</code> is a synonym for the current object. Inside the scope of a type that has a member named <code>member</code>, <code>member</code> by default means <code>this.member</code>.</p> <p>Note: In Cpp2, <code>this</code> is not a pointer.</p> <p>The name <code>this</code> may only be used for the first parameter of a type-scope function (aka member function). It is never declared with an explicit <code>: its_type</code> because its type is always the current type.</p> <p><code>this</code> can be an <code>in</code> (default), <code>inout</code>, <code>out</code>, or <code>move</code> parameter. Which you choose naturally determines what kind of member function is being declared:</p> <ul> <li> <p><code>in this</code>: Writing <code>myfunc: (this /*...*/)</code>, which is shorthand for <code>myfunc: (in this /*...*/)</code>, defines a Cpp1 <code>const</code>-qualified member function, because  <code>in</code> parameters are <code>const</code>.</p> </li> <li> <p><code>inout this</code>: Writing <code>myfunc: (inout this /*...*/)</code> defines a Cpp1 non-<code>const</code> member function.</p> </li> <li> <p><code>out this</code>: Writing <code>myfunc: (out this /*...*/)</code> defines a Cpp1 constructor... and more. (See below.)</p> </li> <li> <p><code>move this</code>: Writing <code>myfunc: (move this /*...*/)</code> defines a Cpp1 <code>&amp;&amp;</code>-qualified member function, or if there are no additional parameters it defines the destructor.</p> </li> </ul> <p>For example, here is how to write read-only member function named <code>print</code> that takes a read-only string value and prints this object's data value and the string message:</p> The this parameter<pre><code>mytype: type = {\n    data: i32;   // some data member (private by default)\n\n    print: (this, msg: std::string) = {\n        std::cout &lt;&lt; data &lt;&lt; msg;\n                 // \"data\" is shorthand for \"this.data\"\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#this-inheritance","title":"<code>this</code> \u2014 Inheritance","text":"<p>Base types are written as members named <code>this</code>. For example, just as a type could write a data member as <code>data: string = \"xyzzy\";</code>, which is pronounced \"<code>data</code> is a <code>string</code> defined as having the default value <code>\"xyzzy\"</code>, a base type is written as <code>this: Shape = (default, values);</code>, which is pronounced \"<code>this</code> is a <code>Shape</code> defined as having these default values.\"</p> <p>Cpp2 syntax has no separate base list or separate member initializer list.</p> <p>Because base and member subobjects are all declared in the same place (the type body) and initialized in the same place (an <code>operator=</code> function body), they can be written in any order, including interleaved, and are still guaranteed to be safely initialized in declared order. This means that in Cpp2 you can declare a data member object before a base subobject, so that it naturally outlives the base subobject.</p> <p>Cpp2 code doesn't need workarounds like Boost's <code>base_from_member</code>, because all of the motivating examples for that can be written directly. See this explanation for details.</p>"},{"location":"cpp2/types/#virtual-override-and-final-virtual-functions","title":"<code>virtual</code>, <code>override</code>, and <code>final</code> \u2014 Virtual functions","text":"<p>A <code>this</code> parameter can additionally be declared as one of the following:</p> <ul> <li> <p><code>virtual</code>: Writing <code>myfunc: (virtual this /*...*/)</code> defines a new virtual function.</p> </li> <li> <p><code>override</code>: Writing <code>myfunc: (override this /*...*/)</code> defines an override of an existing base class virtual function.</p> </li> <li> <p><code>final</code>: Writing <code>myfunc: (final this /*...*/)</code> defines a final override of an existing base class virtual function.</p> </li> </ul> <p>A pure virtual function is a function with a <code>virtual this</code> or <code>override this</code> parameter and no body.</p> <p>For example:</p> Virtual functions<pre><code>abstract_base: type\n= {\n    //  A pure virtual function: virtual + no body\n    print: (virtual this, msg: std::string);\n\n    // ...\n}\n\nderived: type\n= {\n    //  'this' is-an 'abstract_base'\n    this: abstract_base;\n\n    //  Explicit override\n    print: (override this, msg: std::string) = { /*...*/ }\n\n    // ...\n}\n</code></pre>"},{"location":"cpp2/types/#implicit-controlling-conversion-functions","title":"<code>implicit</code> \u2014 Controlling conversion functions","text":"<p>A <code>this</code> parameter of an <code>operator=</code> function can additionally be declared as:</p> <ul> <li><code>implicit</code>: Writing <code>operator=: (implicit out this, /*...*/)</code> defines a function that will not be marked as \"explicit\" when lowered to Cpp1 syntax.</li> </ul> <p>Note: This reverses the Cpp1 default, where constructors are not \"explicit\" by default, and you have to write \"explicit\" to make them explicit.</p>"},{"location":"cpp2/types/#operator-construction-assignment-and-destruction","title":"<code>operator=</code> \u2014 Construction, assignment, and destruction","text":"<p>All value operations are spelled <code>operator=</code>, including construction, assignment, and destruction. <code>operator=</code> sets the value of <code>this</code> object, so the <code>this</code> parameter can be passed as anything but <code>in</code> (which would imply <code>const</code>):</p> <ul> <li> <p><code>out this</code>: Writing <code>operator=: (out this /*...*/ )</code> is naturally both a constructor and an assignment operator, because an <code>out</code> parameter can take an uninitialized or initialized argument. If you don't also write a more-specialized <code>inout this</code> assignment operator, Cpp2 will use the <code>out this</code> function also for assignment.</p> </li> <li> <p><code>inout this</code>: Writing <code>operator=: (inout this /*...*/ )</code> is an assignment operator (only), because an <code>inout</code> parameter requires an initialized modifiable argument.</p> </li> <li> <p><code>move this</code>: Writing <code>operator=: (move this)</code> is the destructor. No other parameters are allowed, so it connotes \"move <code>this</code> nowhere.\"</p> </li> </ul> <p>Unifying <code>operator=</code> enables usable <code>out</code> parameters, which is essential for composable guaranteed initialization. We want the expression syntax <code>x = value</code> to be able to call a constructor or an assignment operator, so naming them both <code>operator=</code> is consistent.</p> <p>An assignment operator always returns the same type as <code>this</code> and automatically performs <code>return this;</code>.</p> <p>Note: Writing <code>=</code> always invokes an <code>operator=</code> (in fact for a Cpp2-authored type, and semantically for a Cpp1-authored type). This avoids the Cpp1 inconsistency that \"writing <code>=</code> calls <code>operator=</code>, except when it doesn't\" (such as in a Cpp1 variable initialization). Conversely, <code>operator=</code> is always invoked by <code>=</code> in Cpp2.</p>"},{"location":"cpp2/types/#that-a-source-parameter","title":"<code>that</code> \u2014 A source parameter","text":"<p>All type-scope functions can have <code>that</code> as their second parameter, which is a synonym for the object to be copied/moved from. Like <code>this</code>, at type scope it is never declared with an explicit <code>: its_type</code> because its type is always the current type.</p> <p><code>that</code> can be an <code>in</code> (default) or <code>move</code> parameter. Which you choose naturally determines what kind of member function is being declared:</p> <ul> <li> <p><code>in that</code>: Writing <code>myfunc: (/*...*/ this, that)</code>, which is shorthand for <code>myfunc: (/*...*/ this, in that)</code>, is naturally both a copy and move function, because it can accept an lvalue or an rvalue <code>that</code> argument. If you don't write a more-specialized <code>move that</code> move function, Cpp2 will automatically use the <code>in that</code> function also for move.</p> </li> <li> <p><code>move that</code>: Writing <code>myfunc: (/*...*/ this, move that)</code> defines a move function.</p> </li> </ul> <p>Putting <code>this</code> and <code>that</code> together: The most general form of <code>operator=</code> is <code>operator=: (out this, that)</code>. It works as a unified general {copy, move} x { constructor, assignment } operator, and generates all of four of those in the lowered Cpp1 code if you didn't write a more specific one yourself.</p>"},{"location":"cpp2/types/#operator-can-generalize-assignment-from-construction-and-move-from-copy","title":"<code>operator=</code> can generalize (A)ssignment from construction, and (M)ove from copy","text":"<p>As mentioned above: - If you don't write an <code>inout this</code> function, Cpp2 will use your <code>out this</code> function in its place (if you wrote one). - If you don't write a <code>move that</code> function, Cpp2 will use your <code>in that</code> function in its place (if you wrote one).</p> <p>Note: When lowering to Cpp1, this just means generating the applicable special member functions from the appropriate Cpp2 function.</p> <p>This graphic summarizes these generalizations. For convenience I've numbered the (A)ssignment and (M)ove defaults.</p> <p></p> <p>In Cpp1 terms, they can be described as follows:</p> <ul> <li> <p>(M)ove, M1, M2: If you write a copy constructor or assignment operator, but not a corresponding move constructor or assignment operator, the latter is generated.</p> </li> <li> <p>(A)ssignment, A1, A3: If you write a generalized constructor, but none of the three more-specific copy/move constructor/assignment functions, the latter three get generated. If you write a converting copy constructor, but no converting assignment operator for the same type and this is not a polymorphic type, the latter is generated.</p> </li> <li> <p>The arrows are transitive. For example, if you write a copy constructor and nothing else, the move constructor, copy assignment operator, and move assignment operator are generated.</p> </li> </ul> <p>The most general <code>operator=</code> with <code>that</code> is <code>(out this, that)</code>. In Cpp1 terms, it generates all four combinations of { copy, move } x { constructor, assignment }. This is often sufficient, so you can write all these value-setting functions just once. If you do want to write a more specific version that does something else, though, you can always write it too.</p> <p>Note: Generating <code>inout this</code> (assignment) from <code>out this</code> also generates converting assignment from converting construction, which is a new thing. Today in Cpp1, if you write a converting constructor from another type <code>X</code>, you may or may not write the corresponding assignment from <code>X</code>; in Cpp2 you will get that by default, and it sets the object to the same state as the converting constructor from <code>X</code> does.</p>"},{"location":"cpp2/types/#minimal-functions-generated-by-default","title":"Minimal functions generated by default","text":"<p>There are only two defaults the language will generate implicitly for a type:</p> <ul> <li> <p>The only special function every type must have is the destructor. If you don't write it by hand, a public nonvirtual destructor is generated by default.</p> </li> <li> <p>If no <code>operator=</code> functions other than the destructor are written by hand, a public default constructor is generated by default.</p> </li> </ul> <p>All other <code>operator=</code> functions are explicitly written, either by hand or by opting into applying a metafunction (see below).</p> <p>Note: Because generated functions are always opt-in, you can never get a generated function that's wrong for your type, and so Cpp2 doesn\u2019t need to support \"=delete\" for the purpose of suppressing unwanted generated functions.</p>"},{"location":"cpp2/types/#memberwise-by-default","title":"Memberwise by default","text":"<p>All copy/move/conversion <code>operator=</code> functions are memberwise by default in Cpp2. That includes when you write memberwise construction and assignment yourself.</p> <p>In a hand-written <code>operator=</code>:</p> <ul> <li> <p>The body must begin with a series of <code>member = value;</code> statements, one for each of the type's data members (including base classes) in declaration order.</p> </li> <li> <p>If the body does not mention a member in the appropriate place in the beginning section, by default the member's default initializer is used.</p> </li> <li> <p>In an assignment operator (<code>inout this</code>), you can explicitly skip setting a member by writing <code>member = _;</code> where it would normally be set if you know you have a reason to set its value later instead or if the existing value needs to be preserved. (This is rare; for an example, see the generated implementation of the <code>union</code> metafunction.)</p> </li> </ul> <p>For example:</p> Memberwise operator= semantics<pre><code>mytype: type\n= {\n    //  data members (private by default)\n    name:          std::string;\n    social_handle: std::string = \"(unknown)\";\n\n    //  conversion from string (construction + assignment)\n    operator=: (out this, who: std::string) = {\n        name = who;\n        //  if social_handle is not mentioned, defaults to:\n        //      social_handle = \"(unknown)\";\n\n        //  now that the members have been set,\n        //  any other code can follow...\n        print();\n    }\n\n    //  copy/move constructor/assignment\n    operator=: (out this, that) = {\n        //  if neither data member is mentioned, defaults to:\n        //      name = that.name;\n        //      social_handle = that.social_handle;\n        print();\n    }\n\n    print: (this) = { std::cout &lt;&lt; \"value is [(name)$] [(social_handle)$]\\n\"; }\n}\n\n//  The above definition of mytype allows all of the following...\nmain: () = {\n    x: mytype = \"Jim\"; // construct from string\n    x = \"John\";        // assign from string\n    y := x;            // copy construct\n    y = x;             // copy assign\n    z := (move x);     // move construct\n    z = (move y);      // move assign\n    x.print();         // \"value is [] []\" - moved from\n    y.print();         // \"value is [] []\" - moved from\n}\n</code></pre> <p>Note: This makes memberwise semantics symmetric for construction and assignment. In Cpp1, only non-copy/move constructors have a default, which is to initialize a member with its default initializer. In Cpp2, both constructors and assignment operators default to using the default initializer if it's a conversion function (non-<code>that</code>, aka non-copy/move), and using memberwise <code>member = that.member;</code> for copy/move functions.</p>"},{"location":"cpp2/types/#operator-unified-comparisons","title":"<code>operator&lt;=&gt;</code> \u2014 Unified comparisons","text":"<p>To write comparison functions for your type, usually you just need to write either or both of <code>operator&lt;=&gt;</code> and <code>operator==</code> with a first parameter of <code>this</code> and a second parameter of any type (usually <code>that</code> which is of the same type). If you omit the function body, a memberwise comparison will be generated by default.</p> <p><code>operator&lt;=&gt;</code> must return one of <code>std::strong_ordering</code>, <code>std::partial_ordering</code>, or <code>std::weak_ordering</code>. It makes <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> comparisons available for your type. Prefer a strong ordering unless you have a reason to use a partial or weak ordering. If you write <code>operator&lt;=&gt;</code> without a custom function body, <code>operator==</code> is generated for you.</p> <p><code>operator==</code> must return <code>bool</code>. It makes <code>==</code> and <code>!=</code> comparisons available for your type.</p> <p>For example:</p> Writing the &lt;=&gt; operator<pre><code>item: type = {\n    x: i32         = ();\n    y: std::string = ();\n\n    operator&lt;=&gt;: (this, that) -&gt; std::strong_ordering;\n        //  memberwise by default: first compares x &lt;=&gt; that.x,\n        //  then if those are equal compares y &lt;=&gt; that.y\n\n    // ...\n}\n\ntest: (x: item, y: item) = {\n    if x != y {         //  ok\n        //  ...\n    }\n}\n</code></pre> <p>The above is the same as in Cpp1 because most of Cpp2's <code>operator&lt;=&gt;</code> feature has already been merged into ISO C++ (Cpp1). In addition, in Cpp2 comparisons with the same precedence can be safely chained, and always have the mathematically sound transitive meaning or else are rejected at compile time:</p> <ul> <li>Valid chains: All <code>&lt;</code>/<code>&lt;=</code>, all <code>&gt;</code>/<code>&gt;=</code>, or all <code>==</code>. All mathematically sound and safe chains like <code>a &lt;= b &lt; c</code> are supported, with efficient single evaluation of each term. They are \"sound\" because they are transitive; these chains imply a relationship between <code>a</code> and <code>c</code> (in this case, the chain implies that <code>a &lt;= c</code> is also true).</li> </ul> <p>Note: These valid chains always give mathematically expected results, even when invoking existing comparison operators authored in Cpp1 syntax.</p> <ul> <li> <p>Invalid chains: Everything else. Nonsense chains like <code>a &gt;= b &lt; c</code> and <code>a != b != c</code> are compile time errors. They are \"nonsense\" because they are non-transitive; these chains do not imply any relationship between <code>a</code> and <code>c</code>.</p> </li> <li> <p>Non-chains: Mixed precedence is not a chain. Expressions like <code>a&lt;b == c&lt;d</code> are not a chain, because <code>==</code> has lower precedence than <code>&lt;</code>. This simply means what it appears to mean, namely <code>(a&lt;b) == (c&lt;d)</code>; the expression evaluates to <code>true</code> if <code>a&lt;b</code> and <code>c&lt;d</code> are either both true or both false, otherwise the expression evaluates to <code>false</code>.</p> </li> </ul> Chained comparisons<pre><code>//  If requested is in the range of values [lo, hi)\nif lo &lt;= requested &lt; hi {\n    // ... do something ...\n}\n\n//  Equivalent result to: (lo ..&lt; hi).contains( requested )\n</code></pre> <p>For more details, see P0515R0 \"Consistent comparison\" section 3.3 and P0893 \"Chaining comparisons\".</p>"},{"location":"cppfront/mixed/","title":"Mixing Cpp1 (today's C++) and Cpp2 in the same source file","text":""},{"location":"cppfront/mixed/#compiling-a-source-file-that-contains-both-cpp1-and-cpp2-code","title":"Compiling a source file that contains both Cpp1 and Cpp2 code","text":"<p>Cppfront compiles a <code>.cpp2</code> file and produces a <code>.cpp</code> file to be compiled by your favorite C++20 or higher C++ compiler.</p> <p>The same <code>.cpp2</code> file may contain both Cpp2 syntax and today's \"Cpp1\" C++ syntax, side by side but not nested.</p> <p>When cppfront compiles such a mixed file, it just passes through the Cpp1 code as-is, and translates the Cpp2 code to Cpp1 in-place. This means that when a call site (call this the \"caller\") uses a type/function/object (call this the \"callee\") written in the same file:</p> <ul> <li> <p>Code written in all Cpp2 is always order-independent by default. When a caller written in Cpp2 syntax uses a callee written in Cpp2 syntax, they can appear in either order in the file.</p> </li> <li> <p>Code written in Cpp1 is order-dependent as usual. When either the caller or the callee (or both) are written in Cpp1 syntax, the callee must be declared before the caller.</p> </li> </ul>"},{"location":"cppfront/mixed/#okay-cpp1-and-cpp2-side-by-side-interleaved","title":"Okay: Cpp1 and Cpp2 side by side, interleaved","text":"<p>For example, this source file is fine, where the Cpp2 and Cpp1 code are side by side and seamlessly call each other directly as usual:</p> mixed.cpp2 \u2014 Mixing Cpp1 and Cpp2 code side by side in the same source file is okay<pre><code>#include &lt;iostream&gt;                             // Cpp1\n#include &lt;string_view&gt;                          // Cpp1\n\nN: namespace = {                                        // Cpp2\n    hello: (msg: std::string_view) =                    // Cpp2\n        std::cout &lt;&lt; \"Hello, (msg)$!\\n\";                // Cpp2\n}                                                       // Cpp2\n\nint main() {                                    // Cpp1\n    auto words = std::vector{ \"Alice\", \"Bob\" }; // Cpp1\n    N::hello( words[0] );                       // Cpp1\n    N::hello( words[1] );                       // Cpp1\n    std::cout &lt;&lt; \"... and goodnight\\n\";         // Cpp1\n}                                               // Cpp1\n</code></pre>"},{"location":"cppfront/mixed/#not-allowed-nesting-cpp1-inside-cpp2-and-vice-versa","title":"Not allowed: Nesting Cpp1 inside Cpp2 (and vice versa)","text":"<p>However, the following source file is not valid, because it tries to nest Cpp2 code inside Cpp1 code, and vice versa:</p> ERROR.cpp2 \u2014 this is NOT allowed<pre><code>#include &lt;iostream&gt;                             // Cpp1\n#include &lt;string_view&gt;                          // Cpp1\n\nnamespace N {                                   // Cpp1\n    hello: (msg: std::string_view) =                    // Cpp2 (ERROR here)\n        std::cout &lt;&lt; \"Hello, (msg)$!\\n\";                // Cpp2 (ERROR here)\n}                                               // Cpp1\n\nmain: () = {                                            // Cpp2\n    auto words = std::vector{ \"Alice\", \"Bob\" }; // Cpp1 (ERROR here)\n    N::hello( words[0] );                           // ?\n    N::hello( words[1] );                           // ?\n    std::cout &lt;&lt; \"... and goodnight\\n\";             // ?\n}                                                       // Cpp2\n</code></pre> <p>The above nesting is not supported because it would create not just parsing problems but also semantic ambiguities. For example, lines 11-13 are syntactically valid as Cpp1 or as Cpp2, but if they are treated as Cpp2 then the <code>words[0]</code> and <code>words[1]</code> expressions' <code>std::vector::operator[]</code> calls are bounds-checked and bounds-safe by default, whereas if they are treated as Cpp1 then they are not bounds-checked. And that's a pretty important difference to be sure about!</p>"},{"location":"cppfront/options/","title":"Cppfront command line options","text":"<p>Cppfront is invoked using</p> <pre><code>cppfront [options] file ...\n</code></pre> <p>where</p> <ul> <li> <p>options is optional, and can include options described on this page</p> </li> <li> <p>file ... is a list of one or more <code>.cpp2</code> filenames to be compiled</p> </li> </ul> <p>Command line options are spelled starting with <code>-</code> or <code>/</code> followed by the option name. For example, <code>-help</code> prints help.</p> <p>For convenience, you can shorten the name to any unique prefix not shared with another option. For example:</p> <ul> <li><code>-help</code> can be equivalently written as <code>-hel</code>, <code>-he</code>, or <code>-h</code>, because no other option starts with <code>h</code>.</li> <li><code>-import-std</code> and <code>-include-std</code> can be shortened to <code>-im</code> and <code>-in</code> respectively, but not <code>-i</code> which would be ambiguous with each other.</li> </ul>"},{"location":"cppfront/options/#basic-command-line-options","title":"Basic command line options","text":""},{"location":"cppfront/options/#-help-h-","title":"<code>-help</code>, <code>-h</code>, <code>-?</code>","text":"<p>Prints an abbreviated version of this documentation page.</p>"},{"location":"cppfront/options/#-import-std-im","title":"<code>-import-std</code>, <code>-im</code>","text":"<p>Makes the entire C++ standard library (namespace <code>std::</code>) available via a module <code>import std.compat;</code> (which implies <code>import std;</code>).</p> <p>When you use either <code>-import-std</code> or <code>-include-std</code>, your <code>.cpp2</code> program will not need to explicitly <code>import</code> any C++ standard library module or <code>#include</code> any C++ standard library header (it can still do that, but it would be redundant).</p> <p>This option is implicitly set if <code>-pure-cpp2</code> is selected.</p> <p>This option is ignored if <code>-include-std</code> is selected. If your Cpp1 compiler does not yet support standard library modules <code>std</code> and <code>std.compat</code>, this option automatically uses  <code>-include-std</code> instead as a fallback.</p>"},{"location":"cppfront/options/#-include-std-in","title":"<code>-include-std</code>, <code>-in</code>","text":"<p>Makes the entire C++ standard library (namespace <code>std::</code>) available via an '#include\" of every standard header.</p> <p>This option should always work with all standard headers, including draft-standard C++26 headers that are not yet in a published standard, because it tracks new headers as they are added and uses feature tests to not include headers that are not yet available on your Cpp1 implementation.</p>"},{"location":"cppfront/options/#-pure-cpp2-p","title":"<code>-pure-cpp2</code>, <code>-p</code>","text":"<p>Allow Cpp2 syntax only.</p> <p>This option also sets <code>-import-std</code>.</p>"},{"location":"cppfront/options/#-version-vers","title":"<code>-version</code>, <code>-vers</code>","text":"<p>Print version, build, copyright, and license information.</p>"},{"location":"cppfront/options/#additional-dynamic-safety-check-controls","title":"Additional dynamic safety check controls","text":""},{"location":"cppfront/options/#-no-comparison-checks-no-c","title":"<code>-no-comparison-checks</code>, <code>-no-c</code>","text":"<p>Disable mixed-sign comparison safety checks. If not disabled, mixed-sign comparisons are diagnosed by default.</p>"},{"location":"cppfront/options/#-no-div-zero-checks-no-d","title":"<code>-no-div-zero-checks</code>, <code>-no-d</code>","text":"<p>Disable integer division by zero checks. If not disabled, integer division by zero checks are performed by default when both the numerator and denominator are integer types.</p>"},{"location":"cppfront/options/#-no-null-checks-no-n","title":"<code>-no-null-checks</code>, <code>-no-n</code>","text":"<p>Disable null safety checks. If not disabled, null dereference checks are performed by default.</p>"},{"location":"cppfront/options/#-no-subscript-checks-no-s","title":"<code>-no-subscript-checks</code>, <code>-no-s</code>","text":"<p>Disable subscript bounds safety checks. If not disabled, subscript bounds safety checks are performed by default.</p>"},{"location":"cppfront/options/#support-for-constrained-target-environments","title":"Support for constrained target environments","text":""},{"location":"cppfront/options/#-fno-exceptions-fno-e","title":"<code>-fno-exceptions</code>, <code>-fno-e</code>","text":"<p>Disable C++ exception handling. This should be used only if you must run in an environment that bans C++ exception handling, and so you are already using a similar command line option for your Cpp1 compiler.</p> <p>If this option is selected, a failed <code>as</code> for <code>std::variant</code> will assert.</p>"},{"location":"cppfront/options/#-fno-rtti-fno-r","title":"<code>-fno-rtti</code>, <code>-fno-r</code>","text":"<p>Disable C++ run-time type information (RTTI). This should be used only if you must run in an environment that bans C++ RTTI, and so you are already using a similar command line option for your Cpp1 compiler.</p> <p>If this option is selected, trying to using <code>as</code> for <code>*</code> (raw pointers) or <code>std::any</code> will assert.</p>"},{"location":"cppfront/options/#cpp1-file-content-options","title":"Cpp1 file content options","text":""},{"location":"cppfront/options/#-clean-cpp1-cl","title":"<code>-clean-cpp1</code>, <code>-cl</code>","text":"<p>Emit clean <code>.cpp</code> files without <code>#line</code> directives and other extra information that cppfront normally emits in the <code>.cpp</code> to light up C++ tools (e.g., to let IDEs integrate cppfront error message output, debuggers step to the right lines in Cpp2 source code, and so forth). In normal use, you won't need <code>-c</code>.</p>"},{"location":"cppfront/options/#-emit-cppfront-info-e","title":"<code>-emit-cppfront-info</code>, <code>-e</code>","text":"<p>Emit cppfront version and build in the <code>.cpp</code> file.</p>"},{"location":"cppfront/options/#-line-paths-l","title":"<code>-line-paths</code>, <code>-l</code>","text":"<p>Emit absolute paths in <code>#line</code> directives.</p>"},{"location":"cppfront/options/#cppfront-output-options","title":"Cppfront output options","text":""},{"location":"cppfront/options/#-cwd-path-cw-path","title":"<code>-cwd</code> path, <code>-cw</code> path","text":"<p>Changes the current working directory to 'path'. Can be useful in build scripts to control where generated Cpp1 files are places; see also <code>-output</code>.</p>"},{"location":"cppfront/options/#-debug-d","title":"<code>-debug</code>, <code>-d</code>","text":"<p>Emit compiler debug output. This is only useful when debugging cppfront itself.</p>"},{"location":"cppfront/options/#-format-colon-errors-fo","title":"<code>-format-colon-errors</code>, <code>-fo</code>","text":"<p>Emit cppfront diagnostics using <code>:line:col:</code> format for line and column numbers, if that is the format better recognized by your IDE, so that it will pick up cppfront messages and integrate them in its normal error message output location. If not set, by default cppfront diagnostics use <code>(line,col)</code> format.</p>"},{"location":"cppfront/options/#-output-filename-o-filename","title":"<code>-output</code> filename, <code>-o</code> filename","text":"<p>Output to 'filename' (can be 'stdout'). If not set, the default output filename for is the same as the input filename without the <code>2</code> (e.g., compiling <code>hello.cpp2</code> by default writes its output to <code>hello.cpp</code>, and <code>header.h2</code> to <code>header.h</code>).</p>"},{"location":"cppfront/options/#-quiet-q","title":"<code>-quiet</code>, <code>-q</code>","text":"<p>Print no console output unless there are errors to report.</p>"},{"location":"cppfront/options/#-verbose-verb","title":"<code>-verbose</code>, <code>-verb</code>","text":"<p>Print verbose statistics and <code>-debug</code> output.</p>"},{"location":"notes/autodiff_status/","title":"Supported algorithmic differentiation (autodiff) features","text":"<p>The listings might be incomplete. If something is missing, it is not supported. Algorithmic differentiation is applied via the <code>autodiff</code> metafunction. Maybe the planned features are added in 2026. Do not wait for them. The autodif feature is a proof of concept implementation.</p> <p>** Reverse mode algorithmic differentiation is very experimental. Expect it to break. **</p>"},{"location":"notes/autodiff_status/#currently-supported-or-planned-features","title":"Currently supported or planned features","text":"Description Status forward Status reverse Type definitions (structures) Supported Supported Member values Supported Planned Member functions Supported Supported Function arguments Supported Supported Function return arguments Supported Supported Addition and multiplication Supported Supported Prefix addition and subtraction Supported Planned Static member function calls Supported Supported Member function calls Supported Planned Function calls Supported Supported Math functions (sin, cos, exp, sqrt) Supported Supported If else Supported Planned Return statement Supported Planned Intermediate variables Supported Supported Passive variables Supported Supported While loop Supported Planned Do while loop Supported Planned For loop Supported Supported Template arguments Planned Planned Lambda functions Planned Planned"},{"location":"notes/regex_status/","title":"Supported regular expression features","text":"<p>The listings are taken from the Perl regex docs. Regular expressions are applied via the <code>regex</code> metafunction.</p>"},{"location":"notes/regex_status/#currently-supported-or-planned-features","title":"Currently supported or planned features","text":""},{"location":"notes/regex_status/#modifiers","title":"Modifiers","text":"Modifier Notes Status <code>i</code> Do case-insensitive pattern matching. For example, \"A\" will match \"a\" under <code>/i</code>. Supported <code>m</code> Treat the string being matched against as multiple lines. That is, change <code>^</code> and <code>$</code> from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string. Supported <code>s</code> Treat the string as single line. That is, change <code>.</code> to match any character whatsoever, even a newline, which normally it would not match. Supported *<code>x</code> and <code>xx</code> Extend your pattern's legibility by permitting whitespace and comments. For details see: Perl regex docs: <code>/x</code> and <code>/xx</code>. Supported <code>n</code> Prevent the grouping metacharacters <code>(</code> and <code>)</code> from capturing. This modifier will stop <code>$1</code>, <code>$2</code>, etc. from being filled in. Supported <code>c</code> Keep the current position during repeated matching. Supported"},{"location":"notes/regex_status/#escape-sequences-complete","title":"Escape sequences (Complete)","text":"Escape sequence Notes Status <code>\\t</code> Tab (HT, TAB)X Supported <code>\\n</code> Newline (LF, NL) Supported <code>\\r</code> Return (CR) Supported <code>\\f</code> Form feed (FF) Supported <code>\\a</code> Alarm (bell) (BEL) Supported <code>\\e</code> Escape (think troff) (ESC) Supported <code>\\x{}</code>, <code>\\x00</code> Character whose ordinal is the given hexadecimal number Supported <code>\\o{}</code>, <code>\\000</code> Character whose ordinal is the given octal number Supported"},{"location":"notes/regex_status/#quantifiers-complete","title":"Quantifiers (Complete)","text":"Quantifier Notes Status <code>*</code> Match 0 or more times Supported <code>+</code> Match 1 or more times Supported <code>?</code> Match 1 or 0 times Supported <code>{n}</code> Match exactly n times Supported <code>{n,}</code> Match at least n times Supported <code>{,n}</code> Match at most n times Supported <code>{n,m}</code> Match at least n but not more than m times Supported <code>*?</code> Match 0 or more times, not greedily Supported <code>+?</code> Match 1 or more times, not greedily Supported <code>??</code> Match 0 or 1 time, not greedily Supported <code>{n}?</code> Match exactly n times, not greedily (redundant) Supported <code>{n,}?</code> Match at least n times, not greedily Supported <code>{,n}?</code> Match at most n times, not greedily Supported <code>{n,m}?</code> Match at least n but not more than m times, not greedily Supported <code>*+</code> Match 0 or more times and give nothing back Supported <code>++</code> Match 1 or more times and give nothing back Supported <code>?+</code> Match 0 or 1 time and give nothing back Supported <code>{n}+</code> Match exactly n times and give nothing back (redundant) Supported <code>{n,}+</code> Match at least n times and give nothing back Supported <code>{,n}+</code> Match at most n times and give nothing back Supported <code>{n,m}+</code> Match at least n but not more than m times and give nothing back Supported"},{"location":"notes/regex_status/#character-classes-and-other-special-escapes-complete","title":"Character Classes and other Special Escapes (Complete)","text":"Feature Notes Status <code>[</code>...<code>]</code> Match a character according to the rules of the bracketed character class defined by the \"...\". Example: <code>[a-z]</code> matches \"a\" or \"b\" or \"c\" ... or \"z\" Supported <code>[[:</code>...<code>:]]</code> Match a character according to the rules of the POSIX character class \"...\" within the outer bracketed character class.  Example: <code>[[:upper:]]</code> matches any uppercase character. Supported <code>\\g1</code> or <code>\\g{-1}</code> Backreference to a specific or previous group. The number may be negative indicating a relative previous group and may optionally be wrapped in curly brackets for safer parsing. Supported <code>\\g{name}</code> Named backreference Supported <code>\\k&lt;name&gt;</code> Named backreference Supported <code>\\k'name'</code> Named backreference Supported <code>\\k{name}</code> Named backreference Supported <code>\\w</code> Match a \"word\" character (alphanumeric plus \"_\", plus other connector punctuation chars plus Unicode marks) Supported <code>\\W</code> Match a non-\"word\" character Supported <code>\\s</code> Match a whitespace character Supported <code>\\S</code> Match a non-whitespace character Supported <code>\\d</code> Match a decimal digit character Supported <code>\\D</code> Match a non-digit character Supported <code>\\v</code> Vertical whitespace Supported <code>\\V</code> Not vertical whitespace Supported <code>\\h</code> Horizontal whitespace Supported <code>\\H</code> Not horizontal whitespace Supported <code>\\1</code> Backreference to a specific capture group or buffer. '1' may actually be any positive integer. Supported <code>\\N</code> Any character but \\n.  Not affected by /s modifier Supported <code>\\K</code> Keep the stuff left of the \\K, don't include it in $&amp; Supported"},{"location":"notes/regex_status/#assertions","title":"Assertions","text":"Assertion Notes Status <code>\\b</code> Match a \\w\\W or \\W\\w boundary Supported <code>\\B</code> Match except at a \\w\\W or \\W\\w boundary Supported <code>\\A</code> Match only at beginning of string Supported <code>\\Z</code> Match only at end of string, or before newline at the end Supported <code>\\z</code> Match only at end of string Supported <code>\\G</code> Match only at pos() (e.g. at the end-of-match position of prior m//g) Supported"},{"location":"notes/regex_status/#capture-groups-complete","title":"Capture groups (Complete)","text":"Feature Status <code>(</code>...<code>)</code> Supported"},{"location":"notes/regex_status/#quoting-metacharacters-complete","title":"Quoting metacharacters (Complete)","text":"Feature Status For <code>^.[]$()*{}?+|\\</code> Supported"},{"location":"notes/regex_status/#extended-patterns","title":"Extended Patterns","text":"Extended pattern Notes Status <code>(?&lt;NAME&gt;pattern)</code> Named capture group Supported <code>(?#text)</code> Comments Supported <code>(?adlupimnsx-imnsx)</code> Modification for surrounding context Supported <code>(?^alupimnsx)</code> Modification for surrounding context Supported <code>(?:pattern)</code> Clustering, does not generate a group index. Supported <code>(?adluimnsx-imnsx:pattern)</code> Clustering, does not generate a group index and modifications for the cluster. Supported <code>(?^aluimnsx:pattern)</code> Clustering, does not generate a group index and modifications for the cluster. Supported <code>(?</code><code>|</code><code>pattern)</code> Branch reset Supported <code>(?'NAME'pattern)</code> Named capture group Supported <code>(?(condition)yes-pattern</code><code>|</code><code>no-pattern)</code> Conditional patterns. Planned <code>(?(condition)yes-pattern)</code> Conditional patterns. Planned <code>(?&gt;pattern)</code> Atomic patterns. (Disable backtrack.) Supported <code>(*atomic:pattern)</code> Atomic patterns. (Disable backtrack.) Supported"},{"location":"notes/regex_status/#lookaround-assertions","title":"Lookaround Assertions","text":"Lookaround assertion Notes Status <code>(?=pattern)</code> Positive look ahead. Supported <code>(*pla:pattern)</code> Positive look ahead. Supported <code>(*positive_lookahead:pattern)</code> Positive look ahead. Supported <code>(?!pattern)</code> Negative look ahead. Supported <code>(*nla:pattern)</code> Negative look ahead. Supported <code>(*negative_lookahead:pattern)</code> Negative look ahead. Supported <code>(?&lt;=pattern)</code> Positive look behind. Supported <code>(*plb:pattern)</code> Positive look behind. Supported <code>(*positive_lookbehind:pattern)</code> Positive look behind. Supported <code>(?&lt;!pattern)</code> Negative look behind. Supported <code>(*nlb:pattern)</code> Negative look behind. Supported <code>(*negative_lookbehind:pattern)</code> Negative look behind. Supported"},{"location":"notes/regex_status/#special-backtracking-control-verbs","title":"Special Backtracking Control Verbs","text":"Backtracking control verb Notes Status <code>(*SKIP) (*SKIP:NAME)</code> Start next search here. Planned <code>(*PRUNE) (*PRUNE:NAME)</code> No backtracking over this point. Planned <code>(*MARK:NAME) (*:NAME)</code> Place a named mark. Planned <code>(*THEN) (*THEN:NAME)</code> Like PRUNE. Planned <code>(*COMMIT) (*COMMIT:arg)</code> Stop searching. Planned <code>(*FAIL) (*F) (*FAIL:arg)</code> Fail the pattern/branch. Planned <code>(*ACCEPT) (*ACCEPT:arg)</code> Accept the pattern/subpattern. Planned"},{"location":"notes/regex_status/#not-planned-mainly-because-of-unicode-or-perl-specifics","title":"Not planned (Mainly because of Unicode or perl specifics)","text":""},{"location":"notes/regex_status/#modifiers_1","title":"Modifiers","text":"Modifier Notes Status <code>p</code> Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} are available for use after matching. Not planned <code>a</code>, <code>d</code>, <code>l</code>, and <code>u</code> These modifiers affect which character-set rules (Unicode, etc.) are used, as described below in \"Character set modifiers\". Not planned <code>g</code> globally match the pattern repeatedly in the string Not planned <code>e</code> evaluate the right-hand side as an expression Not planned <code>ee</code> evaluate the right side as a string then eval the result Not planned <code>o</code> pretend to optimize your code, but actually introduce bugs Not planned <code>r</code> perform non-destructive substitution and return the new value Not planned"},{"location":"notes/regex_status/#escape-sequences","title":"Escape sequences","text":"Escape sequence Notes Status <code>\\cK</code> control char          (example: VT) Not planned <code>\\N{name}</code> named Unicode character or character sequence Not planned <code>\\N{U+263D}</code> Unicode character     (example: FIRST QUARTER MOON) Not planned <code>\\l</code> lowercase next char (think vi) Not planned <code>\\u</code> uppercase next char (think vi) Not planned <code>\\L</code> lowercase until \\E (think vi) Not planned <code>\\U</code> uppercase until \\E (think vi) Not planned <code>\\Q</code> quote (disable) pattern metacharacters until \\E Not planned <code>\\E</code> end either case modification or quoted section, think vi Not planned"},{"location":"notes/regex_status/#character-classes-and-other-special-escapes","title":"Character Classes and other Special Escapes","text":"Character class or escape Notes Status <code>(?[...])</code> Extended bracketed character class Not planned <code>\\pP</code> Match P, named property.  Use \\p{Prop} for longer names Not planned <code>\\PP</code> Match non-P Not planned <code>\\X</code> Match Unicode \"eXtended grapheme cluster\" Not planned <code>\\R</code> Linebreak Not planned"},{"location":"notes/regex_status/#assertions_1","title":"Assertions","text":"Assertion Notes Status <code>\\b{}</code> Match at Unicode boundary of specified type Not planned <code>\\B{}</code> Match where corresponding \\b{} doesn't match Not planned"},{"location":"notes/regex_status/#extended-patterns_1","title":"Extended Patterns","text":"Extended pattern Notes Status <code>(?{ code })</code> Perl code execution. Not planned <code>(*{ code })</code> Perl code execution. Not planned <code>(??{ code })</code> Perl code execution. Not planned <code>(?PARNO)</code> <code>(?-PARNO)</code> <code>(?+PARNO)</code> <code>(?R)</code> <code>(?0)</code> Recursive subpattern. Not planned <code>(?&amp;NAME)</code> Recursive subpattern. Not planned"},{"location":"notes/regex_status/#script-runs","title":"Script runs","text":"Script runs Notes Status <code>(*script_run:pattern)</code> All chars in pattern need to be of the same script. Not planned <code>(*sr:pattern)</code> All chars in pattern need to be of the same script. Not planned <code>(*atomic_script_run:pattern)</code> Without backtracking. Not planned <code>(*asr:pattern)</code> Without backtracking. Not planned"},{"location":"welcome/hello-world/","title":"Hello, world!","text":"<pre><code>graph LR\n  A[\"` hello.cpp**2** `\"] ==&gt; B([\"` **cppfront** `\"]);\n  B ==&gt; C[hello.cpp];\n  C ==&gt; D([Your favorite&lt;br&gt; C++ compiler&lt;p&gt;... and IDE / libraries / build&lt;br&gt;system / in-house tools / ...]);</code></pre>"},{"location":"welcome/hello-world/#a-hellocpp2-program","title":"A <code>hello.cpp2</code> program","text":"<p>Here is the usual one-line starter program that prints <code>Hello, world!</code>. Note that this is a complete program, no <code>#include</code> required:</p> hello.cpp2 \u2014 on one line<pre><code>main: () = std::cout &lt;&lt; \"Hello, world!\\n\";\n</code></pre> <p>But let's add a little more, just to show a few things:</p> hello.cpp2 \u2014 slightly more interesting<pre><code>main: () = {\n    words: std::vector = ( \"Alice\", \"Bob\" );\n    hello( words[0] );\n    hello( words[1] );\n}\n\nhello: (msg: std::string_view) = {\n    std::cout &lt;&lt; \"Hello, (msg)$!\\n\";\n}\n</code></pre> <p>This short program code already illustrates a few Cpp2 essentials.</p> <p>Consistent context-free syntax. Cpp2 is designed so that there is one general way to spell a given thing, that works consistently everywhere. All Cpp2 types/functions/objects/namespaces are written using the unambiguous and context-free declaration syntax \"name <code>:</code> kind <code>=</code> statement\". The <code>:</code> is pronounced \"is a,\" and the <code>=</code> is pronounced \"defined as.\"</p> <ul> <li> <p><code>main</code> is a function that takes no arguments and returns nothing, and is defined as the code body shown.</p> </li> <li> <p><code>words</code> is a <code>std::vector</code>, initially defined as holding <code>\"Alice\"</code> and <code>\"Bob\"</code>.</p> </li> <li> <p><code>hello</code> is a function that takes a <code>std::string_view</code> it will only read from and that returns nothing, and is defined as code that prints the string to <code>cout</code> the usual C++ way.</p> </li> </ul> <p>All grammar is context-free. In particular, we (the human reading the code, and the compiler) never need to do name lookup to figure out how to parse something \u2014 there is never a \"vexing parse\" in Cpp2. For details, see Design note: Unambiguous parsing.</p> <p>Simple, safe, and efficient by default. Cpp2 has contracts (tracking draft C++26 contracts), <code>inspect</code> pattern matching, string interpolation, automatic move from last use, and more.</p> <ul> <li> <p> Declaring <code>words</code> uses \"CTAD\" (C++'s normal constructor template argument deduction) to deduce the type of elements in the <code>vector</code>.</p> </li> <li> <p>Calling <code>words[0]</code> and <code>words[1]</code> is bounds-checked by default. From Cpp2 code, ordinary <code>std::vector</code> subscript accesses are safely bounds-checked by default without requiring any upgrade to your favorite standard library, and that's true for any similar subscript of something whose size can be queried using <code>std::size()</code> and <code>std::ssize()</code>, and for which <code>std::begin()</code> returns a random access iterator, including any in-house integer-indexed container types you already have that can easily provide <code>std::size()</code> and <code>std::ssize()</code> if they don't already.</p> </li> <li> <p><code>hello</code> uses string interpolation to be able to write <code>\"Hello, (msg)$!\\n\"</code> instead of <code>\"Hello, \" &lt;&lt; msg &lt;&lt; \"!\\n\"</code>. String interpolation also supports standard C++ format specifications, so you won't need iostream manipulators.</p> </li> </ul> <p>Simplicity through generality + defaults. A major way that Cpp2 delivers simplicity is by providing just one powerful general syntax for a given thing (e.g., one function definition syntax), but designing it so you can omit the parts you're not currently using (e.g., where you're happy with the defaults). We're already using some of those defaults above:</p> <ul> <li> <p>We can omit writing the <code>-&gt; void</code> return type for a function that doesn't return anything, as both of these functions do.</p> </li> <li> <p>We can omit the <code>{</code> <code>}</code> around single-statement function bodies, as <code>hello</code> does.</p> </li> <li> <p>We can omit the <code>in</code> on the <code>msg</code> parameter. Cpp2 has just six ways to pass parameters: The most common ones are <code>in</code> for read-only (the default so we can omit it, as <code>hello</code> does), and <code>inout</code> for read-write.  The others are <code>copy</code>, <code>out</code>, <code>move</code>, and <code>forward</code>.</p> </li> </ul> <p>For details, see Design note: Defaults are one way to say the same thing.</p> <p>Order-independent by default. Did you notice that <code>main</code> called <code>hello</code>, which was defined later? Cpp2 code is order-independent by default \u2014 there are no forward declarations.</p> <p>Seamless compatibility and interop. We can just use <code>std::cout</code> and <code>std::operator&lt;&lt;</code> and <code>std::string_view</code> directly as usual. Cpp2 code works with any C++ code or library, including the standard library, using ordinary direct calls without any wrapping/marshaling/thunking.</p> <p>C++ standard library is always available. We didn't need <code>#include &lt;iostream&gt;</code> or <code>import std;</code>. The full C++ standard library is always available by default if your source file contains only syntax-2 code and you compile using cppfront's <code>-p</code> (short for <code>-pure-cpp2</code>), or if you use <code>-im</code> (short for <code>-import-std</code>). Cppfront is regularly updated to be compatible with C++23 and the latest draft C++26 library additions as soon as the ISO C++ committee votes them into the C++26 working draft, so as soon as you have a C++ implementation that has a new standard (or bleeding-edge draft standard!) C++ library feature, you'll be able to fully use it in Cpp2 code.</p>"},{"location":"welcome/hello-world/#building-hellocpp2","title":"Building <code>hello.cpp2</code>","text":"<p>Now use <code>cppfront</code> to compile <code>hello.cpp2</code> to a standard C++ file <code>hello.cpp</code>:</p> Call cppfront to produce hello.cpp<pre><code>cppfront hello.cpp2 -p\n</code></pre> <p>The result is an ordinary C++ file that looks like this: <sup>1</sup></p> hello.cpp \u2014 created by cppfront<pre><code>#define CPP2_IMPORT_STD          Yes\n\n#include \"cpp2util.h\"\n\nauto main() -&gt; int;\n\nauto hello(cpp2::in&lt;std::string_view&gt; msg) -&gt; void;\nauto main() -&gt; int{\n    std::vector words {\"Alice\", \"Bob\"};\n    hello(CPP2_ASSERT_IN_BOUNDS_LITERAL(words, 0));\n    hello(CPP2_ASSERT_IN_BOUNDS_LITERAL(std::move(words), 1));\n}\n\nauto hello(cpp2::in&lt;std::string_view&gt; msg) -&gt; void {\n    std::cout &lt;&lt; (\"Hello, \" + cpp2::to_string(msg) + \"!\\n\");  }\n</code></pre> <p>Here we can see more of how Cpp2 makes its features work.</p> <p>How: Consistent context-free syntax.</p> <ul> <li>All compiled lines are portable C++20 code we can build with pretty much any C++ compiler released circa 2019 or later. Cpp2's context-free syntax converts directly to today's Cpp1 syntax. We can write and read our C++ types/functions/objects in simpler Cpp2 syntax without wrestling with context sensitivity and ambiguity, and they're all still just ordinary types/functions/objects.</li> </ul> <p>How: Simple, safe, and efficient by default.</p> <ul> <li>Line 9: CTAD just works, because it turns into ordinary C++ code which already supports CTAD.</li> <li>Lines 10-11: Automatic bounds checking is added to <code>words[0]</code> and <code>words[1]</code> nonintrusively at the call site by default. Because it's nonintrusive, it works seamlessly with all existing container types that are <code>std::size</code> and <code>std::ssize</code>-aware, when you use them from safe Cpp2 code.</li> <li>Line 11: Automatic move from last use ensures the last use of <code>words</code> will automatically avoid a copy if it's being passed to something that's optimized for rvalues.</li> <li>Line 15: String interpolation performs the string capture of <code>msg</code>'s current value via <code>cpp2::to_string</code>. That uses <code>std::to_string</code> when available, and it also works for additional types (such as <code>bool</code>, to print <code>false</code> and <code>true</code> instead of <code>0</code> and <code>1</code>, without having to remember to use <code>std::boolalpha</code>).</li> </ul> <p>How: Simplicity through generality + defaults.</p> <ul> <li>Line 7: <code>in</code> parameters are implemented using <code>cpp2::in&lt;&gt;</code>, which is smart enough to pass by <code>const</code> value when that's safe and appropriate, otherwise by <code>const&amp;</code>, so you don't have to choose the right one by hand.</li> </ul> <p>How: Order-independent by default.</p> <ul> <li>Lines 5 and 7: Order independence happens because cppfront generates all the type and function forward declarations for you, so you don't have to. That's why <code>main</code> can just call <code>hello</code>: both are forward-declared, so they can both see each other.</li> </ul> <p>How: Seamless compatibility and interop.</p> <ul> <li>Lines 9-11 and 15: Ordinary direct calls to existing C++ code, so there's never a need for wrapping/marshaling/thunking.</li> </ul> <p>How: C++ standard library always available.</p> <ul> <li>Lines 1 and 3: <code>std::</code> is available because cppfront was invoked with <code>-p</code>, which implies either <code>-im</code> (short for <code>-import-std</code>) or <code>-in</code> (short for <code>-include-std</code>, for compilers that don't support modules yet). The generated code tells <code>cpp2util.h</code> to <code>import</code> the entire standard library as a module (or do the equivalent via headers if modules are not available).</li> </ul>"},{"location":"welcome/hello-world/#building-and-running-hellocpp-with-any-recent-c-compiler","title":"Building and running <code>hello.cpp</code> with any recent C++ compiler","text":"<p>Finally, just build <code>hello.cpp</code> using your favorite C++20 compiler, where <code>CPPFRONT_INCLUDE</code> is the path to <code>/cppfront/include</code>:</p> <p> MSVC (Visual Studio 2019 version 16.11 or higher)<pre><code>&gt; cl hello.cpp -std:c++20 -EHsc -I CPPFRONT_INCLUDE\n&gt; hello.exe\nHello, world!\n</code></pre> GCC (GCC 10 or higher)<pre><code>$ g++ hello.cpp -std=c++20 -ICPPFRONT_INCLUDE -o hello\n$ ./hello.exe\nHello, world!\n</code></pre> Clang (Clang 12 or higher)<pre><code>$ clang++ hello.cpp -std=c++20 -ICPPFRONT_INCLUDE -o hello\n$ ./hello.exe\nHello, world!\n</code></pre>"},{"location":"welcome/hello-world/#next-adding-cppfront-to-your-existing-c-project","title":"\u27a4 Next: Adding cppfront to your existing C++ project","text":"<ol> <li> <p>For presentation purposes, this documentation generally shows the <code>.cpp</code> as generated when using cppfront's <code>-cl</code> (short for <code>-clean-cpp1</code>), which suppresses extra information cppfront normally emits in the <code>.cpp</code> to light up C++ tools (e.g., to let IDEs integrate cppfront error message output, debuggers step to the right lines in Cpp2 source code, and so forth). In normal use, you won't need or even want <code>-cl</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"welcome/integration/","title":"Adding cppfront in your IDE / build system","text":"<p>To start trying out Cpp2 syntax in any existing C++ project, just add a build step to translate the Cpp2 to Cpp1 syntax:</p> <ul> <li>Copy the <code>.cpp</code> file to the same name with a <code>.cpp2</code> extension.</li> <li>Add the <code>.cpp2</code> file to the project, and ensure the <code>.cpp</code> is in C++20 mode.</li> <li>Tell the IDE to build that file using a custom build tool to invoke cppfront.</li> </ul> <p>That's it... The result Just Works with every C++20 or higher compiler and all existing C++ tools (debuggers, build systems, sanitizers, etc.). The IDE build should just pick up the <code>.cpp2</code> file source locations for any error messages, and the debugger should just step through the <code>.cpp2</code> file.</p> <p>The following uses Visual Studio as an example, but others have done the same in Xcode, Qt Creator, CMake, and other IDEs.</p>"},{"location":"welcome/integration/#1-add-the-cpp2-file-to-the-project-and-ensure-the-cpp-is-in-c20-mode","title":"1. Add the <code>.cpp2</code> file to the project, and ensure the <code>.cpp</code> is in C++20 mode","text":"<p>For Visual Studio: In the Solution Explorer, right-click on Source Files and pick Add to add the file to the project.</p> <p></p> <p>Also in Solution Explorer, right-click on the <code>.cpp</code> file Properties and make sure it's in C++20 (or C++latest) mode.</p> <p></p>"},{"location":"welcome/integration/#2-tell-the-project-system-to-build-that-file-using-a-custom-build-tool-to-invoke-cppfront-and-add-cppfrontinclude-to-the-include-path","title":"2. Tell the project system to build that file using a custom build tool to invoke cppfront, and add <code>cppfront/include</code> to the include path","text":"<p>For Visual Studio: In Solution Explorer, right-click on the <code>.cpp2</code> file and select Properties, and add the custom build tool. Remember to also tell it that the custom build tool produces the <code>.cpp</code> file, so that it knows about the build dependency:</p> <p></p> <p>Finally, put the <code>/cppfront/include</code> directory on your <code>INCLUDE</code> path. In Solution Explorer, right-click the app and select Properties, and add it to the VC++ Directories &gt; Include Directories:</p> <p></p>"},{"location":"welcome/integration/#thats-it-error-message-outputs-debuggers-visualizers-and-other-tools-should-just-work","title":"That's it: Error message outputs, debuggers, visualizers, and other tools should just work","text":"<p>That's enough to enable builds, and the IDE just picks up the rest from the <code>.cpp</code> file that cppfront generated:</p> <ul> <li> <p>The cppfront error messages in <code>filename(line, col)</code> format. Most C++ IDEs recognize these, and usually automatically merge any diagnostic output wherever compiler error output normally appears. If your IDE prefers <code>filename:line:col</code>, just use the cppfront <code>-format-colon-errors</code> command line option.</p> </li> <li> <p>The <code>#line</code> directives cppfront emits in the generated <code>.cpp</code> file. Most C++ debuggers recognize these and will know to step through the <code>.cpp2</code> file. Note that <code>#line</code> emission is on by default, but if you choose <code>-c</code> (short for <code>-clean-cpp1</code>) these will be suppressed and then the debugger will step through the generated C++ code instead.  If your debugger can't find the files, you may need to use <code>-line-paths</code> to have absolute paths instead of relative paths in the <code>#line</code> directives.</p> </li> <li> <p>Regardless of syntax, every type/function/object/namespace/etc. is still just an ordinary C++ type/function/object/namespace/etc. Most C++ debugger visualizers will just work and show beautiful output for the types your program uses, including to use any in-the-box visualizers for all the <code>std::</code> types (since those are used directly as usual) and any custom visualizers you may have already written for your own types or popular library types.</p> </li> </ul>"},{"location":"welcome/overview/","title":"Overview: What are Cpp2 and cppfront? How do I get and build cppfront?","text":"hello.cpp2<pre><code>main: () = {\n    std::cout &lt;&lt; \"Hello, world!\\n\";\n}\n</code></pre>"},{"location":"welcome/overview/#what-is-cpp2","title":"What is Cpp2?","text":"<p>\"Cpp2,\" short for \"C++ syntax 2,\" is my (Herb Sutter's) personal project to try to make writing ordinary C++ types/functions/objects be much simpler and safer, without breaking backward compatibility.</p> <p>What it isn't. Cpp2 is not a successor or alternate language with its own divergent or incompatible ecosystem. For example, it does not have its own nonstandard incompatible modules/concepts/etc. that compete with the Standard C++ features; it does not replace your Standard C++ compiler or other tools; and it does not require any changes to your Standard C++ compiler or standard library or other libraries or tools to keep fully using all of them.</p> <p>What it is. Cpp2 aims to be another \"skin\" for C++ itself, just a simpler and safer way to write ordinary C++ types/functions/objects, and a faster way to experiment with proposals for future new Standard C++ features in a simpler compiler and syntax flavor. It seamlessly uses Standard C++ modules and concepts requirements and other features, and it works with all existing C++20 or higher compilers and libraries and tools right out of the box with no changes required to use them all seamlessly and directly with zero overhead.</p> <p>Bjarne Stroustrup said it best:</p> <p>\"Inside C++, there is a much smaller and cleaner language struggling to get out.\" \u2003\u2003\u2014 Bjarne Stroustrup, The Design and Evolution of C++ (D&amp;E), 1994</p> <p>\"Say 10% of the size of C++ in definition and similar in front-end compiler size. ... most of the simplification would come from generalization.\" \u2003\u2003\u2014 Bjarne Stroustrup, ACM History of Programming Languages III, 2007</p> <p>My goal is to try to prove that Stroustrup is right: that it's possible and desirable to have true C++ with all its expressive power and control and with full backward compatibility, but in a flavor that's 10x simpler with fewer quirks and special cases to remember, <sup>1</sup> and 50x safer where it's far easier to not write security bugs by accident.</p> <p>We can't make an improvement that large to C++ via gradual evolution to today's syntax, because some important changes would require changing the meaning of code written in today's syntax. For example, we can never change a language feature default in today's syntax, not even if the default creates a security vulnerability pitfall, because changing a default would break vast swathes of existing code. Having a distinct alternative syntax gives us a \"bubble of new code\" that doesn't exist today, and have:</p> <ul> <li> <p>Freedom to make any desired improvement, without breaking any of today's code. Cpp2 is designed to take all the consensus C++ best-practices guidance we already teach, and make them the default when using \"syntax 2.\" Examples: Writing type-unsafe casts is just not possible in Cpp2 syntax; and Cpp2 can change language defaults to make them simpler and safer. You can always \"break the glass\" when needed to violate the guidance, but you have to opt out explicitly to write type-unsafe code (usually using the word <code>unchecked</code>), so if the program has a bug you can grep for those places to look at first. For details, see Design note: unsafe code.</p> </li> <li> <p>Perfect link compatibility always on, perfect source compatibility always available (but you pay for it only if you use it). Any type/function/object/namespace written in either syntax is always still just a normal C++ type/function/object/namespace, so any code or library written in either Cpp2 or today's C++ syntax (\"Cpp1\" for short) can seamlessly call each other, with no wrapping/marshaling/thunking. You can write a \"mixed\" source file that has both Cpp2 and Cpp1 code and get perfect backward C++ source compatibility (even SFINAE and macros), or you can write a \"pure\" all-Cpp2 source file and write code in a 10x simpler syntax.</p> </li> </ul>"},{"location":"welcome/overview/#what-is-cppfront","title":"What is cppfront?","text":"<p>Cppfront is a compiler that compiles Cpp2 syntax to today's Cpp1 syntax. This lets you start trying out Cpp2 syntax in any existing C++ project and build system just by renaming a source file from <code>.cpp</code> to <code>.cpp2</code> and adding a build step, and the result Just Works with every C++20 or higher compiler and all existing C++ tools (debuggers, build systems, sanitizers, etc.).</p> <p>This deliberately follows Bjarne Stroustrup's wise approach with cfront, the original C++ compiler: In the 1980s and 1990s, Stroustrup created cfront to translate C++ to pure C, and similarly ensured that C++ could be interleaved with C in the same source file, and that C++ could always call any C code with no wrapping/marshaling/thunking. By providing a C++ compiler that emitted pure C, Stroustrup ensured full compatibility with the C ecosystems that already existed, and made it easy for people to start trying out C++ code in any existing C project by adding just another build step to translate the C++ to C first, and the result Just Worked with existing C tools.</p>"},{"location":"welcome/overview/#how-do-i-get-and-build-cppfront","title":"How do I get and build cppfront?","text":"<p>The full source code for cppfront is at the Cppfront GitHub repo.</p> <p>Cppfront builds with any recent C++ compiler. Go to the <code>/cppfront/source</code> directory, and run one of the following:</p> <p> MSVC build instructions (Visual Studio 2019 version 16.11 or higher)<pre><code>cl cppfront.cpp -std:c++20 -EHsc\n</code></pre> GCC build instructions (GCC 10 or higher)<pre><code>g++ cppfront.cpp -std=c++20 -o cppfront\n</code></pre> Clang build instructions (Clang 12 or higher)<pre><code>clang++ cppfront.cpp -std=c++20 -o cppfront\n</code></pre> <p>That's it!</p> <p>Note: On Windows (including MinGW), if you get a \"too many sections\" message, specify the switch <code>/bigobj</code> (MSVC) or <code>/Wa,-mbig-obj</code> (GCC).</p>"},{"location":"welcome/overview/#next-hello-world","title":"\u27a4 Next: Hello, world!","text":"<ol> <li> <p>I'd ideally love to obsolete ~90% of my own books. I know that Cpp2 can eliminate that much of the C++ guidance I've personally had to write and teach over the past quarter century, by removing inconsistencies and pitfalls and gotchas, so that they're either impossible to write or are compile-time errors (either way, we don't have to teach them). I love writing C++ code... I just want it to be easier and safer by default.\u00a0\u21a9</p> </li> </ol>"}]}