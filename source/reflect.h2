
//  Copyright 2022-2024 Herb Sutter
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//  
//  Part of the Cppfront Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://github.com/hsutter/cppfront/blob/main/LICENSE for license information.


//===========================================================================
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copyable type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*);
    }

    //  Common API
    //
    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view) = _=includes*.emplace( s );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copyable <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copyable type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function : (this) -> function_declaration = (n, this);
    as_object   : (this) -> object_declaration   = (n, this);
    as_type     : (this) -> type_declaration     = (n, this);
    as_alias    : (this) -> alias_declaration    = (n, this);

    get_parent  : (this) -> declaration          = declaration(n*.parent_declaration, this);

    parent_is_function   : (this) -> bool = n*.parent_is_function();
    parent_is_object     : (this) -> bool = n*.parent_is_object();
    parent_is_type       : (this) -> bool = n*.parent_is_type();
    parent_is_namespace  : (this) -> bool = n*.parent_is_namespace();
    parent_is_alias      : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copyable type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_compound_body            : (this) -> compound_statement = (n*.get_compound_initializer(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param*.declaration.get(), this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param*.declaration.get(), this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copyable type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type declarations
//
type_declaration: @copyable type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_type_scope_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }

    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copyable type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
// 
//  Statements
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  General statement
//
statement: @polymorphic_base @copyable type =
{
    this: reflection_base<statement_node> = ();

    operator=: (
        out this,
        n_: *statement_node,
        s : compiler_services
    )
    = {
        reflection_base<statement_node> = (n_, s);
    }

    is_expression_statement : (this) -> bool = n*.is_expression();
    is_compound_statement   : (this) -> bool = n*.is_compound();
    is_selection_statement  : (this) -> bool = n*.is_selection();
    is_declaration_statement: (this) -> bool = n*.is_declaration();
    is_return_statement     : (this) -> bool = n*.is_return();
    is_iteration_statement  : (this) -> bool = n*.is_iteration();
    is_using_statement      : (this) -> bool = n*.is_using();
    is_contract             : (this) -> bool = n*.is_contract();
    is_inspect_expression   : (this) -> bool = n*.is_inspect();
    is_jump_statement       : (this) -> bool = n*.is_jump();

    as_expression_statement : (this) -> expression_statement  = (n*.get_if<expression_statement_node>(), this);
    as_compound_statement   : (this) -> compound_statement    = (n*.get_if<compound_statement_node>(), this);
    //as_selection_statement  : (this) -> selection_statement   = selection_statement  (n*.get_if<selection_statement_node>(), this);
    //as_declaration_statement: (this) -> declaration_statement = declaration_statement(n*.get_if<declaration_statement_node>(), this);
    //as_return_statement     : (this) -> return_statement      = return_statement     (n*.get_if<return_statement_node>(), this);
    //as_iteration_statement  : (this) -> iteration_statement   = iteration_statement  (n*.get_if<iteration_statement_node>(), this);
    //as_using_statement      : (this) -> using_statement       = using_statement      (n*.get_if<using_statement_node>(), this);
    //as_contract             : (this) -> contract              = contract             (n*.get_if<contract_node>(), this);
    //as_inspect_expression   : (this) -> inspect_expression    = inspect_expression   (n*.get_if<inspect_expression_node>(), this);
    //as_jump_statement       : (this) -> jump_statement        = jump_statement       (n*.get_if<jump_statement_node>(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression statements
//
expression_statement: @copyable type =
{
    this: reflection_base<expression_statement_node> = ();

    operator=: (
        out this,
        n_: *expression_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_statement_node> = (n_, s);
    }

    get_expression: (this) -> expression  = (n*.expr.get(), this);

    to_string     : (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Compound statements
//
compound_statement: @copyable type =
{
    this: reflection_base<compound_statement_node> = ();

    operator=: (
        out this,
        n_: *compound_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<compound_statement_node> = (n_, s);
    }

    get_statements: (this)
        -> std::vector<statement>
    = {
        ret: std::vector<statement> = ();
        for n*.get_statements() do (stmt) {
            _ = ret.emplace_back( stmt, this );
        }
        return ret;
    }

    add_statement: (inout this, source: std::string_view, before_position: int = 0)
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        require( n*.add_statement(move stmt, before_position),
                 std::string("unexpected error while attempting to add statement:\n") + source );
    }
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Postfix expressions
//
postfix_expression: @copyable type =
{
    this: reflection_base<postfix_expression_node> = ();

    operator=: (
        out this,
        n_: *postfix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<postfix_expression_node> = (n_, s);
    }

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();

    // get_expression_list          : (this) -> expression_list
    // get_literal                  : (this) -> literal

    get_first_token_ignoring_this: (this) -> std::string_view = n*.get_first_token_ignoring_this()*;

    starts_with_function_call_with_num_parameters: (this, num: int) -> bool = n*.starts_with_function_call_with_n_parameters(num);
    is_result_a_temporary_variable               : (this) -> bool           = n*.is_result_a_temporary_variable             ();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copyable <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    // get_expression_list          : (this) -> expression_list
    // get_literal                  : (this) -> literal

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  is_as_expression
//
is_as_expression: @polymorphic_base @copyable type =
{
    this: reflection_base<is_as_expression_node> = ();

    operator=: (
        out this,
        n_: *is_as_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<is_as_expression_node> = (n_, s);
    }

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  General expression
//
expression: @polymorphic_base @copyable type =
{
    this: reflection_base<expression_node> = ();

    operator=: (
        out this,
        n_: *expression_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_node> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = n*.is_fold_expression      ();
    is_standalone_expression: (this) -> bool = n*.is_standalone_expression();
    subexpression_count     : (this) -> int  = n*.subexpression_count     ();
    is_identifier           : (this) -> bool = n*.is_identifier           ();
    is_id_expression        : (this) -> bool = n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = n*.is_expression_list      ();
    is_empty_expression_list: (this) -> bool = n*.is_empty_expression_list();
    is_literal              : (this) -> bool = n*.is_literal              ();

    is_simple_assignment    : (this) -> bool = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        return ret.lhs && ret.rhs;
    }

    get_lhs_rhs_if_simple_assignment: (this)
        -> (
            lhs: postfix_expression, 
            rhs: logical_or_expression
        )
    = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        lhs = (ret.lhs, this);
        rhs = (ret.rhs, this);
    }

    get_assignment_expression: (this) -> assignment_expression = (n*.expr.get(), this);

    // get_expression_list: (this) -> expression_list
    // get_literal        : (this) -> literal

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//
//  Metafunctions - these are hardwired for now until we get to the
//  step of writing a Cpp2 interpreter to run inside the compiler
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Some common metafunction helpers (metafunctions are just functions,
//  so they can be factored as usual)
//
add_virtual_destructor: (inout t: meta::type_declaration) =
{
    t.add_member( "operator=: (virtual move this) = { }");
}


//-----------------------------------------------------------------------
//
//      "... an abstract base class defines an interface ..."
//
//          -- Stroustrup (The Design and Evolution of C++, 12.3.1)
//
//-----------------------------------------------------------------------
//
//  interface
//
//  an abstract base class having only pure virtual functions
//
interface: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_members() do (inout m)
    {
        m.require( !m.is_object(),
                   "interfaces may not contain data objects");
        if m.is_function() {
            mf := m.as_function();
            mf.require( !mf.is_copy_or_move(),
                        "interfaces may not copy or move; consider a virtual clone() instead");
            mf.require( !mf.has_initializer(),
                        "interface functions must not have a function body; remove the '=' initializer");
            mf.require( mf.make_public(),
                        "interface functions must be public");
            mf.default_to_virtual();
            has_dtor |= mf.is_destructor();
        }
    }

    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "C.35: A base class destructor should be either public and
//      virtual, or protected and non-virtual."
//
//     "[C.43] ... a base class should not be copyable, and so does not
//      necessarily need a default constructor."
//
//          -- Stroustrup, Sutter, et al. (C++ Core Guidelines)
//
//-----------------------------------------------------------------------
//
//  polymorphic_base
//
//  A pure polymorphic base type that is not copyable, and whose
//  destructor is either public and virtual or protected and nonvirtual.
//
//  Unlike an interface, it can have nonpublic and nonvirtual functions.
//
polymorphic_base: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.is_default_access() {
            mf.default_to_public();
        }
        mf.require( !mf.is_copy_or_move(),
                    "polymorphic base types may not copy or move; consider a virtual clone() instead");
        if mf.is_destructor() {
            has_dtor = true;
            mf.require( ((mf.is_public() || mf.is_default_access()) && mf.is_virtual())
                        || (mf.is_protected() && !mf.is_virtual()),
                        "a polymorphic base type destructor must be public and virtual, or protected and nonvirtual");
        }
    }

    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "... A totally ordered type ... requires operator<=> that
//      returns std::strong_ordering. If the function is not
//      user-written, a lexicographical memberwise implementation
//      is generated by default..."
//
//          -- P0707R4, section 3
//
//      Note: This feature derived from Cpp2 was already adopted
//            into Standard C++ via paper P0515, so most of the
//            heavy lifting is done by the Cpp1 C++20/23 compiler,
//            including the memberwise default semantics
//            (In contrast, cppfront has to do the work itself for
//            default memberwise semantics for operator= assignment
//            as those aren't yet part of Standard C++)
//
//-----------------------------------------------------------------------
//

ordered_impl: (
    inout t:  meta::type_declaration,
    ordering: std::string_view  // must be "strong_ordering" etc.
) =
{
    has_spaceship := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.has_name("operator<=>") {
            has_spaceship = true;
            return_name := mf.get_unnamed_return_type();
            if return_name.find(ordering) == return_name.npos
            {
                mf.error( "operator<=> must return std::" + ordering as std::string );
            }
        }
    }

    if !has_spaceship {
        t.add_member( "operator<=>: (this, that) -> std::" + (ordering as std::string) + ";" );
    }
}

//-----------------------------------------------------------------------
//  ordered - a totally ordered type
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "strong_ordering" );
}

//-----------------------------------------------------------------------
//  weakly_ordered - a weakly ordered type
//
weakly_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "weak_ordering" );
}

//-----------------------------------------------------------------------
//  partially_ordered - a partially ordered type
//
partially_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "partial_ordering" );
}


//-----------------------------------------------------------------------
//
//     "A value is ... a regular type. It must have all public
//      default construction, copy/move construction/assignment,
//      and destruction, all of which are generated by default
//      if not user-written; and it must not have any protected
//      or virtual functions (including the destructor)."
//
//          -- P0707R4, section 3
//
//-----------------------------------------------------------------------
//
//  copyable
//
//  A type with (copy and move) x (construction and assignment)
//
copyable: (inout t: meta::type_declaration) =
{
    //  If the user explicitly wrote any of the copy/move functions,
    //  they must also have written the most general one - we can't
    //  assume we can safely generate it for them since they've opted
    //  into customized semantics
    smfs := t.query_declared_value_set_functions();
    if  !smfs.out_this_in_that
        && (
            smfs.out_this_move_that
            || smfs.inout_this_in_that
            || smfs.inout_this_move_that
        )
    {
        t.error( 
            "this type is partially copyable/movable - when you provide "
            "any of the more-specific operator= signatures, you must also provide "
            "the one with the general signature (out this, that); alternatively, "
            "consider removing all the operator= functions and let them all be "
            "generated for you with default memberwise semantics" 
        );
    }
    else if !smfs.out_this_in_that {
        t.add_member( "operator=: (out this, that) = { }");
    }
}

//-----------------------------------------------------------------------
//
//  hashable
//
//  A memberwise hashable type
//
hashable: (inout t: meta::type_declaration) =
{
    t.require( !t.get_member_objects().empty(),
               "a hashable type must have at least one data member");

    hash: std::string = "    hash: (this) -> size_t = {\n"
                        "        ret: size_t = 0;";

    for  t.get_member_objects() 
    do   (o)
    {
        o_hash: std::string;
        if o.name() == "this" {
            o_hash = "(o.type())$::hash()";
        }
        else {
            o_hash = "std::hash<(o.type())$>()((o.name())$)";
        }

        hash += "\n        cpp2::hash_combine( ret, (o_hash)$ );";
    }

    t.add_member(hash + "\n        return ret;\n    }");
}


//-----------------------------------------------------------------------
//
//  basic_value
//
//  A regular type: copyable, plus has public default construction
//  and no protected or virtual functions
//
basic_value: (inout t: meta::type_declaration) =
{
    t.copyable();

    has_default_ctor := false;
    for t.get_member_functions() do (inout mf) {
        has_default_ctor |= mf.is_default_constructor();
        mf.require( !mf.is_protected() && !mf.is_virtual(),
                    "a value type may not have a protected or virtual function");
        mf.require( !mf.is_destructor() || mf.is_public() || mf.is_default_access(),
                    "a value type may not have a non-public destructor");
    }

    if !has_default_ctor {
        t.add_member( "operator=: (out this) = { }");
    }
}

//-----------------------------------------------------------------------
//
//     "A 'value' is a totally ordered basic_value..."
//
//          -- P0707R4, section 3
//
//  value - a value type that is totally ordered
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
value: (inout t: meta::type_declaration) =
{
    t.ordered();
    t.basic_value();
}

weakly_ordered_value: (inout t: meta::type_declaration) =
{
    t.weakly_ordered();
    t.basic_value();
}

partially_ordered_value: (inout t: meta::type_declaration) =
{
    t.partially_ordered();
    t.basic_value();
}


//-----------------------------------------------------------------------
//
//     C.20: If you can avoid defining default operations, do
//
//     ##### Reason
//
//     It's the simplest and gives the cleanest semantics.
//
//     ...
//
//     This is known as "the rule of zero".
//
//          -- C++ Core Guidelines
//             C.20: If you can avoid defining any default operations, do
//             <https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero>
//
//-----------------------------------------------------------------------
//
//  cpp1_rule_of_zero
//
//  a type without declared copy/move/destructor functions
//
cpp1_rule_of_zero: (inout t: meta::type_declaration) =
{
    for t.get_member_functions() do (inout mf)
    {
        t.require( !mf.is_constructor_with_that()
                   && !mf.is_assignment_with_that()
                   && !mf.is_destructor(),
                   "the rule of zero requires no copy/move/destructor functions");
    }
    t.disable_member_function_generation();
}

//-----------------------------------------------------------------------
//
//     "By definition, a `struct` is a `class` in which members
//      are by default `public`; that is,
//
//      	struct s { ...
//
//      is simply shorthand for
//
//          class s { public: ...
//
//      ... Which style you use depends on circumstances and taste.
//      I usually prefer to use `struct` for classes that have all
//      data `public`."
//
//          -- Stroustrup (The C++ Programming Language, 3rd ed., p. 234)
//
//-----------------------------------------------------------------------
//
//  struct
//
//  a type with only public bases, objects, and functions,
//  no virtual functions, and no user-defined constructors
//  (i.e., no invariants) or assignment or destructors.
// 
//  For GCC 10 compatibility, optionally allow passing struct<noforward>
//  that generates a memberwise constructor with a generic deduced
//  parameters instead of concrete forwarding parameters (mainly used
//  for cppfront internal use, so cppfront builds under GCC 10)
//
struct: (inout t: meta::type_declaration) =
{
    ctor_params: std::string = ();
    ctor_inits : std::string = ();

    found_member_without_initializer: = false;

    for t.get_members() do (inout m)
    {
        m.require( m.make_public(),
                   "all struct members must be public");
        if m.is_function() {
            mf := m.as_function();
            t.require( !mf.is_virtual(),
                       "a struct may not have a virtual function");
            t.require( !mf.has_name("operator="),
                       "a struct may not have a user-defined operator=");
        }
        else if m.is_object() {
            mo: = m.as_object();
            if mo.name() != "this" {
                if t.get_argument(0) == "noforward" {
                    ctor_params += "(mo.name())$_, ";
                }
                else {
                    ctor_params += "forward (mo.name())$_ : (mo.type())$, ";
                }
                ctor_inits  += "(mo.name())$ = (mo.name())$_; ";
            }
            else {
                ctor_inits += "(mo.type())$ = ((mo.initializer())$); ";
            }
            found_member_without_initializer |= !mo.has_initializer();
        }
    }
    t.cpp1_rule_of_zero();

    //  If we found any data members
    if !ctor_params.empty()
    {
        //  Then to enable construction from corresponding values
        //  requires a constructor... an exception to the rule of zero
        t.add_member("    operator=: (implicit out this, (ctor_params)$) = { (ctor_inits)$ }");

        //  And if all members had initializers, we need a default constructor
        if !found_member_without_initializer {
            t.add_member("    operator=: (implicit out this) = { }");
        }
    }
}


//-----------------------------------------------------------------------
//
//     "C enumerations constitute a curiously half-baked concept. ...
//      the cleanest way out was to deem each enumeration a separate type."
//
//          -- Stroustrup (The Design and Evolution of C++, 11.7)
//
//     "An enumeration is a distinct type ... with named constants"
//
//          -- ISO C++ Standard
//
//-----------------------------------------------------------------------
//
//  basic_enum
//
//  a type together with named constants that are its possible values
//
value_member_info: @struct<noforward> type = {
    name  : std::string;
    type  : std::string;
    value : std::string;
}

basic_enum: (
    inout t : meta::type_declaration,
    nextval ,
    bitwise : bool
    )
= {
    enumerators     : std::vector<value_member_info> = ();
    min_value       : i64                            = ();
    max_value       : i64                            = ();
    underlying_type : std::string;

    t.reserve_names( "operator=", "operator<=>" );
    if bitwise {
        t.reserve_names( "has", "set", "clear", "to_string", "get_raw_value", "none" );
    }

    //  1. Gather: The names of all the user-written members, and find/compute the type

    underlying_type = t.get_argument(0);    // use the first template argument, if there was one

    found_non_numeric := false;

    (copy value: std::string = "-1")
    for  t.get_members()
    do   (m)
    if   m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                    "an enumerator cannot be protected or private");

        mo := m.as_object();
        if !mo.has_wildcard_type() {
            mo.error( 
                "an explicit underlying type should be specified as a compile-time argument "
                "to the metafunction - try 'enum<u16>' or 'flag_enum<u64>'"
            );
        }

        init := mo.initializer();

        is_default_or_numeric := is_empty_or_a_decimal_number(init);
        found_non_numeric |= !init.empty() && !is_default_or_numeric;
        m.require( !is_default_or_numeric || !found_non_numeric || mo.has_name("none"),
            "(mo.name())$: enumerators with non-numeric values must come after all default and numeric values");

        nextval( value, init );

        v := std::strtoll(value[0]&, nullptr, 10);  // for non-numeric values we'll just get 0 which is okay for now
        if v < min_value {
            min_value = v;
        }
        if v > max_value {
            max_value = v;
        }

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, "", value );
        enumerators.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    if (enumerators.empty()) {
        t.error( "an enumeration must contain at least one enumerator value");
        return;
    }

    //  Compute the default underlying type, if it wasn't explicitly specified
    if underlying_type == ""
    {
        t.require( !found_non_numeric,
            "if you write an enumerator with a non-numeric-literal value, "
            "you must specify the enumeration's underlying type"
        );

        if !bitwise {
            if min_value >= std::numeric_limits<i8>::min() && max_value <= std::numeric_limits<i8>::max() {
                underlying_type = "i8";
            }
            else if min_value >= std::numeric_limits<i16>::min() && max_value <= std::numeric_limits<i16>::max() {
                underlying_type = "i16";
            }
            else if min_value >= std::numeric_limits<i32>::min() && max_value <= std::numeric_limits<i32>::max() {
                underlying_type = "i32";
            }
            else if min_value >= std::numeric_limits<i64>::min() && max_value <= std::numeric_limits<i64>::max() {
                underlying_type = "i64";
            }
            else {
                t.error(
                    "values are outside the range representable by the "
                    "largest supported underlying signed type (i64)" 
                );
            }
        }
        else {
            umax := max_value * 2 as u64;
            if umax <= std::numeric_limits<u8>::max() {
                underlying_type = "u8";
            }
            else if umax <= std::numeric_limits<u16>::max() {
                underlying_type = "u16";
            }
            else if umax <= std::numeric_limits<u32>::max() {
                underlying_type = "u32";
            }
            else {
                underlying_type = "u64";
            }
        }
    }


    //  2. Replace: Erase the contents and replace with modified contents
    //
    //  Note that most values and functions are declared as '==' compile-time values, i.e. Cpp1 'constexpr'

    t.remove_marked_members();

    //  Generate the 'none' value if appropriate, and use that or
    //  else the first enumerator as the default-constructed value
    default_value := enumerators[0].name;
    if bitwise{
        default_value = "none";
        e: value_member_info = ( "none", "", "0");
        enumerators.push_back( e );
    }

    //  Generate all the private implementation
    t.add_member( "    _value            : (underlying_type)$;");
    t.add_member( "    private operator= : (implicit out this, _val: i64) == "
                                            "_value = cpp2::unchecked_narrow<(underlying_type)$>(_val);");

    //  Generate the bitwise operations
    if bitwise {
        t.add_member( "    operator|=: ( inout this, that )                 == _value |= that._value;");
        t.add_member( "    operator&=: ( inout this, that )                 == _value &= that._value;");
        t.add_member( "    operator^=: ( inout this, that )                 == _value ^= that._value;");
        t.add_member( "    operator| : (       this, that ) -> (t.name())$  == _value |  that._value;");
        t.add_member( "    operator& : (       this, that ) -> (t.name())$  == _value &  that._value;");
        t.add_member( "    operator^ : (       this, that ) -> (t.name())$  == _value ^  that._value;");
        t.add_member( "    has       : (       this, that ) -> bool         == _value &  that._value;");
        t.add_member( "    set       : ( inout this, that )                 == { _value |= that._value;  }");
        t.add_member( "    clear     : ( inout this, that )                 == { _value &= that._value~; }");
    }

    //  Add the enumerators
    for enumerators do (e) {
        t.add_member( "    (e.name)$ : (t.name())$ == (e.value)$;");
    }

    //  Generate the common functions
    t.add_member( "    get_raw_value     : (this) -> (underlying_type)$ == _value;");
    t.add_member( "    operator=         : (out this) == { _value = (default_value)$._value; }");
    t.add_member( "    operator=         : (out this, that) == { }");
    t.add_member( "    operator<=>       : (this, that) -> std::strong_ordering;");

    //  Provide 'to_string' and 'to_code' functions to print enumerator
    //  name(s) as human-readable strings or as code expressions
    (copy to_string_impl: std::string = "    to_string_impl: (this, prefix: std::string_view")
    {
        if bitwise {
            to_string_impl += ", separator: std::string_view ) -> std::string = { \n"
                              "    ret : std::string = \"(\";\n"
                              "    sep : std::string = ();\n"
                              "    if this == none { return \"(none)\"; }\n";
        }
        else {
            to_string_impl += ") -> std::string = { \n";
        }

        to_string_impl += "    pref := cpp2::to_string(prefix);\n";

        for  enumerators
        do   (e) {
            if e.name != "_" {  // ignore unnamed values
                if bitwise {
                    if e.name != "none" {
                        to_string_impl += "    if (this & (t.name())$::(e.name)$) == (t.name())$::(e.name)$ { "
                                                  "ret += sep + pref + \"(e.name)$\"; sep = separator; "
                                              "}\n";
                    }
                }
                else {
                    to_string_impl += "    if this == (t.name())$::(e.name)$ { return pref + \"(e.name)$\"; }\n";
                }
            }
        }

        if bitwise {
            to_string_impl += "    return ret+\")\";\n}\n";
        }
        else {
            to_string_impl += "    return \"invalid (t.name())$ value\";\n}\n";
        }

        t.add_member( to_string_impl );
    }

    if bitwise {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\", \", \" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\", \" | \" );" );
    }
    else {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\" );" );
    }

    //  Provide a 'from_string' function to parse strings into enumerators    
    (copy from_string: std::string = "    from_string: (s: std::string_view) -> (t.name())$ = { \n")
    {
        prefix    : std::string_view = "";
        combine_op: std::string_view = "return";

        //  For flags, accept a list that we break apart and then |= together
        if bitwise 
        {
            prefix      = "flag_";
            combine_op  = "ret |=";

            from_string += "        ret := none;\n"
                           "        outer: do {\n"
                           "        for cpp2::string_util::split_string_list(s) do (x) {\n";
        }
        //  Otherwise, accept just a single string
        else {
            from_string += "        x := s;\n";
        }

        (copy else_: std::string_view = "")
        for  enumerators
        do   (e) {
            from_string += "            (else_)$if \"(e.name)$\" == x { (combine_op)$ (t.name())$::(e.name)$; }\n";
            else_ = "else ";
        }

        if bitwise {
            from_string += "            else { break outer; }\n"
                           "        }\n"
                           "        return ret;\n"
                           "        } while false;\n";
        }

        from_string += "        cpp2::type_safety.report_violation( (\"can't convert string '\" + cpp2::to_string(s) + \"' to (prefix)$enum of type (t.name())$\").c_str() );\n"
                       "        return (t.name())$::(default_value)$;\n"
                       "    }\n\n";

        t.add_member( from_string );
    }

    t.add_member( "    from_code: (s: std::string_view) -> (t.name())$ = { str: std::string = s; return from_string( cpp2::string_util::replace_all(str, \"(t.name())$::\", \"\" ) ); }" );
}


//-----------------------------------------------------------------------
//
//    "An enum[...] is a totally ordered value type that stores a
//     value of its enumerators's type, and otherwise has only public
//     member variables of its enumerator's type, all of which are
//     naturally scoped because they are members of a type."
//
//          -- P0707R4, section 3
//
enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with an incrementing value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                value = (v + 1) as std::string;
            }
        },
        false   // disable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "flag_enum expresses an enumeration that stores values
//      corresponding to bitwise-or'd enumerators. The enumerators must
//      be powers of two, and are automatically generated [...] A none
//      value is provided [...] Operators | and & are provided to
//      combine and extract values."
//
//          -- P0707R4, section 3
//
flag_enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with a power-of-two value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                if v < 1 {
                    value = "1";
                }
                else {
                    value = (v * 2) as std::string;
                }
            }
        },
        true    // enable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "As with void*, programmers should know that unions [...] are
//      inherently dangerous, should be avoided wherever possible,
//      and should be handled with special care when actually needed."
//
//          -- Stroustrup (The Design and Evolution of C++, 14.3.4.1)
//
//     "C++17 needs a type-safe union... The implications of the
//      consensus `variant` design are well understood and have been
//      explored over several LEWG discussions, over a thousand emails,
//      a joint LEWG/EWG session, and not to mention 12 years of
//      experience with Boost and other libraries."
//
//          -- Axel Naumann, in P0088 (wg21.link/p0088),
//             the adopted proposal for C++17 std::variant
//
//-----------------------------------------------------------------------
//
//  union
//
//  a type that contains exactly one of a fixed set of values at a time
//

union: (inout t : meta::type_declaration)
= {
    alternatives : std::vector<value_member_info> = ();

    //  1. Gather: All the user-written members, and find/compute the max size

    (copy value := 0)
    for   t.get_members()
    next  value++
    do    (m)
    if    m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                   "a union alternative cannot be protected or private"
                );

        m.require( !m.name().starts_with("is_")
                   && !m.name().starts_with("set_"),
                   "a union alternative's name cannot start with 'is_' or 'set_' - that could cause "
                   "user confusion with the 'is_alternative' and 'set_alternative' generated functions"
                );

        mo := m.as_object();
        mo.require( mo.initializer().empty(),
                    "a union alternative cannot have an initializer"
                );

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, mo.type(), value as std::string );
        alternatives.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    discriminator_type: std::string = ();
    if alternatives.ssize() < std::numeric_limits<i8>::max() {
        discriminator_type = "i8";
    }
    else if alternatives.ssize() < std::numeric_limits<i16>::max() {
        discriminator_type = "i16";
    }
    else if alternatives.ssize() < std::numeric_limits<i32>::max() {
        discriminator_type = "i32";
    }
    else {
        discriminator_type = "i64";
    }


    //  2. Replace: Erase the contents and replace with modified contents

    t.remove_marked_members();

    //  Provide storage
    (copy storage: std::string = "    _storage: cpp2::aligned_storage<cpp2::max( ")
    {
        for  alternatives
        do   (e) {
            storage += "sizeof((e.type)$), ";
        }

        storage += "), cpp2::max( ";

        for  alternatives
        do   (e) {
            storage += "alignof((e.type)$), ";
        }

        storage += " )> = ();\n";
        t.add_member( storage );
    }

    //  Provide discriminator
    t.add_member( "    _discriminator: (discriminator_type)$ = -1;\n");

    //  Add the alternatives: is_alternative, get_alternative, and set_alternative
    for alternatives
    do  (a)
    {
        t.add_member( "    is_(a.name)$: (this) -> bool = _discriminator == (a.value)$;\n");

        t.add_member( "    (a.name)$: (this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<* const (a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    (a.name)$: (inout this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<*(a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, _value: (a.type)$) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _value); } "
                            "else { reinterpret_cast<*(a.type)$>(_storage&)* = _value; } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, forward _args...: _) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _args...); } "
                            " else { reinterpret_cast<*(a.type)$>(_storage&)* = :(a.type)$ = (_args...); } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );
    }

    //  Add destroy
    (copy destroy: std::string = "    private _destroy: (inout this) = {\n")
    {
        for  alternatives
        do   (a) {
            destroy += "        if _discriminator == (a.value)$ { std::destroy_at( reinterpret_cast<*(a.type)$>(_storage&) ); }\n";
        }

        destroy += "        _discriminator = -1;\n"
                   "    }\n";
        t.add_member( destroy );
    }

    //  Add the destructor
    t.add_member( "    operator=: (move this) = { _destroy(); _ = this; }" );

    //  Add default constructor
    t.add_member( "    operator=: (out this) = { }" );

    //  Add copy/move construction and assignment
    (copy value_set: std::string = "")
    {
        for  alternatives
        do   (a) {
            value_set += "        if that.is_(a.name)$() { set_(a.name)$( that.(a.name)$() ); }\n";
        }
        value_set += "    }\n";

        t.add_member( "    operator=: (out this, that) = {\n"
                      "        _storage = ();\n"
                      "        _discriminator = -1;\n"
                      + value_set
                    );
        t.add_member( "    operator=: (inout this, that) = {\n"
                      "        _storage = _;\n"
                      "        _discriminator = _;\n"
                      + value_set
                    );
    }
}


//-----------------------------------------------------------------------
//
//  print - output a pretty-printed visualization of t
//
print: (t: meta::type_declaration) =
{
    std::cout << t.print() << "\n";
}


//-----------------------------------------------------------------------
//
//  noisy - make each function print its name and signature,
//          so the programmer can see what's called
//
noisy: (t: meta::type_declaration) =
{
    for t.get_members()
    do  (m)
    if  m.is_function()
        && !m.has_name("operator=")
    {
        mf := m.as_function();
        if mf.has_compound_body() {
            body := mf.get_compound_body();
            body.add_statement( "    std::cout << \"(mf.get_signature())$\\n\";" );
            _ = body;
        }
    }
}


//-----------------------------------------------------------------------
//
//  autodiff - stub
//
autodiff: (inout t: meta::type_declaration) =
{
    for t.get_members()
    do  (m)
    if  m.is_function()
    {
        mf := m.as_function();

        diff: std::string = "    (mf.name())$_diff: (";

        //  1. Generate the modified signature
        //  a) Parameters

        for mf.get_parameters() do (param) {
            diff += "(param.name())$ : (param.type())$, ";
            diff += "(param.name())$_d : (param.type())$, ";
        }

        diff += ") -> (";

        //  b) Returns

        for mf.get_returns() do (param) {
            diff += "(param.name())$ : (param.type())$ = 1, ";
            diff += "(param.name())$_d : (param.type())$ = 1, ";
        }

        diff += ") = {";

        //  Generate the body

        if !mf.has_compound_body() {
            m.error( "temporary alpha limitation: a differentiable function must have a {}-enclosed body" );
            return;
        }

        next_statement: for mf.get_compound_body().get_statements() do (stmt)
        {
            if stmt.is_expression_statement()
            {
                expr := stmt.as_expression_statement().get_expression();
                if expr.is_simple_assignment()
                {
                    //  If this is not an assignment to a parameter or return object, skip it
                    lhs_rhs := expr.get_lhs_rhs_if_simple_assignment();
                    lhs     := lhs_rhs.lhs.get_first_token_ignoring_this();
                    if !mf.has_parameter_or_return_named(lhs)
                    {
                        continue next_statement;
                    }

                    //  We will need to split this assignment into two lines
                    //  and build them up as we traverse the subexpressions
                    line1: std::string = "(lhs)$_d = ";    // for the _d variable
                    line2: std::string = "(lhs)$ = ";      // for the original variable

                    assignment := expr.get_assignment_expression();

                    //  Cpp2 doesn't allow chained assignment, so rhs must be a single logical_or_expression
                    assignment_terms := assignment.get_terms();
                    if assignment_terms.ssize() != 2 {
                        m.error( "an assignment must have exactly one right-hand side expression" );
                    }

                    //  Now we handle sequences of binary "expr1 @ expr2 @ ..." where each
                    //  @ is one of a list of operators at the same grammar precedence

                    //  Handle binary ||
                    logical_or_terms := assignment_terms[1].get_term().get_terms();
                    if logical_or_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found as a grammatical
                        //  identifier (this won't compile as Cpp1, but it will
                        //  be visible via @print for development/debugging)
                        diff += "found_logical_or_with_____";
                        count := 0;
                        for logical_or_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary &&
                    if logical_or_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one logical or term here" );
                    }
                    logical_and_terms := logical_or_terms.front().get_term().get_terms();
                    if logical_and_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_logical_and_with_____";
                        count := 0;
                        for logical_and_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary |
                    if logical_and_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one logical and term here" );
                    }
                    bit_or_terms := logical_and_terms.front().get_term().get_terms();
                    if bit_or_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_bit_or_with_____";
                        count := 0;
                        for bit_or_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary ^
                    if bit_or_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one bit or term here" );
                    }
                    bit_xor_terms := bit_or_terms.front().get_term().get_terms();
                    if bit_xor_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_bit_xor_with_____";
                        count := 0;
                        for bit_xor_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary &
                    if bit_xor_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one bit xor term here" );
                    }
                    bit_and_terms := bit_xor_terms.front().get_term().get_terms();
                    if bit_and_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_bit_and_with_____";
                        count := 0;
                        for bit_and_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary == and !=
                    if bit_and_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one bit and term here" );
                    }
                    equality_terms := bit_and_terms.front().get_term().get_terms();
                    if equality_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_equality_with_____";
                        count := 0;
                        for equality_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary < > <= >=
                    if equality_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one equality term here" );
                    }
                    relational_terms := equality_terms.front().get_term().get_terms();
                    if relational_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_relational_with_____";
                        count := 0;
                        for relational_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary <=>
                    if relational_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one relational term here" );
                    }
                    compare_terms := relational_terms.front().get_term().get_terms();
                    if compare_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_compare_with_____";
                        count := 0;
                        for compare_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary << and >>
                    if compare_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one compare term here" );
                    }
                    shift_terms := compare_terms.front().get_term().get_terms();
                    if shift_terms.ssize() > 1
                    {
                        //  TODO: Do whatever is appropriate here...
                        //  For now, just list out what we found (visible via @print)...
                        diff += "found_shift_with_____";
                        count := 0;
                        for shift_terms do (term) {
                            if count++ > 1 {
                                diff += term.get_op() + "___";
                            }
                            diff += term.get_term().to_string() + "___";
                        }
                        diff += ";";

                        continue next_statement;
                    }

                    //  Handle binary + and -
                    if shift_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one shift term here" );
                    }
                    additive_terms := shift_terms.front().get_term().get_terms();
                    if additive_terms.ssize() > 1
                    {
                        first := true;
                        for additive_terms do (term) {
                            if !first {
                                op := term.get_op().to_string();
                                line1 += " (op)$ ";
                                line2 += " (op)$ ";
                            }

                            var := term.get_term().to_string();
                            if !mf.has_parameter_or_return_named(var) {
                                m.error( "temporary alpha limitation: the addition's left-hand side '(var)$' must be a parameter or return name");
                            }
                            line1 += "(var)$_d";
                            line2 += "(var)$";

                            first = false;
                        }

                        line1 += ";";
                        line2 += ";";

                        diff += line1 + line2;

                        continue next_statement;
                    }

                    //  Handle binary * / %
                    if additive_terms.ssize() != 1 {
                        m.error( "ICE: there should be exactly one additive term here" );
                    }
                    multiplicative_terms := additive_terms.front().get_term().get_terms();
                    if multiplicative_terms.ssize() > 1
                    {
                        if multiplicative_terms.ssize() != 2
                        {
                            m.error( "temporary alpha limitation: does not support chains of * and /");
                        }

                        lhs := multiplicative_terms[0].get_term().to_string();
                        if !mf.has_parameter_or_return_named(lhs) {
                            m.error( "temporary alpha limitation: the addition's left-hand side '(lhs)$' must be a parameter or return name");
                        }

                        rhs := multiplicative_terms[1].get_term().to_string();
                        if !mf.has_parameter_or_return_named(rhs) {
                            m.error( "temporary alpha limitation: the addition's right-hand side '(rhs)$' must be a parameter or return name");
                        }

                        op := multiplicative_terms[1].get_op().to_string();
                        if "*" == op {
                            line1 += "(lhs)$ * (rhs)$_d + (rhs)$ * (lhs)$_d;";
                            line2 += "(lhs)$ * (rhs)$;";
                        }
                        else if "/" == op {
                            line1 += "(lhs)$_d / (rhs)$ - (lhs)$ * (rhs)$_d / ((rhs)$ * (rhs)$);";
                            line2 += "(lhs)$ / (rhs)$;";
                        }
                        else {
                            m.error( "unkown multiplicative operator '(op)$'");
                        }

                        diff += line1 + line2;

                        continue next_statement;
                    }

                }
            }
        }

        diff += "}";

        t.add_member( diff );
    }
}


//-----------------------------------------------------------------------
//
//  regex - creates regular expressions from members
//
//  Each member that starts with `regex` is replaced by a regular expression
//  of the initializer string. E.g.:
//  ```
//    regex := "ab";
//  ```
//  is replaced with
//  ```
//    regex := ::cpp2::regex::regular_expression<...>;
//  ```
//
error_func: type == std::function< (x: std::string) -> void >;

//  Possible modifiers for a regular expression.
//
expression_flags: @flag_enum<u8> type = 
{
    case_insensitive;             // mod: i
    multiple_lines;               // mod: m
    single_line;                  // mod: s
    no_group_captures;            // mod: n
    perl_code_syntax;             // mod: x
    perl_code_syntax_in_classes;  // mod: xx
}


//  Tokens for regular expressions.
//

// Basic class for a regex token.
//
regex_token: @polymorphic_base type = 
{
    public string_rep: std::string;

    operator=:(out this, str: std::string) = {
        string_rep = str;
    }

    operator=:(out this) = {
        string_rep = "";
    }

    //parse: (inout ctx: parse_context) -> token_ptr;
    generate_code: (virtual this, inout _: generation_context);        // Generate the matching code.
    reverse:       (virtual this) -> std::shared_ptr<regex_token>;     // Create a reverse token for look behind expressions.

    add_groups: (virtual this, inout _: std::set<int>) = {}            // Adds all group indices to the set.
    to_string: (this) -> std::string         = { return string_rep; }  // Create a string representation.
    set_string: (inout this, s: std::string) = { string_rep = s; }     // Set the string representation.
}

token_ptr : type == std::shared_ptr<regex_token>;
token_vec: type == std::vector<token_ptr>;


//  Adds a check in code generation.
//
regex_token_check: @polymorphic_base type = 
{
    this: regex_token;

    check: std::string;

    operator=:(out this, str: std::string, check_: std::string) = {
        regex_token = (str);
        check = check_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check(check + "(" + ctx..match_parameters() + ")");
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_check>(this.to_string(), this.check);
}


//  Adds code in code generation.
//
regex_token_code: @polymorphic_base type = 
{
    this: regex_token;

    code: std::string;

    operator=:(out this, str: std::string, code_: std::string) = {
        regex_token = (str);
        code = code_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add(code);
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_code>(this.to_string(), this.code);
}


//  Token that does not influence the matching. E.g. comment.
//
regex_token_empty: @polymorphic_base type = 
{
    this: regex_token;

    operator=:(out this, str: std::string) = {
        regex_token = (str);
    }

    generate_code: (override this, inout _: generation_context) = {
        // Nothing.
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_empty>(this.to_string());
}


//  Represents a list of regex tokens as one token.
//
regex_token_list: @polymorphic_base type = 
{
    this: regex_token;

    public tokens: token_vec;

    operator=:(out this, t: token_vec) = {
        regex_token = (gen_string(t));
        tokens = t;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        for tokens do (token) {
            token*..generate_code(ctx);
        }
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        for tokens do (token) {
            token*..add_groups(groups);
        }
    }

    gen_string: (vec: token_vec) -> std::string = {
        r : std::string = "";
        for vec do (token) {
            r += token*..to_string();
        }
        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(tokens..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < tokens.ssize() next (i += 1) {
            reverse_vec[s - 1 -i] = tokens[i]*.reverse();
        }
        return shared.new<regex_token_list>(reverse_vec);
    }
}


//
//  Parse and generation context.
//

//  State of the current capturing group. See '(<pattern>)'
//
parse_context_group_state: @struct<noforward> type = 
{    
    cur_match_list:        token_vec = ();         // Current list of matchers.
    alternate_match_lists: token_vec = ();         // List of alternate matcher lists. E.g. ab|cd|xy.
    modifiers :            expression_flags = ();  // Current modifiers for the group/regular expression.

    //  Start a new alternative.
    next_alternative: (inout this) = {
        new_list: token_vec = ();
        std::swap(new_list, cur_match_list);
        post_process_list(new_list);
        _ = alternate_match_lists..insert(alternate_match_lists..end(), shared.new<regex_token_list>(new_list));
    }

    //  Swap this state with the other one. NOLINTNEXTLINE(performance-noexcept-swap)
    swap: (inout this, inout t: parse_context_group_state) = { // NOLINT(performance-noexcept-swap)
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        std::swap(modifiers, t.modifiers);
    }

    //  Convert this state into a regex token.
    get_as_token: (inout this) -> token_ptr = {
        if alternate_match_lists..empty() {
            post_process_list(cur_match_list);
            return shared.new<regex_token_list>(cur_match_list);
        }
        else {
            next_alternative();
            return shared.new<alternative_token_gen>(alternate_match_lists);
        }
    }

    //  Add a token to the current matcher list.
    add: (inout this, token: token_ptr) = {
        cur_match_list..push_back(token);
    }

    //  True if current matcher list is empty.
    empty: (this) -> bool = cur_match_list..empty();

    
    //  Apply optimizations to the matcher list.
    post_process_list: (inout list: token_vec) = {
        // Merge all characters
        merge_pos := list..begin();
        while merge_pos != list..end() next (merge_pos++) {
            if merge_pos** is char_token {
                combine_pos := merge_pos + 1;
                while combine_pos != list..end() && combine_pos** is char_token { // The erase advances combine_pos
                    (merge_pos** as char_token)..append(combine_pos** as char_token);
                    combine_pos = list..erase(combine_pos);
                }
            }
        }
    }
}


//  State for the branch reset. Takes care of the group numbering. See '(|<pattern>)'.
//
parse_context_branch_reset_state: @struct<noforward> type = 
{
    is_active : bool = false; // If we have a branch reset group.
    cur_group : int  = 1;     // Next group identifier. 0 == global capture group.
    max_group : int  = 1;     // Maximum group identifier generated.
    from      : int  = 1;     // Starting identifier on new alternative branch.

    //  Next group identifier.
    next: (inout this) -> int = {
        g := cur_group;
        cur_group += 1;
        max_group = max(max_group, cur_group);

        return g;
    }

    //  Set next group identifier.
    set_next: (inout this, g: int) = {
        cur_group = g;
        max_group = max(max_group, g);
    }

    //  Start a new alternative branch.
    next_alternative: (inout this) = {
        if is_active {
            cur_group = from;
        }
    }

    //  Initialize for a branch reset group.
    set_active_reset: (inout this, restart: int) = {
        is_active = true;
        cur_group = restart;
        from      = restart;
        max_group = restart;
    }
}


//  Context during parsing of the regular expressions.
// 
//  Keeps track of the distributed group identifiers, current parsed group and branch resets.
//
parse_context: type = 
{
    regex: std::string_view;   // Regular expression string.
    pos:   size_t = 0;         // Current parsing position.
    root:  token_ptr;          // Token representing the regular expression.

    public is_start_match: bool = false;  // If the regex contains \G at the beginning.

    cur_group_state:        parse_context_group_state = ();
    cur_branch_reset_state: parse_context_branch_reset_state = ();

    
    public named_groups:  std::map<std::string, int> = ();

    error_out: error_func; // TODO: Declaring std::function<void(std::string)> fails for cpp2.
    has_error: bool      = false;

    operator=:(out this, r: std::string_view, e) = {
        regex = r;
        root = shared.new<regex_token_empty>("");
        error_out = e;
    }

    //  State management functions
    //

    //  Returned group state needs to be stored and provided in `end_group`.
    start_group: (inout this) -> parse_context_group_state = 
    {
        old_state: parse_context_group_state = ();
        old_state..swap(cur_group_state);
        cur_group_state.modifiers = old_state.modifiers;

        return old_state;
    }

    //  `old_state` argument needs to be from start group.
    end_group: (inout this, old_state: parse_context_group_state) -> token_ptr =
    {
        inner := cur_group_state..get_as_token();
        cur_group_state = old_state;
        return inner;
    }

    get_modifiers: (this) -> expression_flags = {
        return cur_group_state.modifiers;
    }

    set_modifiers: (inout this, mod: expression_flags) = {
        cur_group_state.modifiers = mod;
    }

    //  Branch reset management functions
    //

    branch_reset_new_state: (inout this) -> parse_context_branch_reset_state = 
    {
        old_state: parse_context_branch_reset_state = ();
        std::swap(old_state, cur_branch_reset_state);

        cur_branch_reset_state..set_active_reset(old_state.cur_group);
        return old_state;
    }

    branch_reset_restore_state: (inout this, old_state: parse_context_branch_reset_state) = 
    {
        max_group := cur_branch_reset_state.max_group;
        cur_branch_reset_state = old_state;
        cur_branch_reset_state..set_next(max_group);
    }

    next_alternative: (inout this) = 
    {
        cur_group_state..next_alternative();
        cur_branch_reset_state..next_alternative();
    }

    //  Regex token management
    //
    add_token: (inout this, token: token_ptr) = {
        cur_group_state..add(token);
    }

    has_token: (this) -> bool = {
        return !cur_group_state..empty();
    }

    pop_token: (inout this) -> token_ptr = 
    {
        r : token_ptr = nullptr;
        if has_token() {
            r = cur_group_state.cur_match_list..back();
            cur_group_state.cur_match_list..pop_back();
        }

        return r;
    }

    get_as_token: (inout this) -> token_ptr = {
        return root;
    }

    //  Group management
    //
    get_cur_group: (this) -> int = {
        return cur_branch_reset_state.cur_group;
    }

    next_group: (inout this) -> int = {
        return cur_branch_reset_state..next();
    }

    set_named_group: (inout this, name: std::string, id: int) = 
    {
        if !named_groups..contains(name) { // Redefinition of group name is not an error. The left most one is retained.
            named_groups[name] = id;
        }
    }

    get_named_group: (this, name: std::string) -> int = 
    {
        iter := named_groups..find(name);
        if iter == named_groups..end() {
             return -1;
        }
        else {
            return iter*.second;
        }
    }
    
    //  Position management functions
    //
    current: (this) -> char = { return regex[pos]; }

    //  Get the next token in the regex, skipping spaces according to the parameters. See `x` and `xx` modifiers.
    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t = 
    {
        perl_syntax := false;
        if !no_skip {
            if in_class {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax) && get_modifiers()..has(expression_flags::perl_code_syntax_in_classes);
            }
            else {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax);
            }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex..size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex..find('\n', cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex..size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        //  Check for end of file.
        if cur > regex..size() {
            cur = regex..size();
        }
        return cur;
    }

    //  Return true if next token is available.
    private next_impl: (inout this, in_class: bool, no_skip: bool) -> bool = 
    {
        pos = get_next_position(in_class, no_skip);
        if pos != regex..size() {
            return true;
        }
        else {
            return false;
        }
    }

    next         : (inout this) = next_impl(false, false);
    next_in_class: (inout this) = next_impl( true, false);
    next_no_skip : (inout this) = next_impl(false,  true);

    next_n: (inout this, n: int) -> bool = {
        r := true;
        cur := 0;
        while r && cur < n next (r = next()) {
            cur += 1;
        }
        return r;
    }

    has_next: (this) -> bool = { return pos < regex..size(); }

    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool = 
    {
        end:= pos; // NOLINT(clang-analyzer-deadcode.DeadStores)
        if any {
            end = regex..find_first_of(e, pos);
        }
        else {
            end = regex..find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex..substr(pos, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        = grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               = grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) = grab_until_impl(e, out r, true);

    grab_n: (inout this, in n: int, out r: std::string) -> bool = 
    {
        if pos + n as size_t <= regex..size() {
            r = regex..substr(pos, n as size_t);
            pos += (n as size_t) - 1;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string = 
    {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex..find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string::npos {
            r = regex..substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex..substr(start);
            pos = regex..size() - 1;
        }
        return r;
    }

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex..size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek         : (in this) = peek_impl(false);
    peek_in_class: (in this) = peek_impl( true);


    //  Parsing functions
    //
    parser_group_modifiers: (inout this, change_str: std::string, inout parser_modifiers: expression_flags) -> bool = 
    {
        is_negative := false;
        is_reset    := false;

        apply := :(flag: expression_flags) = {
            if is_negative&$* {
                parser_modifiers&$*..clear(flag);
            }
            else {
                parser_modifiers&$*..set(flag);
            }
        };

        iter := change_str..begin();
        while iter != change_str..end() next (iter++) 
        {
            cur := iter*;
            if cur == '^' {
                is_reset = true;
                parser_modifiers = expression_flags::none;
            }
            else if cur == '-' {
                if is_reset { _= error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else if cur == 'n' { apply(expression_flags::no_group_captures); }
            else if cur == 'x' {
                if (iter + 1) == change_str..end() || (iter + 1)* != 'x' {
                    // x modifier
                    apply(expression_flags::perl_code_syntax);

                    // Just x unsets xx and remove x also removes xx
                    parser_modifiers..clear(expression_flags::perl_code_syntax_in_classes);
                }
                else { // xx modifier
                    // xx also sets or unsets x
                    apply(expression_flags::perl_code_syntax);
                    apply(expression_flags::perl_code_syntax_in_classes);

                    iter++; // Skip the second x
                }
            }
            else {
                _= error("Unknown modifier: (cur)$"); return false;
            }
        }

        return true;
    }

    parse_until: (inout this, term: char) -> bool = {
        cur_token: token_ptr = ();

        while valid() next _ = next()
        {
            if term == current() { break; }

            cur_token = nullptr;

            if !cur_token && valid() { cur_token = alternative_token::parse(this); }
            if !cur_token && valid() { cur_token = any_token::parse(this); }
            if !cur_token && valid() { cur_token = class_token::parse(this); }
            if !cur_token && valid() { cur_token = escape_token_parse(this); }
            if !cur_token && valid() { cur_token = global_group_reset_token_parse(this); }
            if !cur_token && valid() { cur_token = group_ref_token::parse(this); }
            if !cur_token && valid() { cur_token = group_token::parse(this); }
            if !cur_token && valid() { cur_token = hexadecimal_token_parse(this); }
            if !cur_token && valid() { cur_token = line_end_token_parse(this); }
            if !cur_token && valid() { cur_token = line_start_token_parse(this); }
            if !cur_token && valid() { cur_token = named_class_token_parse(this); }
            if !cur_token && valid() { cur_token = octal_token_parse(this); }
            if !cur_token && valid() { cur_token = range_token::parse(this); }
            if !cur_token && valid() { cur_token = special_range_token::parse(this); }
            if !cur_token && valid() { cur_token = start_match_parse(this); }
            if !cur_token && valid() { cur_token = word_boundary_token_parse(this); }

            // Everything else is matched as it is.
            if !cur_token && valid() { cur_token = char_token::parse(this); }

            if cur_token && valid() {
                add_token(cur_token);
            } else {
                return false;
            }
        }

        return true;
    }

    parse: (inout this, modifiers: std::string) -> bool = 
    {

        flags : expression_flags = ();
        if !parser_group_modifiers(modifiers, flags) { return false; }
        set_modifiers(flags);

        r := parse_until('\0');
        if r {
            root = cur_group_state..get_as_token();
        }

        return r;
    }

    //  Misc functions

    get_pos:   (this)                             = pos;
    get_range: (this, start: size_t, end: size_t) = std::string(regex..substr(start, end - start + 1));
    valid:     (this) -> bool                     = { return has_next() && !has_error; }

    error: (inout this, err: std::string) -> token_ptr = {
        has_error = true;
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (err)$");
        return nullptr;
    }
}


//  Context for one function generation. Generation of functions can be interleaved,
//  therefore we buffer the code for one function here.
//
generation_function_context: @struct<noforward> type = {
    code: std::string = "";
    tabs: std::string = "";

    add_tabs: (inout this, c: int) = {
        i: int = 0;
        while i < c next i += 1 {
            tabs += "  ";
        }
    }

    remove_tabs: (inout this, c: int) = {
        tabs = tabs..substr(0, (c as size_t) * 2);
    }
}


//  Context for generating the state machine.
generation_context: type = 
{
    gen_stack: std::vector<generation_function_context> = (1); // Element 0 contains all the code.

    matcher_func: int         = 0;
    reset_func:   int         = 0;
    temp_name:    int         = 0;
    entry_func:   std::string = "";

    //  Generation helpers
    //
    match_parameters: (this) -> std::string = { return "r.pos, ctx"; }

    //  Code generation.

    //  Add code line.
    add: (inout this, s: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$(s)$\n";
    }

    //  Add check for token. The check needs to be a function call that returns a boolean.
    add_check: (inout this, check: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$if !cpp2::regex::(check)$ { r.matched = false; break; }\n";
    }

    //  Add a stateful check. The check needs to return a `match_return`.
    add_statefull: (inout this, next_func: std::string, check: std::string) = 
    {
        end_func_statefull(check);

        name := next_func..substr(0, next_func..size() - 2);
        start_func_named(name);
    }

    protected start_func_named: (inout this, name: std::string) = 
    {
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): <Iter> (this, cur: Iter, forward ctx, other) -> cpp2::regex::match_return<Iter> = {\n";
        cur*.code += "(cur*.tabs)$    r := ctx..pass(cur);\n";
        cur*.code += "(cur*.tabs)$    do {\n";
        cur*..add_tabs(3);
    }

    protected start_func: (inout this) -> std::string = 
    {
        name := gen_func_name();
        start_func_named(name);
        return name + "()";
    }

    protected end_func_statefull: (inout this, s: std::string) = 
    {
        cur := get_current();
        cur*..remove_tabs(3);
        cur*.code += "\n";
        cur*.code += "(cur*.tabs)$    } while false;\n";
        cur*.code += "(cur*.tabs)$    if r.matched {\n";
        cur*.code += "(cur*.tabs)$      r = (s)$;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    else {\n";
        cur*.code += "(cur*.tabs)$      r.pos = ctx.end;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    _ = ctx;\n";
        cur*.code += "(cur*.tabs)$    return r;\n";
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();
    }

    //  Generate the function for a token.
    generate_func: (inout this, token: token_ptr) -> std::string = 
    {
        name := start_func();
        token*..generate_code(this);
        end_func_statefull("other((match_parameters())$)");

        return name;
    }

    //  Generate the reset for a list of group identifiers.
    generate_reset: (inout this, groups: std::set<int>) -> std::string = 
    {
        if groups..empty() {
            return "cpp2::regex::no_reset()";
        }

        name := gen_reset_func_name();
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, inout ctx) = {\n";
        for groups do (g) {
            cur*.code += "(cur*.tabs)$  ctx..set_group_invalid((g)$);\n";
        }
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();

        return name + "()";
    }

    //  Name generation
    //
    protected gen_func_name: (inout this) -> std::string = {
        cur_id : = matcher_func;
        matcher_func += 1;
        return "func_(cur_id)$";
    }

    next_func_name: (inout this) -> std::string = {
        return gen_func_name() + "()";
    }

    protected gen_reset_func_name: (inout this) -> std::string = {
        cur_id : = reset_func;
        reset_func += 1;
        return "reset_(cur_id)$";
    }

    gen_temp: (inout this) -> std::string = {
        cur_id := temp_name;
        temp_name += 1;
        return "tmp_(cur_id)$";
    }

    //  Context management
    //
    new_context: (inout this) -> *generation_function_context = {
        gen_stack..push_back(generation_function_context());
        cur := get_current();
        cur*.tabs = "    ";

        return cur;
    }

    finish_context: (inout this) = {
        cur := get_current();
        base := get_base();
        base*.code += cur*.code;

        gen_stack..pop_back();
    }

    //  Misc functions
    //
    private get_current: (inout this) -> *generation_function_context = {
        return gen_stack..back()&;
    }

    private get_base: (inout this) -> *generation_function_context = {
        return gen_stack[0]&;
    }

    get_entry_func: (this) -> std::string = {
        return entry_func;
    }

    create_named_group_lookup: (this, named_groups: std::map<std::string, int>) -> std::string = 
    {
        res: std::string = "get_named_group_index: (name) -> int = {\n";

        //  Generate if selection.
        sep: std::string = "";
        for named_groups do (cur) {
            res += "(sep)$if name == \"(cur.first)$\" { return (cur.second)$; }";
            sep = "else ";
        }

        //  Generate else branch or return if list is empty.
        if named_groups..empty() {
            res += "  _ = name;\n";
            res += "  return -1;\n";
        }
        else {
            res += "  else { return -1; }\n";
        }
        res += "}\n";
        return res;
    }


    //  Run the generation for the token.
    run: (inout this, token: token_ptr) -> std::string = {
        entry_func = generate_func(token);

        return get_base()*.code;
    }
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen.
//
alternative_token: @polymorphic_base type = 
{
    this: regex_token_empty = ("");  // No code gen here. alternative_token_gen is created in the parse_context

    operator=:(out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx..current() != '|' { return nullptr; }

        if !ctx..has_token() { return ctx..error("Alternative with no content."); }
        ctx..next_alternative();
        return shared.new<alternative_token>();
    }
}

alternative_token_gen: @polymorphic_base type = 
{
    this: regex_token;

    alternatives: token_vec;

    operator=: (out this, a: token_vec) = {
        regex_token = gen_string(a);
        alternatives = a;
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        functions: std::string = "";

        for alternatives do (cur) {
            groups: std::set<int> = ();
            cur*..add_groups(groups);

            functions += ", " + ctx..generate_func(cur);
            functions += ", " + ctx..generate_reset(groups);
        }

        next_name := ctx..next_func_name();

        ctx..add_statefull(next_name, "cpp2::regex::alternative_token_matcher<char>::match((ctx..match_parameters())$, other, (next_name)$ (functions)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = 
    {
        for alternatives do (cur) {
            cur*..add_groups(groups);
        }
    }

    gen_string: (a: token_vec) -> std::string = 
    {
        r: std::string = "";
        sep: std::string = "";

        for a do (cur) {
            r += sep + cur*..to_string();
            sep = "|";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(alternatives..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < s next (i += 1) {
            reverse_vec[i] = alternatives[i]*.reverse(); // We only reverse the alternatives, not the order in which they are checked.
        }
        return shared.new<alternative_token_gen>(reverse_vec);
    }
}


//  Regex syntax: .
//
any_token: @polymorphic_base type = 
{
    this: regex_token_check = (".");

    operator=:(out this, single_line: bool) = {
        regex_token_check = (".", "any_token_matcher<char, (single_line)$>");
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        if '.' != ctx..current() { return nullptr;}

        return shared.new<any_token>(ctx..get_modifiers()..has(expression_flags::single_line));
    }
}

//  Regex syntax: (?><matcher>)  Example: a(?>bc|c)c
//
atomic_group_token: @polymorphic_base type =
{
    this                 : regex_token = ("");

    public  inner_token : token_ptr   = nullptr;

    operator=: (out this) = {}

    reverse: (override this) -> token_ptr = {
        r := shared.new<atomic_group_token>();
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        inner_name := ctx..generate_func(inner_token);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::atomic_group_matcher<char>((ctx..match_parameters())$, (inner_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}

//  Regex syntax: a
//
char_token: @polymorphic_base type = 
{
    this: regex_token;

    token      : std::string;
    ignore_case: bool;

    operator=: (out this, t: char, ignore_case_: bool) = {
        regex_token = (std::string(1, t));
        token = t;
        ignore_case = ignore_case_;
    }

    operator=: (out this, t: std::string, ignore_case_: bool) = {
        regex_token = (t);
        token = t;
        ignore_case = ignore_case_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx..current(), ctx..get_modifiers()..has(expression_flags::case_insensitive));
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        if ignore_case {
            upper: std::string = token;
            lower: std::string = token;

            (copy i: size_t = 0) while i < token..size() next i += 1 {
                lower[i] = string_util::safe_tolower(token[i]);
                upper[i] = string_util::safe_toupper(token[i]);
            }

            if upper != lower {
                gen_case_insensitive(lower, upper, ctx);
            }
            else {
                gen_case_sensitive(ctx);
            }
        }
        else {
            gen_case_sensitive(ctx);
        }
    }

    gen_case_insensitive: (this, lower: std::string, upper: std::string, inout ctx: generation_context) = 
    {
        name: std::string = "str_(ctx..gen_temp())$";
        lower_name: std::string = "lower_(name)$";
        upper_name: std::string = "upper_(name)$";
        size := token..size();
        ctx..add("(lower_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(lower))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("(upper_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(upper))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if !((lower_name)$[i] == r.pos[i] || (upper_name)$[i] == r.pos[i]) { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    gen_case_sensitive: (this, inout ctx: generation_context) = 
    {
        name: std::string = "str_(ctx..gen_temp())$";
        size := token..size();
        ctx..add("(name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(token))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if (name)$[i] != r.pos[i] { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    add_escapes: (this, copy str: std::string) -> std::string = 
    {
        str = string_util::replace_all(str, "\\", "\\\\");
        str = string_util::replace_all(str, "\a", "\\a");
        str = string_util::replace_all(str, "\f", "\\f");
        str = string_util::replace_all(str, "\x1b", "\" \"\\x1b\" \""); // Generate a separated string. This prevents
                                                                        // situations like `\x1bblub` from generating
                                                                        // wrong hex characters.
        str = string_util::replace_all(str, "\n", "\\n");
        str = string_util::replace_all(str, "\r", "\\r");
        str = string_util::replace_all(str, "\t", "\\t");

        return str;
    }

    reverse: (override this) -> token_ptr = {
        reverse_str: std::string = token;
        std::reverse(reverse_str..begin(), reverse_str..end());
        return shared.new<char_token>(reverse_str, ignore_case);
    }

    append: (inout this, that) = {
        this.token += that.token;
        this.string_rep += that.string_rep;
    }
}


//  Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_token: @polymorphic_base type = 
{
    this            : regex_token = ();

    negate          : bool;
    case_insensitive: bool;
    class_str       : std::string;

    operator=: (out this, negate_: bool, case_insensitive_: bool, class_str_: std::string, str: std::string) = 
    {
        regex_token = str;
        negate = negate_;
        case_insensitive = case_insensitive_;
        class_str = class_str_;
    }

    //  TODO: Rework class generation: Generate check functions for classes.
    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '[' { return nullptr; }

        start_pos := ctx..get_pos();

        supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                       "lower", "print", "punct", "space", "upper", "word", "xdigit");

        classes: std::vector<std::string> = ();

        //  First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        is_negate := false;
        first     := true;
        range     := false;
        while ctx..next_in_class() && (ctx..current() != ']' || first) 
        {
            if ctx..current() == '^' 
            {
                is_negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }

            if ctx..current() == '[' && ctx..peek_in_class() == ':' 
            {
                //  We have a character class.
                _ = ctx..next_n(2);  // Skip [:

                name: std::string = "";
                if !ctx..grab_until(":]", out name) { return ctx..error("Could not find end of character class."); }
                if supported_classes..end() == std::find(supported_classes..begin(), supported_classes..end(), name) {
                    return ctx..error("Unsupported character class. Supported ones are: (string_util::join(supported_classes))$");
                }

                classes..push_back("[:(name)$:]");

                _ = ctx..next(); // Skip ':' pointing to the ending ']'.
            }
            else if ctx..current() == '\\' 
            {
                if ctx..next_no_skip()  && (ctx..current() != ']') 
                {
                    if  ' ' == ctx..current() 
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax) 
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax_in_classes) 
                    {
                        classes..push_back(std::string(1, ctx..current()));
                    }
                    else {
                        name := "";
                        if      'd' == ctx..current() { name = "short_digits"; }
                        else if 'D' == ctx..current() { name = "short_not_digits"; }
                        else if 'h' == ctx..current() { name = "short_hor_space"; }
                        else if 'H' == ctx..current() { name = "short_not_hor_space"; }
                        else if 's' == ctx..current() { name = "short_space"; }
                        else if 'S' == ctx..current() { name = "short_not_space"; }
                        else if 'v' == ctx..current() { name = "short_ver_space"; }
                        else if 'V' == ctx..current() { name = "short_not_ver_space"; }
                        else if 'w' == ctx..current() { name = "short_word"; }
                        else if 'W' == ctx..current() { name = "short_not_word"; }
                        else {
                            return ctx..error("Unknown group escape.");
                        }
                        classes..push_back("[:(name)$:]");
                    }
                } else {
                    return ctx..error("Escape without a following character.");
                }
            }
            else if ctx..current() == '-' 
            {
                if first { // Literal if first entry.
                    classes..push_back("(ctx..current())$");
                } else {
                    range = true;
                }
            }
            else 
            {
                if range { // Modify last element to be a range.
                    classes..back() += "-(ctx..current())$";
                    range = false;
                }
                else {
                    classes..push_back("(ctx..current())$");
                }
            }

            first = false;
        }

        if ctx..current() != ']' {
            return ctx..error("Error end of character class definition before terminating ']'.");
        }
        end_pos := ctx..get_pos();

        if range { // If '-' is last entry treat it as a literal char.
            classes..push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur) 
        {
            if cur..starts_with("[:") {
                name := cur..substr(2, cur..size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur..size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner      := string_util::join(classes);
        string_rep := ctx..get_range(start_pos, end_pos);
        return shared.new<class_token>(
            is_negate, 
            ctx..get_modifiers()..has(expression_flags::case_insensitive), 
            inner, 
            string_rep
            );
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<class_token>(
            negate,
            case_insensitive,
            class_str,
            to_string()
            );
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        ctx..add_check("class_token_matcher<char, (negate)$, (case_insensitive)$, (class_str)$>::match((ctx..match_parameters())$)");
    }

    private create_matcher: (name: std::string, template_arguments: std::string) -> std::string = 
    {
        sep := ", ";
        if template_arguments..empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }
}


//  Regex syntax: \a or \n or \[
//
escape_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }


    if std::string::npos == std::string("afenrt^.[]()*{}?+|\\")..find(ctx..peek()) {
        return nullptr;
    }

    _ = ctx..next(); // Skip escape

    if std::string::npos != std::string("afenrt\\")..find(ctx..current()) 
    {
        // Escape of string special char
        t : char = '\0';
        if      'a' == ctx..current() { t = '\a'; }
        else if 'f' == ctx..current() { t = '\f'; }
        else if 'e' == ctx..current() { t = '\x1b'; }
        else if 'n' == ctx..current() { t = '\n'; }
        else if 'r' == ctx..current() { t = '\r'; }
        else if 't' == ctx..current() { t = '\t'; }
        else if '\\' == ctx..current() { t = '\\'; }
        else { return ctx..error("Internal: missing switch case for special escape."); }

        r: = shared.new<char_token>(t, false);
        r*..set_string("\\(ctx..current())$");
        return r;
    } 
    else 
    {
        // Escape of regex special char
        r := shared.new<char_token>(ctx..current(), false);
        r*..set_string("\\(ctx..current())$");
        return r;
    }

}


//  Regex syntax: \K Example: ab\Kcd
//
global_group_reset_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'K') { return nullptr; }

    _ = ctx..next(); // Skip escape.
    return shared.new<regex_token_code>("\\K", "ctx..set_group_start(0, r.pos);");
}


//  Regex syntax: \<number>  Example: \1
//                \g{name_or_number}
//                \k{name_or_number}
//                \k<name_or_number>
//                \k'name_or_number'
//
group_ref_token: @polymorphic_base type = 
{
    this            : regex_token = ();

    id              : int;
    case_insensitive: bool;
    reverse_eval    : bool;

    operator=:(out this, id_: int, case_insensitive_: bool, reverse_: bool, str: std::string) =
    {
        regex_token      = str;
        id               = id_;
        case_insensitive = case_insensitive_;
        reverse_eval     = reverse_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '\\' { return nullptr; }

        str : std::string = "\\";
        group : std::string = "";

        if '0' <= ctx..peek() <= '9' 
        {
            _ = ctx..next(); // Skip escape
            group = ctx..grab_number();

            if group..size() >= 3 as size_t 
            {
                // Octal syntax (\000) not a group ref matcher.
                number := 0;
                if !string_util::string_to_int(group, number, 8) { return ctx..error("Could not convert octal to int."); }

                number_as_char : char = unchecked_narrow<char>(number);

                token := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
                token*..set_string("\\(string_util::int_to_string<8>(number_as_char as int))$");

                return token;
            }

            str += group;
            // Regular group ref
        }
        else if 'g' == ctx..peek() 
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip g

            str += "g";

            if ctx..current() == '{' {
                str += "{";
                if !(ctx..next() && ctx..grab_until('}', out group)) { return ctx..error("No ending bracket."); }

                str += group + "}";
            }
            else {
                group = ctx..grab_number();
                str += group;
            }
        }
        else if 'k' == ctx..peek() 
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip k

            str += "k";

            term_char := '\0';
            if ctx..current() == '{' { term_char = '}'; }
            else if ctx..current() == '<' { term_char = '>'; }
            else if ctx..current() == '\'' { term_char = '\''; }
            else {
                return ctx..error("Group escape has wrong operator.");
            }

            str += ctx..current();

            if !(ctx..next() && ctx..grab_until(term_char, out group)) { return ctx..error("No ending bracket."); }

            str += group + term_char;
        }
        else 
        {
            // No group ref matcher
            return nullptr;
        }

        // Parse the group
        group = string_util::trim_copy(group);
        group_id : int = 0;
        if string_util::string_to_int(group, group_id) 
        {
            if group_id < 0 {
                group_id = ctx..get_cur_group() + group_id;

                if group_id < 1 { // Negative and zero are no valid groups.
                    return ctx..error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                }
            }

            if group_id >= ctx..get_cur_group() {
                return ctx..error("Group reference is used before the group is declared.");
            }
        }
        else 
        {
            // Named group
            group_id = ctx..get_named_group(group);
            if -1 == group_id { return ctx..error("Group names does not exist. (Name is: (group)$)");}
        }

        return shared.new<group_ref_token>(group_id, ctx..get_modifiers()..has(expression_flags::case_insensitive), false, str);
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<group_ref_token>(id, case_insensitive, !reverse_eval, to_string());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check("group_ref_token_matcher<char, (id)$, (case_insensitive)$, (reverse_eval)$>((ctx..match_parameters())$)");
    }
}


//  Regex syntax: (<tokens>)      Example: (abc)
//                (?<modifiers)            (?i)
//                (?<modifiers>:<tokens>)  (?i:abc)
//                (?<<name>>:<tokens>)     (?<start>:abc)
//                (?#<comment>)            (#Step 1 finished)
//                (?|<tokens>)             (?|(abc)|(cde))
//                (?=<tokens>)             (?=abc)
//                (?!<tokens>)             (?!abc)
//                (*<name>:<tokens)        (*pla:abc)
//
group_token: @polymorphic_base type = 
{
    this: regex_token = ();

    number:       int       = -1;
    reverse_eval: bool      = false;
    inner:        token_ptr = nullptr;

    parse_lookahead_lookbehind: (inout ctx: parse_context, syntax: std::string, lookahead: bool, positive: bool) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner*..to_string())$)");

        if !lookahead {
            r*.inner = r*.inner*..reverse();
        }

        return r;
    }

    parse_atomic_pattern: (inout ctx: parse_context, syntax: std::string) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<atomic_group_token>();

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner_token = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner_token*..to_string())$)");

        return r;
    }

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '(' { return nullptr; }

        has_id              :=  !ctx..get_modifiers()..has(expression_flags::no_group_captures);
        has_pattern         := true;
        group_name          : std::string = "";
        group_name_brackets := true;
        modifiers           : std::string = "";
        modifiers_change_to : =  ctx..get_modifiers();

        //  Skip the '('
        if !ctx..next() { return ctx..error("Group without closing bracket."); }

        if ctx..current() == '?' 
        {
            //  Special group
            if !ctx..next_no_skip() { return ctx..error("Missing character after group opening.");  }

            if  ctx.current() == '<' && (ctx.peek() == '=' || ctx.peek() == '!')
            {
                // Lookbehind
                _ = ctx.next(); // Skip the '<'

                return parse_lookahead_lookbehind(ctx, "?<(ctx..current())$", false, ctx..current() == '=');
            }
            else if ctx..current() == '<' || ctx..current() == '\''
            {
                //  Named group
                end_char := ctx..current();
                if end_char == '<' {
                    end_char = '>';
                } else {
                    group_name_brackets = false;
                }
                has_id = true; // Force id for named groups.
                if !ctx..next() /* skip '<' */ { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..grab_until(end_char, out group_name) { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..next() { return ctx..error("Group without closing bracket."); }
            }
            else if ctx..current() == '#' 
            {
                //  Comment
                comment_str : std::string = "";
                _ = ctx..next(); // Skip #
                if !ctx..grab_until(")", out comment_str) { return ctx..error("Group without closing bracket."); }
                //  Do not add comment. Has problems with ranges.

                //  Pop token and add a list. This fixes comments between a token and a range
                if ctx..has_token() {
                    list : token_vec = ();
                    list..push_back(ctx..pop_token());
                    list..push_back(shared.new<regex_token_empty>("(?#(comment_str)$)"));

                    return shared.new<regex_token_list>(list);
                }
                else {
                    return shared.new<regex_token_empty>("(?#(comment_str)$)");
                }
            }
            else if ctx..current() == '|' 
            {
                //  Branch reset group

                if !ctx..next() /* skip '|' */ { return ctx..error("Missing ending bracket for named group.");  }

                old_parser_state := ctx..start_group();
                old_branch_state  := ctx..branch_reset_new_state();
                if !ctx..parse_until(')') { return nullptr; }
                ctx..branch_reset_restore_state(old_branch_state);
                inner_ := ctx..end_group(old_parser_state);

                list: token_vec = (shared.new<regex_token_empty>("(?|"), inner_, shared.new<regex_token_empty>(")"));
                return shared.new<regex_token_list>(list);
            }
            else if ctx..current() == '=' || ctx..current() == '!' 
            {
                // Lookahead
                return parse_lookahead_lookbehind(ctx, "?(ctx..current())$", true, ctx..current() == '=');
            }
            else if ctx..current() == '>'
            {
                // Atomic pattern
                return parse_atomic_pattern(ctx, "?(ctx..current())$");
            }
            else 
            {
                //  Simple modifier
                has_id = false;
                if !ctx..grab_until_one_of("):", out modifiers) { return ctx..error("Missing ending bracket for group."); }
                if !ctx..parser_group_modifiers(modifiers, modifiers_change_to) {
                     return nullptr;
                }

                if ')' == ctx..current() {
                    has_pattern = false;
                }
                else {
                    if !ctx..next() /* skip ':' */ { return ctx..error("Missing ending bracket for group.");  }
                }
            }
        }
        else if ctx..current() == '*' 
        {
            //  Named pattern
            _ = ctx..next(); // Skip *.
            name: std::string = "";
            if !ctx..grab_until(':', out name) { return ctx..error("Missing colon for named pattern.");  }

            if name == "pla" || name == "positive_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, true);
            }
            else if name == "nla" || name == "negative_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, false);
            }
            else if name == "plb" || name == "positive_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, true);
            }
            else if name == "nlb" || name == "negative_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, false);
            }
            else if name == "atomic" {
                return parse_atomic_pattern(ctx, "*(name)$:");
            }
            else {
                return ctx..error("Unknown named group pattern: '(name)$'");
            }
        }

        if has_pattern 
        {
            //  Regular group

            r := shared.new<group_token>();
            if has_id {
                r*.number = ctx..next_group();

                if 0 != group_name..size() {
                    ctx..set_named_group(group_name, r*.number);
                }
            }

            old_state := ctx..start_group();
            ctx..set_modifiers(modifiers_change_to);
            if !ctx..parse_until(')') { return nullptr; }
            r*.inner = ctx..end_group(old_state);
            r*..set_string(gen_string(group_name, group_name_brackets, !has_id, modifiers, r*.inner));

            return r;
        }
        else 
        {
            //  Only a modifier
            ctx..set_modifiers(modifiers_change_to);

            return shared.new<regex_token_empty>("(?(modifiers)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<group_token>();
        r*.number = number;
        r*.reverse_eval = !reverse_eval;
        r*.inner = inner*.reverse();
        return r;
    }

    gen_string: (name: std::string, name_brackets: bool, has_modifier: bool, modifiers: std::string, inner_: token_ptr) -> std::string = 
    {
        start : std::string = "(";
        if 0 != name..size() {
            if name_brackets {
                start += "?<(name..data())$>";
            }
            else {
                start += "?'(name..data())$'";
            }
        }
        else if has_modifier {
            start += "?" + modifiers + ":";
        }

        return start + inner_*..to_string() + ")";
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
        }

        inner*..generate_code(ctx);
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }

            tmp_name := ctx..gen_temp();
            ctx..add("(tmp_name)$_func :=  :() = {");
            ctx..add("  if !r&$*.matched {");
            ctx..add("    ctx&$*..set_group_invalid((number)$);");
            ctx..add("  }");
            ctx..add("};");
            ctx..add("(tmp_name)$ :=  cpp2::regex::make_on_return((tmp_name)$_func);");
            ctx..add("_ = (tmp_name)$;"); // Logic is done in the destructor. Same behavior as for guard objects.
        }
    }

    add_groups: (override this, inout groups: std::set<int>) = 
    {
        inner*..add_groups(groups);
        if -1 != number {
            _ = groups..insert(number);
        }
    }
}


//  Regex syntax: \x<number> or \x{<number>}  Example: \x{62}
//
hexadecimal_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'x') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next() { return ctx..error("x escape without number.");}

    has_brackets := false;
    number_str: std::string = "";
    if '{' == ctx..current() {
        //  Bracketed
        has_brackets = true;
        _  = ctx..next(); // Skip '{'
        if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\x"); }
    }
    else {
        //  Grab two chars
        if !ctx..grab_n(2, out number_str) { return ctx..error("Missing hexadecimal digits after \\x."); }
    }

    number := 0;
    if !string_util::string_to_int(number_str, number, 16) { return ctx..error("Could not convert hexadecimal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = string_util::int_to_string<16>(number_as_char as int);
    if has_brackets {
        syntax = "{(syntax)$}";
    }
    syntax = "\\x(syntax)$";

    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: $  Example: aa$
//
line_end_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() == '$' || (ctx..current() == '\\' && ctx..peek() == '$') {
        if (ctx..current() == '\\') { _ = ctx..next(); } // Skip escape
        return shared.new<regex_token_check>("$", "line_end_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$, true>");
    }
    else if ctx..current() == '\\' && (ctx..peek() == 'z' || ctx..peek() == 'Z') {
        _ = ctx..next(); // Skip escape

        negate := ctx..current() == 'Z';
        return shared.new<regex_token_check>("\\(ctx..current())$", "line_end_token_matcher<char, false, (negate)$>");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: ^  Example: ^aa
//
line_start_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '^' && !(ctx..current() == '\\' && ctx..peek() == 'A') { return nullptr; }

    if ctx..current() == '\\' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\A", "line_start_token_matcher<char, false>");
    }
    else {
        return shared.new<regex_token_check>("^", "line_start_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$>");
    }
}


//  Regex syntax: (?=) or (?!) or (*pla), etc.  Example: (?=AA)
//
//  Parsed in group_token.
//
lookahead_lookbehind_token: @polymorphic_base type =
{
    this: regex_token = ("");

    protected lookahead: bool;
    protected positive:  bool;
    public    inner   :  token_ptr = nullptr;

    operator=: (out this, lookahead_: bool, positive_: bool) = {
        lookahead = lookahead_;
        positive  = positive_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx..generate_func(inner);

        if lookahead {
            ctx..add_check("lookahead_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
        else {
            ctx..add_check("lookbehind_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);
        r*.inner = inner; // We do not reverse here. Nested lookahead and lookbehind stay as they are.

        return r;
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner*..add_groups(groups);
    }
}


// Named character classes
//
named_class_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }

    name := "";
    c_next := ctx..peek();

    if      'd' == c_next { name = "named_class_digits"; }
    else if 'D' == c_next { name = "named_class_not_digits"; }
    else if 'h' == c_next { name = "named_class_hor_space"; }
    else if 'H' == c_next { name = "named_class_not_hor_space"; }
    else if 'N' == c_next { name = "named_class_no_new_line"; }
    else if 's' == c_next { name = "named_class_space"; }
    else if 'S' == c_next { name = "named_class_not_space"; }
    else if 'v' == c_next { name = "named_class_ver_space"; }
    else if 'V' == c_next { name = "named_class_not_ver_space"; }
    else if 'w' == c_next { name = "named_class_word"; }
    else if 'W' == c_next { name = "named_class_not_word"; }
    else                  { return nullptr; }

    _ = ctx..next(); // Skip escape

    return shared.new<regex_token_check>("\\(ctx..current())$", "(name)$<char, (ctx..get_modifiers()..has(expression_flags::case_insensitive))$>::match");
}


//  Regex syntax: \o{<number>}  Example: \o{142}
//
octal_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'o') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next()          { return ctx..error("o escape without number.");}
    if ctx..current() != '{' { return ctx..error("Missing opening bracket for \\o."); }

    number_str: std::string = "";
    _  = ctx..next(); // Skip '{'
    if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\o"); }

    number := 0;
    if !string_util::string_to_int(number_str, number, 8) { return ctx..error("Could not convert octal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = "\\o{(string_util::int_to_string<8>(number_as_char as int))$}";
    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: <matcher>{min, max}  Example: a{2,4}
//
range_token: @polymorphic_base type = 
{
    this                 : regex_token = ("");

    protected min_count  : int         = -1;
    protected max_count  : int         = -1;
    protected kind       : int         = range_flags::greedy;
    protected inner_token: token_ptr   = nullptr;

    operator=: (out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        r := shared.new<range_token>();
        if ctx..current() == '{' 
        {
            if !ctx..has_token() { return ctx..error("'{' without previous element."); }

            inner: std::string = "";
            if !ctx..grab_until('}', out inner) { return ctx..error("Missing closing bracket '}'."); }

            inner = string_util::trim_copy(inner..substr(1)); // Remove '{' and white spaces.
            if inner..empty() { return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

            // Non-greedy or possessive
            r*..parse_modifier(ctx);

            // Get range arguments
            min_count_str: std::string = "-1";
            max_count_str: std::string = "-1";

            sep: size_t = inner..find(',');
            if sep == std::string::npos 
            {
                min_count_str = inner;
                max_count_str = inner;
                if !string_util::string_to_int(inner, r*.min_count) { return ctx..error("Could not convert range to number."); }
                r*.max_count = r*.min_count;
            }
            else 
            {
                inner_first: std::string = string_util::trim_copy(inner..substr(0, sep));
                inner_last: std::string = string_util::trim_copy(inner..substr(sep + 1));

                if (inner_first..empty() && inner_last..empty()) {
                    return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                }

                if !inner_first..empty() {
                    min_count_str = inner_first;
                    if !string_util::string_to_int(inner_first, r*.min_count) { return ctx..error("Could not convert range to number."); }
                }
                if !inner_last..empty() {
                    max_count_str = inner_last;
                    if !string_util::string_to_int(inner_last, r*.max_count) { return ctx..error("Could not convert range to number."); }
                }
            }

            // Check validity of the range.
            if -1 != r*.min_count {
                if !(0 <= r*.min_count) {
                    return ctx..error("Min value in range is negative. Have (r*.min_count)$)");
                }
            }
            if -1 != r*.max_count {
                if !(0 <= r*.max_count) {
                    return ctx..error("Max value in range is negative. Have (r*.max_count)$)");
                }
                if -1 != r*.min_count {
                    if !(r*.min_count <= r*.max_count) {
                        return ctx..error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (r*.min_count)$ <= (r*.max_count)$");
                    }
                }
            }

            r*.inner_token = ctx..pop_token();
            r*.string_rep = r*.inner_token*..to_string() + r*..gen_range_string() + r*..gen_mod_string();

            return r;
        }

        return nullptr;
    }

    parse_modifier: (inout this, inout ctx: parse_context) = 
    {
        if ctx..peek() == '?' {
            kind = range_flags::not_greedy;
            _ = ctx..next();
        }
        else if ctx..peek() == '+' {
            kind = range_flags::possessive;
            _ = ctx..next();
        }
    }

    gen_mod_string: (this) -> std::string = 
    {
        if kind == range_flags::not_greedy {
            return "?";
        }
        else if kind == range_flags::possessive {
            return "+";
        }
        else {
            return "";
        }
    }

    gen_range_string: (this) -> std::string = 
    {
        r : std::string = "";
        if min_count == max_count {
            r += "{(min_count)$}";
        }
        else if min_count == -1 {
            r += "{,(max_count)$}";
        }
        else if max_count == -1 {
            r += "{(min_count)$,}";
        }
        else {
            r += "{(min_count)$,(max_count)$}";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<range_token>();
        r*.min_count   = min_count;
        r*.max_count   = max_count;
        r*.kind        = kind;
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        inner_name := ctx..generate_func(inner_token);
        groups: std::set<int> = ();
        inner_token*..add_groups(groups);
        reset_name := ctx..generate_reset(groups);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::range_token_matcher<char, (min_count)$, (max_count)$, (kind)$>::match((ctx..match_parameters())$, (inner_name)$, (reset_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}


//  Regex syntax: *, +, or ?  Example: aa*
//
special_range_token: @polymorphic_base type = 
{
    this : range_token = ();

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        r := shared.new<special_range_token>();
        symbol: char = '\0';
        if ctx..current() == '*' {
            r*.min_count = 0;
            r*.max_count = -1;
            symbol = '*';
        }
        else if ctx..current() == '+' {
            r*.min_count = 1;
            r*.max_count = -1;
            symbol = '+';
        } else if ctx..current() == '?' {
            r*.min_count = 0;
            r*.max_count = 1;
            symbol = '?';
        } else {
            return nullptr;
        }

        if !ctx..has_token() { return ctx..error("'(ctx..current())$' without previous element."); }


        r*..parse_modifier(ctx);

        r*.inner_token = ctx..pop_token();
        r*.string_rep = r*.inner_token*..to_string() + symbol + r*..gen_mod_string();
        return r;
    }
}

//  Regex syntax: \G  Example: \Gaa
//
//  Forces the match and/or consecutive matches to start at the position of the last match.
//
start_match_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'G' {
        if 0 != ctx..get_pos() { return ctx..error("\\G is only supported at the first position in the regex."); }
        _ = ctx..next();
        ctx.is_start_match = true;
        return shared.new<regex_token_empty>("\\G");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: \b or \B  Example: \bword\b
//
//  Matches the start end end of word boundaries.
//
word_boundary_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'b' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\b", "word_boundary_token_matcher<char, false>");
    }
    else if ctx..peek() == 'B' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\B", "word_boundary_token_matcher<char, true>");
    }
    else {
        return nullptr;
    }
}


//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

//  Parser and generator for regular expressions.
regex_generator: <Error_out> type = 
{
    regex:           std::string_view;
    modifier:        std::string = "";
    modifier_escape: std::string = "";

    error_out:       Error_out;

    source:          std::string = "";

    operator=: (out this, r: std::string_view, e: Error_out) = {
        regex = r;
        error_out = e;
    }

    parse:(inout this) -> std::string = 
    {
        // Extract modifiers and adapt regex.
        extract_modifiers();

        parse_ctx: parse_context = (regex, error_out);
        if !parse_ctx..parse(modifier) {
            return "";
        }

        source += "{\n";
        source += "  context: <Iter> type == cpp2::regex::match_context<CharT, Iter, (parse_ctx..get_cur_group())$>;";

        gen_ctx: generation_context = ();
        source += gen_ctx..run(parse_ctx..get_as_token());
        source += "  entry: <Iter> (cur: Iter, inout ctx: context<Iter>) -> cpp2::regex::match_return<Iter> = {\n";
        source += "    ctx..set_group_start(0, cur);\n";
        source += "    r := (gen_ctx..get_entry_func())$(cur, ctx, cpp2::regex::true_end_func());\n";
        source += "    if r.matched { ctx..set_group_end(0, r.pos); }\n";
        source += "    return r;\n";
        source += "  }\n";

        source += gen_ctx..create_named_group_lookup(parse_ctx.named_groups);
        source += "  is_start_match: () -> bool == (parse_ctx.is_start_match)$;";

        string := parse_ctx..get_as_token()*..to_string();
        source += "  to_string: () -> std::string = { return R\"((modifier_escape)$(string)$(modifier_escape)$(modifier)$)\"; }\n";

        source += "}\n";

        _ = parse_ctx;

        return source;
    }

    private extract_modifiers: (inout this) = 
    {
        if regex..find_first_of("'/") == 0 {
            mod_token: char = regex[0];

            end_pos := regex..rfind(mod_token);
            if end_pos != 0 {
                // Found valid start end escape
                modifier = regex..substr(end_pos + 1);
                modifier_escape = mod_token;
                regex = regex..substr(1, end_pos - 1);
            }
        }
    }
}

generate_regex: <Err> (regex: std::string_view, err: Err) -> std::string = 
{
    parser: regex_generator<Err> = (regex, err);
    r := parser..parse();
    _ = parser;
    return r;
}



regex_gen: (inout t: meta::type_declaration) =
{
    has_default := false;
    exact_name  := "regex";
    prefix      := "regex_";
    expressions : std::map<std::string, std::string> = ();

    for t.get_member_objects() do (inout m)
    {
        name: std::string = m.name();

        if name.starts_with(prefix) || name == exact_name
        {
            if !m.has_initializer() {
                t.error("Regular expression must have an initializer.");
            }
            m.mark_for_removal_from_enclosing_type();

            if name == exact_name {
                if has_default {
                    t.error("Type can only contain one default named regular expression.");
                }
                has_default = true;
            }

            expr: std::string = m.initializer();
            if expr.starts_with("R\"(") && expr.ends_with(")\"") {
                expr = expr.substr(3, expr.size() - 5);
            }
            else if string_util::is_escaped(expr) {
                expr = expr.substr(1, expr.size() - 2);
            }
            else {
                t.error("Unknown string format '(expr)$'");
            }

            expressions[name] = expr;
        }
    }

    t.remove_marked_members();

    for expressions do (expr) {
        regular_expression := generate_regex(expr.second, :(message) = t$.error(message););

        if !regular_expression..empty() {
            t.add_member("public (expr.first)$_matcher: <CharT> type = (regular_expression)$");
            t.add_member("public (expr.first)$: cpp2::regex::regular_expression<char, (expr.first)$_matcher<char>> = ();\n");
        }
    }

    t.add_runtime_support_include( "cpp2regex.h" );
}


//-----------------------------------------------------------------------
//
//  apply_metafunctions
//
apply_metafunctions: (
    inout n     : declaration_node,
    inout rtype : type_declaration,
    error
    )
    -> bool
= {
    assert( n.is_type() );

    //  Check for _names reserved for the metafunction implementation
    if !n.metafunctions.empty()
    {
        for  rtype.get_members()
        do   (m)
        {
            m.require( 
                !m.name().starts_with("_") || m.name().ssize() == 1,
                "a type that applies a metafunction cannot have a body that declares "
                "a name that starts with '_' - those names are reserved for the "
                "metafunction implementation"
            );
        }
    }

    //  For each metafunction, apply it
    for n.metafunctions
    do  (meta)
    {
        //  Convert the name and any template arguments to strings
        //  and record that in rtype
        name := meta*.to_string();
        name = name.substr(0, name.find('<'));

        args: std::vector<std::string> = ();
        for meta*.template_arguments()
        do  (arg)
            args.push_back( arg.to_string() );

        rtype.set_metafunction_name( name, args );

        //  Dispatch
        //
        if name == "interface" {
            interface( rtype );
        }
        else if name == "polymorphic_base" {
            polymorphic_base( rtype );
        }
        else if name == "ordered" {
            ordered( rtype );
        }
        else if name == "weakly_ordered" {
            weakly_ordered( rtype );
        }
        else if name == "partially_ordered" {
            partially_ordered( rtype );
        }
        else if name == "copyable" {
            copyable( rtype );
        }
        else if name == "hashable" {
            hashable( rtype );
        }
        else if name == "basic_value" {
            basic_value( rtype );
        }
        else if name == "value" {
            value( rtype );
        }
        else if name == "weakly_ordered_value" {
            weakly_ordered_value( rtype );
        }
        else if name == "partially_ordered_value" {
            partially_ordered_value( rtype );
        }
        else if name == "cpp1_rule_of_zero" {
            cpp1_rule_of_zero( rtype );
        }
        else if name == "struct" {
            cpp2_struct( rtype );
        }
        else if name == "enum" {
            cpp2_enum( rtype );
        }
        else if name == "flag_enum" {
            flag_enum( rtype );
        }
        else if name == "union" {
            cpp2_union( rtype );
        }
        else if name == "print" {
            print( rtype );
        }
        else if name == "noisy" {
            noisy( rtype );
        }
        else if name == "autodiff" {
            autodiff( rtype );
        }
        else if name == "regex" {
            regex_gen( rtype );
        }
        else {
            error( "unrecognized metafunction name: " + name );
            error( 
                "the current supported names are listed at "
                "https://hsutter.github.io/cppfront/cpp2/metafunctions/#built-in-metafunctions"
            );
            return false;
        }
    }

    return true;
}


}

}
