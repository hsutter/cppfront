
//  Copyright 2022-2025 Herb Sutter
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//  
//  Part of the Cppfront Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://github.com/hsutter/cppfront/blob/main/LICENSE for license information.


//===========================================================================
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);

    is_same:      (this, o: reflection_base)     -> bool = n == o.n;  // Test pointers
    is_same: <TO> (this, _: reflection_base<TO>) -> bool = false;     // Different types => false
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }

        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression list
//
expression_list: @copy_constructible type =
{
    this: reflection_base<expression_list_node> = ();

    operator=: (
        out this,
        n_: *expression_list_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_list_node> = (n_, s);
    }

    is_empty          : (this) -> bool = n*.is_empty          ();
    is_fold_expression: (this) -> bool = n*.is_fold_expression();

    get_expressions: (this)
        -> std::vector<expression>
    = {
        ret: std::vector<expression> = ();
        for n*.get_expressions() do (expr) {
            _ = ret.emplace_back(expression(expr.expr.get(), this));
        }
        return ret;
    }

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Prefix expressions
//
prefix_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<prefix_expression_node> = ();

    operator=: (
        out this,
        n_: *prefix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<prefix_expression_node> = (n_, s);
    }

    get_ops: (this) -> std::vector<std::string> = {
        ret: std::vector<std::string> = ();
        for n*.ops do (op) {
            _ = ret.emplace_back(op*.to_string());
        }
        return ret;
    }

    get_postfix_expression: (this) -> postfix_expression = (this.n*.expr.get(), this);

    is_fold_expression            : (this) -> bool = n*.is_fold_expression            ();
    is_identifier                 : (this) -> bool = n*.is_identifier                 ();
    is_id_expression              : (this) -> bool = n*.is_id_expression              ();
    is_unqualified_id             : (this) -> bool = n*.is_unqualified_id             ();
    is_expression_list            : (this) -> bool = n*.is_expression_list            ();
    is_literal                    : (this) -> bool = n*.is_literal                    ();
    is_result_a_temporary_variable: (this) -> bool = n*.is_result_a_temporary_variable();

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Postfix expressions
//
postfix_expression: @copy_constructible type =
{
    this: reflection_base<postfix_expression_node> = ();

    operator=: (
        out this,
        n_: *postfix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<postfix_expression_node> = (n_, s);
    }

    get_primary_expression: (this) -> primary_expression = (this.n*.expr.get(), this);

    term_t: @copy_constructible type = {
        private term_: * const postfix_expression_node::term;
        private cs_  : * const compiler_services;

        operator=: (out this, forward term, forward cs) = { term_ = term; cs_ = cs; }

        get_op            : (this) -> std::string_view  = term_*.op*.as_string_view();

        //  If op is        More is contained in the        Notes
        //
        //  .               id_expression                   member selection
        //  [ (             expression_list                 subscript or function call
        //  ...             expression                      fold expression

        is_id_expression   : (this) -> bool            = term_*.id_expr  .get() != nullptr;
        is_expression_list : (this) -> bool            = term_*.expr_list.get() != nullptr;
        is_expression      : (this) -> bool            = term_*.last_expr.get() != nullptr;

        get_id_expression  : (this) -> id_expression   = (term_*.id_expr  .get(), cs_*);
        get_expression_list: (this) -> expression_list = (term_*.expr_list.get(), cs_*);
        get_expression     : (this) -> expression      = (term_*.last_expr.get(), cs_*);
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t&, this& ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();

    get_first_token_ignoring_this: (this) -> std::string_view = {
        ptok := n*.get_first_token_ignoring_this();
        if ptok { return ptok*; }
        return "";
    }

    starts_with_function_call_with_num_parameters: (this, num: int) -> bool = n*.starts_with_function_call_with_n_parameters(num);
    is_result_a_temporary_variable               : (this) -> bool           = n*.is_result_a_temporary_variable             ();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Template arguments
//
template_arg: @copy_constructible type =
{
    this: reflection_base<template_argument> = ();

    operator=: (
        out this,
        n_: *template_argument,
        s : compiler_services
    )
    = {
        reflection_base<template_argument> = (n_, s);
    }

    is_expression: (this) -> bool = n*.is_expression();
    is_type_id   : (this) -> bool = n*.is_type_id   ();

    as_expression: (this) -> expression = (this.n*.get_expression(), this);
    as_type_id   : (this) -> type_id    = (this.n*.get_type_id(),    this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Unqualified IDs
//
unqualified_id: @copy_constructible type =
{
    this: reflection_base<unqualified_id_node> = ();

    operator=: (
        out this,
        n_: *unqualified_id_node,
        s : compiler_services
    )
    = {
        reflection_base<unqualified_id_node> = (n_, s);
    }

    is_identifier : (this) -> bool        = n*.is_identifier();

    get_identifier: (this) -> std::string = n*.get_identifier()*.to_string();

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    as_token : (this) -> std::string = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Qualified IDs
//
qualified_id: @copy_constructible type =
{
    this: reflection_base<qualified_id_node> = ();

    operator=: (
        out this,
        n_: *qualified_id_node,
        s : compiler_services
    )
    = {
        reflection_base<qualified_id_node> = (n_, s);
    }

    term_t: @copy_constructible type = {
        op:          std::string;
        unqualified: unqualified_id;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; unqualified = (ptr, cs); }

        get_op:          (this) -> std::string    = op;
        get_unqualified: (this) -> unqualified_id = unqualified;
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ids do (t) { _ = ret.emplace_back( t.scope_op*, t.id.get(), this ); }
        return ret;
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    as_token : (this) -> std::string = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Type IDs
//
type_id: @copy_constructible type =
{
    this: reflection_base<type_id_node> = ();

    operator=: (
        out this,
        n_: *type_id_node,
        s : compiler_services
    )
    = {
        reflection_base<type_id_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_postfix_expression: (this) -> bool = this.n*.is_postfix_expression();
    is_qualified_id      : (this) -> bool = this.n*.is_qualified_id      ();
    is_unqualified_id    : (this) -> bool = this.n*.is_unqualified_id    ();
    is_function_typeid   : (this) -> bool = this.n*.is_function_typeid   ();
    is_keyword           : (this) -> bool = this.n*.is_keyword           ();
    is_wildcard          : (this) -> bool = this.n*.is_wildcard          ();
    is_pointer_qualified : (this) -> bool = this.n*.is_pointer_qualified ();
    is_concept           : (this) -> bool = this.n*.is_concept           ();

    as_postfix_expression: (this) -> postfix_expression = (n*.get_postfix_expression(), this);
    as_qualified_id      : (this) -> qualified_id       = (n*.get_qualified_id(),       this);
    as_unqualified_id    : (this) -> unqualified_id     = (n*.get_unqualified_id(),     this);
    // TODO
    //as_function_typeid   : (this) -> function_typeid    = (n*.get_function_typeid(),    this);
    as_keyword           : (this) -> std::string        = n*.get_keyword()*.to_string();
    as_token             : (this) -> std::string        = n*.get_token()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Primary expressions
//
primary_expression: @copy_constructible type =
{
    this: reflection_base<primary_expression_node> = ();

    operator=: (
        out this,
        n_: *primary_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<primary_expression_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();
    is_declaration    : (this) -> bool = n*.is_declaration    ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_declaration    : (this) -> declaration     = (this.n*.get_declaration(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  ID expression
//
id_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<id_expression_node> = ();

    operator=: (
        out this,
        n_: *id_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<id_expression_node> = (n_, s);
    }

    //get_template_args: (this) -> std::vector<template_arg> = {
    //    ret: std::vector<template_arg> = ();
    //    for this.n*.template_arguments() do (t) { _ = ret.emplace_back( t&, this ); }
    //    return ret;
    //}

    is_fold_expression: (this) -> bool = n*.is_fold_expression      ();
    is_empty          : (this) -> bool = n*.is_empty                ();
    is_identifier     : (this) -> bool = n*.is_identifier           ();
    is_qualified      : (this) -> bool = n*.is_qualified            ();
    is_unqualified    : (this) -> bool = n*.is_unqualified          ();

    as_identifier     : (this) -> std::string    = n*.get_identifier()*.to_string();
    as_qualified      : (this) -> qualified_id   = (n*.get_qualified_id(),   this);
    as_unqualified    : (this) -> unqualified_id = (n*.get_unqualified_id(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  General expression
//
expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<expression_node> = ();

    operator=: (
        out this,
        n_: *expression_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_node> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = n*.is_fold_expression      ();
    is_standalone_expression: (this) -> bool = n*.is_standalone_expression();
    subexpression_count     : (this) -> int  = n*.subexpression_count     ();
    is_identifier           : (this) -> bool = n*.is_identifier           ();
    is_id_expression        : (this) -> bool = n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = n*.is_expression_list      ();
    is_empty_expression_list: (this) -> bool = n*.is_empty_expression_list();
    is_literal              : (this) -> bool = n*.is_literal              ();
    is_assignment_expression: (this) -> bool = n*.is_assignment_expression();

    is_simple_assignment    : (this) -> bool = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        return ret.lhs && ret.rhs;
    }

    get_lhs_rhs_if_simple_assignment: (this)
        -> (
            lhs: postfix_expression, 
            rhs: logical_or_expression
        )
    = {
        ret := n*.get_lhs_rhs_if_simple_assignment();
        lhs = (ret.lhs, this);
        rhs = (ret.rhs, this);
    }

    as_assignment_expression: (this) -> assignment_expression = (n*.get_assignment_expression(), this);
    as_expression_list      : (this) -> expression_list       = (n*.get_expression_list(), this);
    as_literal              : (this) -> std::string           = n*.get_literal()*.to_string();

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  is_as_expression
//
is_as_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<is_as_expression_node> = ();

    operator=: (
        out this,
        n_: *is_as_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<is_as_expression_node> = (n_, s);
    }

    term_t: @copy_constructible type = {
        op:   std::string;
        expr: expression;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; expr = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_expr: (this) -> expression  = expr;
    }

    get_expression: (this) -> prefix_expression = (n*.expr.get(), this);

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = this.n*.is_fold_expression();
    is_identifier     : (this) -> bool = this.n*.is_identifier     ();
    is_id_expression  : (this) -> bool = this.n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = this.n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = this.n*.is_expression_list();
    is_literal        : (this) -> bool = this.n*.is_literal        ();
                      
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
                      
    get_identifier    : (this) -> std::string_view = { 
        ptok := this.n*.get_identifier();
        if ptok { return ptok*; }
        return "";
    }

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
// 
//  Statements
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  General statement
//
statement: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<statement_node> = ();

    operator=: (
        out this,
        n_: *statement_node,
        s : compiler_services
    )
    = {
        reflection_base<statement_node> = (n_, s);
    }

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    is_expression_statement : (this) -> bool = n*.is_expression();
    is_compound_statement   : (this) -> bool = n*.is_compound();
    is_selection_statement  : (this) -> bool = n*.is_selection();
    is_declaration          : (this) -> bool = n*.is_declaration();
    is_return_statement     : (this) -> bool = n*.is_return();
    is_iteration_statement  : (this) -> bool = n*.is_iteration();
    is_using_statement      : (this) -> bool = n*.is_using();
    is_contract             : (this) -> bool = n*.is_contract();
    is_inspect_expression   : (this) -> bool = n*.is_inspect();
    is_jump_statement       : (this) -> bool = n*.is_jump();

    as_expression_statement : (this) -> expression_statement  = (n*.get_if<expression_statement_node>(), this);
    as_compound_statement   : (this) -> compound_statement    = (n*.get_if<compound_statement_node>(), this);
    as_selection_statement  : (this) -> selection_statement   = selection_statement  (n*.get_if<selection_statement_node>(), this);
    as_declaration          : (this) -> declaration           = declaration(n*.get_if<declaration_node>(), this);
    as_return_statement     : (this) -> return_statement      = return_statement     (n*.get_if<return_statement_node>(), this);
    as_iteration_statement  : (this) -> iteration_statement   = iteration_statement  (n*.get_if<iteration_statement_node>(), this);
    //as_using_statement      : (this) -> using_statement       = using_statement      (n*.get_if<using_statement_node>(), this);
    //as_contract             : (this) -> contract              = contract             (n*.get_if<contract_node>(), this);
    //as_inspect_expression   : (this) -> inspect_expression    = inspect_expression   (n*.get_if<inspect_expression_node>(), this);
    //as_jump_statement       : (this) -> jump_statement        = jump_statement       (n*.get_if<jump_statement_node>(), this);

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression statements
//
expression_statement: @copy_constructible type =
{
    this: reflection_base<expression_statement_node> = ();

    operator=: (
        out this,
        n_: *expression_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_statement_node> = (n_, s);
    }

    get_expression: (this) -> expression  = (n*.expr.get(), this);

    to_string     : (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Compound statements
//
compound_statement: @copy_constructible type =
{
    this: reflection_base<compound_statement_node> = ();

    operator=: (
        out this,
        n_: *compound_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<compound_statement_node> = (n_, s);
    }

    get_statements: (this)
        -> std::vector<statement>
    = {
        ret: std::vector<statement> = ();
        for n*.get_statements() do (stmt) {
            _ = ret.emplace_back( stmt, this );
        }
        return ret;
    }

    add_statement: (inout this, source: std::string_view, before_position: int = 0)
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        require( n*.add_statement(move stmt, before_position),
                 std::string("unexpected error while attempting to add statement:\n") + source );
    }
}


//-----------------------------------------------------------------------
//  Selection statements
//
selection_statement: @copy_constructible type =
{
    this: reflection_base<selection_statement_node> = ();

    operator=: (
        out this,
        n_: *selection_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<selection_statement_node> = (n_, s);
    }

    has_false_branch_in_source_code: (this) -> bool = n*.has_false_branch_in_source_code();
    has_false_branch               : (this) -> bool = n*.has_false_branch();

    get_identifier  : (this) -> std::string_view      = n*.get_identifier()*.as_string_view();
    get_expression  : (this) -> logical_or_expression = (n*.get_expression  (), this);
    get_true_branch : (this) -> compound_statement    = (n*.get_true_branch (), this);
    get_false_branch: (this) -> compound_statement    = (n*.get_false_branch(), this);
}


//-----------------------------------------------------------------------
//  Return statements
//
return_statement: @copy_constructible type =
{
    this: reflection_base<return_statement_node> = ();

    operator=: (
        out this,
        n_: *return_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<return_statement_node> = (n_, s);
    }

    has_expression: (this) -> bool       = n*.has_expression();

    get_expression: (this) -> expression = (n*.get_expression(), this);
}


//-----------------------------------------------------------------------
//  Iteration statements - for, do, while
//
iteration_statement: @copy_constructible type =
{
    this: reflection_base<iteration_statement_node> = ();

    operator=: (
        out this,
        n_: *iteration_statement_node,
        s : compiler_services
    )
    = {
        reflection_base<iteration_statement_node> = (n_, s);
    }

    is_do   : (this) -> bool = n*.is_do   ();
    is_while: (this) -> bool = n*.is_while();
    is_for  : (this) -> bool = n*.is_for  ();
    has_next: (this) -> bool = n*.has_next();

    get_label             : (this) -> std::string           = n*.get_label().to_string();
    get_next_expression   : (this) -> assignment_expression = (n*.get_next_expression(),    this);
    get_do_while_condition: (this) -> logical_or_expression = (n*.get_do_while_condition(), this);
    get_do_while_body     : (this) -> compound_statement    = (n*.get_do_while_body(),      this);
    get_for_range         : (this) -> expression            = (n*.get_for_range(),          this);
    get_for_parameter     : (this) -> parameter_declaration = (n*.get_for_parameter(),      this);
    get_for_body          : (this) -> statement             = (n*.get_for_body(),           this);
}


//-----------------------------------------------------------------------
//
//  Metafunctions - these are hardwired for now until we get to the
//  step of writing a Cpp2 interpreter to run inside the compiler
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Some common metafunction helpers (metafunctions are just functions,
//  so they can be factored as usual)
//
add_virtual_destructor: (inout t: meta::type_declaration) =
{
    t.add_member( "operator=: (virtual move this) = { }");
}


//-----------------------------------------------------------------------
//
//      "... an abstract base class defines an interface ..."
//
//          -- Stroustrup (The Design and Evolution of C++, 12.3.1)
//
//-----------------------------------------------------------------------
//
//  interface
//
//  an abstract base class having only pure virtual named functions,
//  a public default constructor, a public virtual destructor, and
//  protected copy/move operations
//
interface: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_members() do (inout m)
    {
        m.require( !m.is_object(),
                   "interfaces may not contain data objects");
        if m.is_function() {
            mf := m.as_function();
            mf.require( !mf.is_copy_or_move(),
                        "interfaces may not copy or move; consider a virtual clone() instead");
            mf.require( !mf.has_initializer(),
                        "interface functions must not have a function body; remove the '=' initializer");
            mf.require( mf.make_public(),
                        "interface functions must be public");
            mf.default_to_virtual();
            has_dtor |= mf.is_destructor();
        }
    }

    //  Add public default constructor + protected copy/move operations
    t.add_member( "operator=: (out this) = { }");
    t.add_member( "protected operator=: (out this, that) = { }");

    //  Add public virtual destructor
    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "C.35: A base class destructor should be either public and
//      virtual, or protected and non-virtual."
//
//          -- Stroustrup, Sutter, et al. (C++ Core Guidelines)
//
//-----------------------------------------------------------------------
//
//  polymorphic_base
//
//  A polymorphic base type whose destructor is either public and virtual
//  or else protected and nonvirtual.
//
//  Unlike an interface, it can have nonpublic and nonvirtual functions.
//
polymorphic_base: (inout t: meta::type_declaration) =
{
    has_dtor := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.is_default_access() {
            mf.default_to_public();
        }
        mf.require( !mf.is_copy_or_move(),
                    "polymorphic base types may not copy or move; consider a virtual clone() instead");
        if mf.is_destructor() {
            has_dtor = true;
            mf.require( ((mf.is_public() || mf.is_default_access()) && mf.is_virtual())
                        || (mf.is_protected() && !mf.is_virtual()),
                        "a polymorphic base type destructor must be public and virtual, or protected and nonvirtual");
        }
    }

    if !has_dtor {
        t.add_virtual_destructor();
    }
}


//-----------------------------------------------------------------------
//
//     "... A totally ordered type ... requires operator<=> that
//      returns std::strong_ordering. If the function is not
//      user-written, a lexicographical memberwise implementation
//      is generated by default..."
//
//          -- P0707R4, section 3
//
//      Note: This feature derived from Cpp2 was already adopted
//            into Standard C++ via paper P0515, so most of the
//            heavy lifting is done by the Cpp1 C++20/23 compiler,
//            including the memberwise default semantics
//            (In contrast, cppfront has to do the work itself for
//            default memberwise semantics for operator= assignment
//            as those aren't yet part of Standard C++)
//
//-----------------------------------------------------------------------
//

ordered_impl: (
    inout t:  meta::type_declaration,
    ordering: std::string_view  // must be "strong_ordering" etc.
) =
{
    has_spaceship := false;

    for t.get_member_functions() do (inout mf)
    {
        if mf.has_name("operator<=>") {
            has_spaceship = true;
            return_name := mf.get_unnamed_return_type();
            if return_name.find(ordering) == return_name.npos
            {
                mf.error( "operator<=> must return std::" + ordering as std::string );
            }
        }
    }

    if !has_spaceship {
        t.add_member( "operator<=>: (this, that) -> std::" + (ordering as std::string) + ";" );
    }
}

//-----------------------------------------------------------------------
//  ordered - a totally ordered type
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "strong_ordering" );
}

//-----------------------------------------------------------------------
//  weakly_ordered - a weakly ordered type
//
weakly_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "weak_ordering" );
}

//-----------------------------------------------------------------------
//  partially_ordered - a partially ordered type
//
partially_ordered: (inout t: meta::type_declaration) =
{
    ordered_impl( t, "partial_ordering" );
}


//-----------------------------------------------------------------------
//
//     "A value is ... a regular type. It must have all public
//      default construction, copy/move construction/assignment,
//      and destruction, all of which are generated by default
//      if not user-written; and it must not have any protected
//      or virtual functions (including the destructor)."
//
//          -- P0707R4, section 3
//
//-----------------------------------------------------------------------
//
//  copyable
//
//  A type with (copy and move) x (construction and assignment)
//
copyable: (inout t: meta::type_declaration) =
{
    //  If the user explicitly wrote any of the copy/move functions,
    //  they must also have written the most general one - we can't
    //  assume we can safely generate it for them since they've opted
    //  into customized semantics
    smfs := t.query_declared_value_set_functions();
    if  !smfs.out_this_in_that
        && (
            smfs.out_this_move_that
            || smfs.inout_this_in_that
            || smfs.inout_this_move_that
        )
    {
        t.error( 
            "this type is partially copyable/movable - when you provide "
            "any of the more-specific operator= signatures, you must also provide "
            "the one with the general signature (out this, that); alternatively, "
            "consider removing all the operator= functions and let them all be "
            "generated for you with default memberwise semantics" 
        );
    }
    else if !smfs.out_this_in_that {
        t.add_member( "operator=: (out this, that) = { }");
    }
}


//  copy_constructible
//
//  A type with (copy and move) construction
//
copy_constructible: (inout t: meta::type_declaration) =
{
    //  If the user explicitly wrote any of the copy/move constructors,
    //  they must also have written the most general one - we can't
    //  assume we can safely generate it for them since they've opted
    //  into customized semantics
    smfs := t.query_declared_value_set_functions();
    if  !smfs.out_this_in_that
        && smfs.out_this_move_that
    {
        t.error( 
            "this type is partially copy/move constructible - when you provide "
            "the (out this, move that) operator= signature, you must also provide "
            "the one with the general signature (out this, that)" 
        );
    }
    else if 
        !smfs.out_this_in_that
        && !smfs.out_this_move_that
    {
        t.add_member( "operator=: (out this,      that) = { }");
        t.add_member( "operator=: (out this, move that) = { }");
    }
}


//-----------------------------------------------------------------------
//
//  hashable
//
//  A memberwise hashable type
//
hashable: (inout t: meta::type_declaration) =
{
    t.require( !t.get_member_objects().empty(),
               "a hashable type must have at least one data member");

    hash: std::string = "    hash: (this) -> size_t = {\n"
                        "        ret: size_t = 0;";

    for  t.get_member_objects() 
    do   (o)
    {
        o_hash: std::string;
        if o.name() == "this" {
            o_hash = "(o.type())$::hash()";
        }
        else {
            o_hash = "std::hash<(o.type())$>()((o.name())$)";
        }

        hash += "\n        cpp2::hash_combine( ret, (o_hash)$ );";
    }

    t.add_member(hash + "\n        return ret;\n    }");
}


//-----------------------------------------------------------------------
//
//  basic_value
//
//  A regular type: copyable, plus has public default construction
//  and no protected or virtual functions
//
basic_value: (inout t: meta::type_declaration) =
{
    t.copyable();

    has_default_ctor := false;
    for t.get_member_functions() do (inout mf) {
        has_default_ctor |= mf.is_default_constructor();
        mf.require( !mf.is_protected() && !mf.is_virtual(),
                    "a value type may not have a protected or virtual function");
        mf.require( !mf.is_destructor() || mf.is_public() || mf.is_default_access(),
                    "a value type may not have a non-public destructor");
    }

    if !has_default_ctor {
        t.add_member( "operator=: (out this) = { }");
    }
}

//-----------------------------------------------------------------------
//
//     "A 'value' is a totally ordered basic_value..."
//
//          -- P0707R4, section 3
//
//  value - a value type that is totally ordered
//
//  Note: the ordering that should be encouraged as default gets the nice name
//
value: (inout t: meta::type_declaration) =
{
    t.ordered();
    t.basic_value();
}

weakly_ordered_value: (inout t: meta::type_declaration) =
{
    t.weakly_ordered();
    t.basic_value();
}

partially_ordered_value: (inout t: meta::type_declaration) =
{
    t.partially_ordered();
    t.basic_value();
}


//-----------------------------------------------------------------------
//
//     C.20: If you can avoid defining default operations, do
//
//     ##### Reason
//
//     It's the simplest and gives the cleanest semantics.
//
//     ...
//
//     This is known as "the rule of zero".
//
//          -- C++ Core Guidelines
//             C.20: If you can avoid defining any default operations, do
//             <https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero>
//
//-----------------------------------------------------------------------
//
//  cpp1_rule_of_zero
//
//  a type without declared copy/move/destructor functions
//
cpp1_rule_of_zero: (inout t: meta::type_declaration) =
{
    for t.get_member_functions() do (inout mf)
    {
        t.require( !mf.is_constructor_with_that()
                   && !mf.is_assignment_with_that()
                   && !mf.is_destructor(),
                   "the rule of zero requires no copy/move/destructor functions");
    }
    t.disable_member_function_generation();
}

//-----------------------------------------------------------------------
//
//     "By definition, a `struct` is a `class` in which members
//      are by default `public`; that is,
//
//      	struct s { ...
//
//      is simply shorthand for
//
//          class s { public: ...
//
//      ... Which style you use depends on circumstances and taste.
//      I usually prefer to use `struct` for classes that have all
//      data `public`."
//
//          -- Stroustrup (The C++ Programming Language, 3rd ed., p. 234)
//
//-----------------------------------------------------------------------
//
//  struct
//
//  a type with only public bases, objects, and functions,
//  no virtual functions, and no user-defined constructors
//  (i.e., no invariants) or assignment or destructors.
// 
//  For GCC 10 compatibility, optionally allow passing struct<noforward>
//  that generates a memberwise constructor with a generic deduced
//  parameters instead of concrete forwarding parameters (mainly used
//  for cppfront internal use, so cppfront builds under GCC 10)
//
struct: (inout t: meta::type_declaration) =
{
    ctor_params: std::string = ();
    ctor_inits : std::string = ();

    found_member_without_initializer: = false;

    for t.get_members() do (inout m)
    {
        m.require( m.make_public(),
                   "all struct members must be public");
        if m.is_function() {
            mf := m.as_function();
            t.require( !mf.is_virtual(),
                       "a struct may not have a virtual function");
            t.require( !mf.has_name("operator="),
                       "a struct may not have a user-defined operator=");
        }
        else if m.is_object() {
            mo: = m.as_object();
            if mo.name() != "this" {
                if t.get_argument(0) == "noforward" {
                    ctor_params += "(mo.name())$_, ";
                }
                else {
                    ctor_params += "forward (mo.name())$_ : (mo.type())$, ";
                }
                ctor_inits  += "(mo.name())$ = (mo.name())$_; ";
            }
            else {
                ctor_inits += "(mo.type())$ = ((mo.initializer())$); ";
            }
            found_member_without_initializer |= !mo.has_initializer();
        }
    }
    t.cpp1_rule_of_zero();

    //  If we found any data members
    if !ctor_params.empty()
    {
        //  Then to enable construction from corresponding values
        //  requires a constructor... an exception to the rule of zero
        t.add_member("    operator=: (implicit out this, (ctor_params)$) = { (ctor_inits)$ }");

        //  And if all members had initializers, we need a default constructor
        if !found_member_without_initializer {
            t.add_member("    operator=: (implicit out this) = { }");
        }
    }
}


//-----------------------------------------------------------------------
//
//     "C enumerations constitute a curiously half-baked concept. ...
//      the cleanest way out was to deem each enumeration a separate type."
//
//          -- Stroustrup (The Design and Evolution of C++, 11.7)
//
//     "An enumeration is a distinct type ... with named constants"
//
//          -- ISO C++ Standard
//
//-----------------------------------------------------------------------
//
//  basic_enum
//
//  a type together with named constants that are its possible values
//
value_member_info: @struct<noforward> type = {
    name  : std::string;
    type  : std::string;
    value : std::string;
}

basic_enum: (
    inout t : meta::type_declaration,
    nextval ,
    bitwise : bool
    )
= {
    enumerators     : std::vector<value_member_info> = ();
    min_value       : i64                            = ();
    max_value       : i64                            = ();
    underlying_type : std::string;

    t.reserve_names( "operator=", "operator<=>" );
    if bitwise {
        t.reserve_names( "has", "set", "clear", "to_string", "get_raw_value", "none" );
    }

    //  1. Gather: The names of all the user-written members, and find/compute the type

    underlying_type = t.get_argument(0);    // use the first template argument, if there was one

    found_non_numeric := false;

    (copy value: std::string = "-1")
    for  t.get_members()
    do   (m)
    if   m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                    "an enumerator cannot be protected or private");

        mo := m.as_object();
        if !mo.has_wildcard_type() {
            mo.error( 
                "an explicit underlying type should be specified as a compile-time argument "
                "to the metafunction - try 'enum<u16>' or 'flag_enum<u64>'"
            );
        }

        init := mo.initializer();

        is_default_or_numeric := is_empty_or_a_decimal_number(init);
        found_non_numeric |= !init.empty() && !is_default_or_numeric;
        m.require( !is_default_or_numeric || !found_non_numeric || mo.has_name("none"),
            "(mo.name())$: enumerators with non-numeric values must come after all default and numeric values");

        nextval( value, init );

        v := std::strtoll(value[0]&, nullptr, 10);  // for non-numeric values we'll just get 0 which is okay for now
        if v < min_value {
            min_value = v;
        }
        if v > max_value {
            max_value = v;
        }

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, "", value );
        enumerators.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    if (enumerators.empty()) {
        t.error( "an enumeration must contain at least one enumerator value");
        return;
    }

    //  Compute the default underlying type, if it wasn't explicitly specified
    if underlying_type == ""
    {
        t.require( !found_non_numeric,
            "if you write an enumerator with a non-numeric-literal value, "
            "you must specify the enumeration's underlying type"
        );

        if !bitwise {
            if min_value >= std::numeric_limits<i8>::min() && max_value <= std::numeric_limits<i8>::max() {
                underlying_type = "i8";
            }
            else if min_value >= std::numeric_limits<i16>::min() && max_value <= std::numeric_limits<i16>::max() {
                underlying_type = "i16";
            }
            else if min_value >= std::numeric_limits<i32>::min() && max_value <= std::numeric_limits<i32>::max() {
                underlying_type = "i32";
            }
            else if min_value >= std::numeric_limits<i64>::min() && max_value <= std::numeric_limits<i64>::max() {
                underlying_type = "i64";
            }
            else {
                t.error(
                    "values are outside the range representable by the "
                    "largest supported underlying signed type (i64)" 
                );
            }
        }
        else {
            umax := max_value * 2 as u64;
            if umax <= std::numeric_limits<u8>::max() {
                underlying_type = "u8";
            }
            else if umax <= std::numeric_limits<u16>::max() {
                underlying_type = "u16";
            }
            else if umax <= std::numeric_limits<u32>::max() {
                underlying_type = "u32";
            }
            else {
                underlying_type = "u64";
            }
        }
    }


    //  2. Replace: Erase the contents and replace with modified contents
    //
    //  Note that most values and functions are declared as '==' compile-time values, i.e. Cpp1 'constexpr'

    t.remove_marked_members();

    //  Generate the 'none' value if appropriate, and use that or
    //  else the first enumerator as the default-constructed value
    default_value := enumerators[0].name;
    if bitwise{
        default_value = "none";
        e: value_member_info = ( "none", "", "0");
        enumerators.push_back( e );
    }

    //  Generate all the private implementation
    t.add_member( "    _value            : (underlying_type)$;");
    t.add_member( "    private operator= : (implicit out this, _val: i64) == "
                                            "_value = cpp2::unchecked_narrow<(underlying_type)$>(_val);");

    //  Generate the bitwise operations
    if bitwise {
        t.add_member( "    operator|=: ( inout this, that )                 == _value |= that._value;");
        t.add_member( "    operator&=: ( inout this, that )                 == _value &= that._value;");
        t.add_member( "    operator^=: ( inout this, that )                 == _value ^= that._value;");
        t.add_member( "    operator| : (       this, that ) -> (t.name())$  == _value |  that._value;");
        t.add_member( "    operator& : (       this, that ) -> (t.name())$  == _value &  that._value;");
        t.add_member( "    operator^ : (       this, that ) -> (t.name())$  == _value ^  that._value;");
        t.add_member( "    has       : (       this, that ) -> bool         == _value &  that._value;");
        t.add_member( "    set       : ( inout this, that )                 == { _value |= that._value;  }");
        t.add_member( "    clear     : ( inout this, that )                 == { _value &= that._value~; }");
    }

    //  Add the enumerators
    for enumerators do (e) {
        t.add_member( "    (e.name)$ : (t.name())$ == (e.value)$;");
    }

    //  Generate the common functions
    t.add_member( "    get_raw_value     : (this) -> (underlying_type)$ == _value;");
    t.add_member( "    operator=         : (out this) == { _value = (default_value)$._value; }");
    t.add_member( "    operator=         : (out this, that) == { }");
    t.add_member( "    operator<=>       : (this, that) -> std::strong_ordering;");

    //  Provide 'to_string' and 'to_code' functions to print enumerator
    //  name(s) as human-readable strings or as code expressions
    (copy to_string_impl: std::string = "    to_string_impl: (this, prefix: std::string_view")
    {
        if bitwise {
            to_string_impl += ", separator: std::string_view ) -> std::string = { \n"
                              "    ret : std::string = \"(\";\n"
                              "    sep : std::string = ();\n"
                              "    if this == none { return \"(none)\"; }\n";
        }
        else {
            to_string_impl += ") -> std::string = { \n";
        }

        to_string_impl += "    pref := cpp2::to_string(prefix);\n";

        for  enumerators
        do   (e) {
            if e.name != "_" {  // ignore unnamed values
                if bitwise {
                    if e.name != "none" {
                        to_string_impl += "    if (this & (t.name())$::(e.name)$) == (t.name())$::(e.name)$ { "
                                                  "ret += sep + pref + \"(e.name)$\"; sep = separator; "
                                              "}\n";
                    }
                }
                else {
                    to_string_impl += "    if this == (t.name())$::(e.name)$ { return pref + \"(e.name)$\"; }\n";
                }
            }
        }

        if bitwise {
            to_string_impl += "    return ret+\")\";\n}\n";
        }
        else {
            to_string_impl += "    return \"invalid (t.name())$ value\";\n}\n";
        }

        t.add_member( to_string_impl );
    }

    if bitwise {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\", \", \" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\", \" | \" );" );
    }
    else {
        t.add_member( "    to_string: (this) -> std::string = to_string_impl( \"\" );" );
        t.add_member( "    to_code  : (this) -> std::string = to_string_impl( \"(t.name())$::\" );" );
    }

    //  Provide a 'from_string' function to parse strings into enumerators    
    (copy from_string: std::string = "    from_string: (s: std::string_view) -> (t.name())$ = { \n")
    {
        prefix    : std::string_view = "";
        combine_op: std::string_view = "return";

        //  For flags, accept a list that we break apart and then |= together
        if bitwise 
        {
            prefix      = "flag_";
            combine_op  = "ret |=";

            from_string += "        ret := none;\n"
                           "        outer: do {\n"
                           "        for cpp2::string_util::split_string_list(s) do (x) {\n";
        }
        //  Otherwise, accept just a single string
        else {
            from_string += "        x := s;\n";
        }

        (copy else_: std::string_view = "")
        for  enumerators
        do   (e) {
            from_string += "            (else_)$if \"(e.name)$\" == x { (combine_op)$ (t.name())$::(e.name)$; }\n";
            else_ = "else ";
        }

        if bitwise {
            from_string += "            else { break outer; }\n"
                           "        }\n"
                           "        return ret;\n"
                           "        } while false;\n";
        }

        from_string += "        cpp2::type_safety.report_violation( (\"can't convert string '\" + cpp2::to_string(s) + \"' to (prefix)$enum of type (t.name())$\").c_str() );\n"
                       "        return (t.name())$::(default_value)$;\n"
                       "    }\n\n";

        t.add_member( from_string );
    }

    t.add_member( "    from_code: (s: std::string_view) -> (t.name())$ = { str: std::string = s; return from_string( cpp2::string_util::replace_all(str, \"(t.name())$::\", \"\" ) ); }" );
}


//-----------------------------------------------------------------------
//
//    "An enum[...] is a totally ordered value type that stores a
//     value of its enumerators's type, and otherwise has only public
//     member variables of its enumerator's type, all of which are
//     naturally scoped because they are members of a type."
//
//          -- P0707R4, section 3
//
enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with an incrementing value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                value = (v + 1) as std::string;
            }
        },
        false   // disable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "flag_enum expresses an enumeration that stores values
//      corresponding to bitwise-or'd enumerators. The enumerators must
//      be powers of two, and are automatically generated [...] A none
//      value is provided [...] Operators | and & are provided to
//      combine and extract values."
//
//          -- P0707R4, section 3
//
flag_enum: (inout t: meta::type_declaration) =
{
    //  Let basic_enum do its thing, with a power-of-two value generator
    t.basic_enum(
        :(inout value: std::string, specified_value: std::string) = {
            if !specified_value.empty() {
                value = specified_value;
            } else {
                v := std::strtoll(value[0]&, nullptr, 10);
                if v < 1 {
                    value = "1";
                }
                else {
                    value = (v * 2) as std::string;
                }
            }
        },
        true    // enable bitwise operations
    );
}


//-----------------------------------------------------------------------
//
//     "As with void*, programmers should know that unions [...] are
//      inherently dangerous, should be avoided wherever possible,
//      and should be handled with special care when actually needed."
//
//          -- Stroustrup (The Design and Evolution of C++, 14.3.4.1)
//
//     "C++17 needs a type-safe union... The implications of the
//      consensus `variant` design are well understood and have been
//      explored over several LEWG discussions, over a thousand emails,
//      a joint LEWG/EWG session, and not to mention 12 years of
//      experience with Boost and other libraries."
//
//          -- Axel Naumann, in P0088 (wg21.link/p0088),
//             the adopted proposal for C++17 std::variant
//
//-----------------------------------------------------------------------
//
//  union
//
//  a type that contains exactly one of a fixed set of values at a time
//

union: (inout t : meta::type_declaration)
= {
    alternatives : std::vector<value_member_info> = ();

    //  1. Gather: All the user-written members, and find/compute the max size

    (copy value := 0)
    for   t.get_members()
    next  value++
    do    (m)
    if    m.is_member_object()
    {
        m.require( m.is_public() || m.is_default_access(),
                   "a union alternative cannot be protected or private"
                );

        m.require( !m.name().starts_with("is_")
                   && !m.name().starts_with("set_"),
                   "a union alternative's name cannot start with 'is_' or 'set_' - that could cause "
                   "user confusion with the 'is_alternative' and 'set_alternative' generated functions"
                );

        mo := m.as_object();
        mo.require( mo.initializer().empty(),
                    "a union alternative cannot have an initializer"
                );

        //  Adding local variable 'e' to work around a Clang warning
        e: value_member_info = ( mo.name() as std::string, mo.type(), value as std::string );
        alternatives.push_back( e );

        mo.mark_for_removal_from_enclosing_type();
        _ = mo;
    }

    discriminator_type: std::string = ();
    if alternatives.ssize() < std::numeric_limits<i8>::max() {
        discriminator_type = "i8";
    }
    else if alternatives.ssize() < std::numeric_limits<i16>::max() {
        discriminator_type = "i16";
    }
    else if alternatives.ssize() < std::numeric_limits<i32>::max() {
        discriminator_type = "i32";
    }
    else {
        discriminator_type = "i64";
    }


    //  2. Replace: Erase the contents and replace with modified contents

    t.remove_marked_members();

    //  Provide storage
    (copy storage: std::string = "    _storage: cpp2::aligned_storage<cpp2::max( ")
    {
        for  alternatives
        do   (e) {
            storage += "sizeof((e.type)$), ";
        }

        storage += "), cpp2::max( ";

        for  alternatives
        do   (e) {
            storage += "alignof((e.type)$), ";
        }

        storage += " )> = ();\n";
        t.add_member( storage );
    }

    //  Provide discriminator
    t.add_member( "    _discriminator: (discriminator_type)$ = -1;\n");

    //  Add the alternatives: is_alternative, get_alternative, and set_alternative
    for alternatives
    do  (a)
    {
        t.add_member( "    is_(a.name)$: (this) -> bool = _discriminator == (a.value)$;\n");

        t.add_member( "    (a.name)$: (this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<* const (a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    (a.name)$: (inout this) -> forward (a.type)$ pre(is_(a.name)$()) = "
                            "reinterpret_cast<*(a.type)$>(_storage&)*;\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, _value: (a.type)$) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _value); } "
                            "else { reinterpret_cast<*(a.type)$>(_storage&)* = _value; } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );

        t.add_member( "    set_(a.name)$: (inout this, forward _args...: _) = { "
                            "if !is_(a.name)$() { _destroy(); std::construct_at( reinterpret_cast<*(a.type)$>(_storage&), _args...); } "
                            " else { reinterpret_cast<*(a.type)$>(_storage&)* = :(a.type)$ = (_args...); } "
                            "_discriminator = (a.value)$; "
                            "}\n"
                    );
    }

    //  Add destroy
    (copy destroy: std::string = "    private _destroy: (inout this) = {\n")
    {
        for  alternatives
        do   (a) {
            destroy += "        if _discriminator == (a.value)$ { std::destroy_at( reinterpret_cast<*(a.type)$>(_storage&) ); }\n";
        }

        destroy += "        _discriminator = -1;\n"
                   "    }\n";
        t.add_member( destroy );
    }

    //  Add the destructor
    t.add_member( "    operator=: (move this) = { _destroy(); _ = this; }" );

    //  Add default constructor
    t.add_member( "    operator=: (out this) = { }" );

    //  Add copy/move construction and assignment
    (copy value_set: std::string = "")
    {
        for  alternatives
        do   (a) {
            value_set += "        if that.is_(a.name)$() { set_(a.name)$( that.(a.name)$() ); }\n";
        }
        value_set += "    }\n";

        t.add_member( "    operator=: (out this, that) = {\n"
                      "        _storage = ();\n"
                      "        _discriminator = -1;\n"
                      + value_set
                    );
        t.add_member( "    operator=: (inout this, that) = {\n"
                      "        _storage = _;\n"
                      "        _discriminator = _;\n"
                      + value_set
                    );
    }
}


//-----------------------------------------------------------------------
//
//  print - output a pretty-printed visualization of t
//
print: (t: meta::type_declaration) =
{
    std::cout << t.print() << "\n";
}


//-----------------------------------------------------------------------
//
//  noisy - make each function print its name and signature,
//          so the programmer can see what's called
//
noisy: (t: meta::type_declaration) =
{
    for t.get_members()
    do  (m)
    if  m.is_function()
        && !m.has_name("operator=")
    {
        mf := m.as_function();
        if mf.has_compound_body() {
            body := mf.get_compound_body();
            body.add_statement( "    std::cout << \"(mf.get_signature())$\\n\";" );
            _ = body;
        }
    }
}


//-----------------------------------------------------------------------
//
//  python - expose the type using pybind11
// 
//  *** Basic proof of concept only, limited and not well tested
//      Hardcoded for pybind11 and g++10 and my local cppfront include path
//
python_param_names_and_types: (mf: meta::function_declaration)
    -> 
    (
    names: std::string = (),
    types: std::string = ()
    ) 
= {
    for mf.get_parameters()
    do  (param)
    if  param.get_declaration().name() != "this"
    {
        names += ", ";
        if !types.empty() {
            types += ", ";
        }
        names += std::string("pybind11::arg(\"") + param.get_declaration().name() + "\")";
        types += param.get_declaration().type();
    }
}

python: (inout t: meta::type_declaration) =
{
    bind: std::string = ();
    bind += "PYBIND11_MODULE((t.name())$lib, m) {\n";
    bind += "    pybind11::class_<(t.name())$>(m, \"(t.name())$\")\n";

    for t.get_members()
    do  (m)
    if  m.is_function()
    {
        mf := m.as_function();
        params := mf.python_param_names_and_types();

        if mf.is_constructor() {
            bind += "        .def(pybind11::init<(params.types)$>())\n";
        }
        else if !mf.has_name("operator=") {
            bind += "        .def(\"(mf.name())$\", &(t.name())$::(mf.name())$ (params.names)$)\n";
        }
    }

    bind += "    ;\n";
    bind += "}\n";

    file := t.filename();
    if file.ends_with(".cpp2") {
        file = file.substr(0, file.size()-5);    // drop the ".cpp2"
    }
    build: std::string = "g++-10 -O3 -shared -std=c++20 -fPIC $(python3 -m pybind11 --includes) (file)$.cpp -o (file)$lib$(python3-config --extension-suffix)";

    t.add_runtime_support_include( "pybind11/pybind11.h", true );
    t.add_runtime_support_include( "pybind11/stl.h", true );
    t.add_extra_cpp1_code        ( bind );
    t.add_extra_build_step       ( build );
}


//-----------------------------------------------------------------------
//
//  javascript - expose the type using emscripten
// 
//  *** Basic proof of concept only, limited and not well tested
//
javascript: (inout t: meta::type_declaration) =
{
    bind: std::string = ();
    bind += "using namespace emscripten;\n";
    bind += "EMSCRIPTEN_BINDINGS((t.name())$_module) {\n";
    bind += "    class_<(t.name())$>(\"(t.name())$\")\n";

    for t.get_members()
    do  (m)
    if  m.is_function()
    {
        mf := m.as_function();
        params := mf.python_param_names_and_types(); // good enough! only care about .types

        if mf.is_constructor() {
            bind += "        .constructor<(params.types)$>()\n";
        }
        else if !mf.has_name("operator=") {
            bind += "        .function(\"(mf.name())$\", &(t.name())$::(mf.name())$)\n";
        }
    }

    bind += "    ;\n";
    bind += "}\n";

    file := t.filename();
    if file.ends_with(".cpp2") {
        file = file.substr(0, file.size()-5);    // drop the ".cpp2"
    }
    build: std::string = "em++ -std=c++20 -O3 (file)$.cpp --bind -s MODULARIZE=1 -s ENVIRONMENT='web,node' -s ALLOW_MEMORY_GROWTH=1 -s FILESYSTEM=0 -s LEGACY_VM_SUPPORT=1 -o (file)$.js";
    t.add_runtime_support_include( "emscripten/bind.h", true );
    t.add_extra_cpp1_code        ( bind );
    t.add_extra_build_step       ( build );
    t.disable_ref_qualifier_generation();
}


//-----------------------------------------------------------------------
//
//  For reflection test cases
//
sample_print: (s: std::string_view, indent: i32) =
{
    std::cout
        << pre(indent)
        << s
        << "\n";
}

simple_traverser: type = {

    pre_traverse: (virtual inout this, decl: meta::declaration) = {
        traverse(decl);
    }

    traverse: (virtual inout this, decl: meta::declaration) =
    {
        if decl.is_function() {
            pre_traverse(decl.as_function());
        }

        if decl.is_object() {
            pre_traverse(decl.as_object());
        }

        if decl.is_type() {
            pre_traverse(decl.as_type());
        }

        // ...
        // ... extend as desired to namespace, alias, etc.
        // ...
    }


    pre_traverse: (virtual inout this, f: meta::function_declaration) = {
        traverse(f);
    }

    traverse: (virtual inout this, f: meta::function_declaration) =
    {
        parameters := f.get_parameters();
        for parameters do (param) {
            pre_traverse(param);
        }

        returns := f.get_returns();
        for returns do (param) {
            pre_traverse(param);
        }

        if !f.has_compound_body() {
            pre_traverse(f.get_body());
        }
        else {
            pre_traverse(f.get_compound_body());
        }
    }


    pre_traverse: (virtual inout this, o: meta::object_declaration) = {
        traverse(o);
    }

    traverse: (virtual inout this, o: meta::object_declaration) =
    {
        if o.has_initializer() {
            pre_traverse(o.get_initializer());
        }
    }


    pre_traverse: (virtual inout this, t: meta::type_declaration) = {
        traverse(t);
    }

    traverse: (virtual inout this, t: meta::type_declaration) =
    {
        for t.get_members() do (m) {
            pre_traverse(m);
        }
    }


    pre_traverse: (virtual inout this, t: meta::parameter_declaration) = {
        traverse(t);
    }

    traverse: (virtual inout this, t: meta::parameter_declaration) =
    {
        pre_traverse(t.get_declaration());
    }

    pre_traverse: (virtual inout this, stmt: meta::statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::statement) =
    {
        if stmt.is_expression_statement() {
            pre_traverse(stmt.as_expression_statement().get_expression());
        }

        if stmt.is_compound_statement() {
            pre_traverse(stmt.as_compound_statement());
        }

        if stmt.is_selection_statement()
        {
            pre_traverse(stmt.as_selection_statement());
        }

        if stmt.is_declaration() {
            pre_traverse(stmt.as_declaration());
        }

        if stmt.is_return_statement() {
            pre_traverse(stmt.as_return_statement());
        }

        if stmt.is_iteration_statement() {
            pre_traverse(stmt.as_iteration_statement());
        }

        // TODO:
        //  using
        //  contract
        //  inspect
        //  jump
    }


    pre_traverse: (virtual inout this, stmt: meta::compound_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::compound_statement) =
    {
        stmts := stmt.get_statements();

        for stmts do (cur) {
            pre_traverse(cur);
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::return_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::return_statement) =
    {
        if stmt.has_expression() {
            pre_traverse(stmt.get_expression());
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::iteration_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::iteration_statement) =
    {
        if stmt.is_do() || stmt.is_while() {
            pre_traverse(stmt.get_do_while_condition());
            pre_traverse(stmt.get_do_while_body());
        }
        else {
            assert(stmt.is_for());
            pre_traverse(stmt.get_for_range());
            pre_traverse(stmt.get_for_parameter());
            pre_traverse(stmt.get_for_body());
        }

        if stmt.has_next() {
            pre_traverse(stmt.get_next_expression());
        }
    }


    pre_traverse: (virtual inout this, stmt: meta::selection_statement) = {
        traverse(stmt);
    }

    traverse: (virtual inout this, stmt: meta::selection_statement) =
    {
        pre_traverse(stmt.get_expression());
        pre_traverse(stmt.get_true_branch());

        if stmt.has_false_branch() {
            pre_traverse(stmt.get_false_branch());
        }
    }


    pre_traverse: (virtual inout this, expr: meta::expression) =
    {
        // Nothing to select here.
        traverse(expr);
    }

    traverse: (virtual inout this, expr: meta::expression) =
    {
        //  An expression has other shortcuts to query deeper properties,
        //  but let's just traverse all the nested grammer elements to
        //  show how that traversal works

        // The expressions use the pre_traverse function to decide which expression
        // they are. The correct one calls traverse only once.

        //  The expression's basic payload is just an assignment expression
        pre_traverse(expr.as_assignment_expression());
    }


    pre_traverse: (virtual inout this, binexpr: meta::assignment_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual assignment,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::assignment_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::logical_or_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual logical-or,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::logical_or_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::logical_and_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual logical-and,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::logical_and_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::bit_or_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-or,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_or_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::bit_xor_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-xor,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_xor_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::bit_and_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual bit-and,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::bit_and_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::equality_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual equality,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::equality_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::relational_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual relational,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::relational_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::compare_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual compare,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::compare_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::shift_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual shift,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::shift_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, binexpr: meta::additive_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual additive,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::additive_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }


    pre_traverse: (virtual inout this, binexpr: meta::multiplicative_expression) =
    {
        terms := binexpr.get_terms();
        assert(!terms.empty());

        //  If this has only one term, it's not an actual multiplicative,
        //  it's holding a lower grammar production so go traverse that
        if terms.ssize() == 1 {
            pre_traverse(terms.front().get_term());
        }

        //  Else we're at an actual binary expression with a rhs
        else {
            traverse(binexpr);
        }
    }

    traverse: (virtual inout this, binexpr: meta::multiplicative_expression) =
    {
        terms := binexpr.get_terms();

        for terms
        do  (term)
        {
            traverse(term.get_term());
        }
    }

    pre_traverse: (virtual inout this, isas: meta::is_as_expression) =
    {
        terms := isas.get_terms();

        //  If this has no additional terms, it's not an actual is-as,
        //  it's holding a lower grammar production so go traverse that
        if terms.empty() {
            pre_traverse(isas.get_expression());
        }

        //  Else we're at an actual is-as expression with a rhs
        else {
            traverse(isas);
        }
    }

    traverse: (virtual inout this, isas: meta::is_as_expression) =
    {
        terms := isas.get_terms();

        pre_traverse(isas.get_expression());

        for terms do (term) {
            traverse(term.get_expr());
        }
    }

    traverse: (virtual inout this, exprs: meta::expression_list) =
    {
        for exprs.get_expressions() do (expr) {
            traverse(expr);
        }
    }

    pre_traverse: (virtual inout this, prefix: meta::prefix_expression) =
    {
        ops := prefix.get_ops();

        //  If this has no additional ops, it's not a naked prefix expr,
        //  it's holding a lower grammar production so go traverse that
        if ops.empty() {
            pre_traverse(prefix.get_postfix_expression(),);
        }

        //  Else we're at an actual prefix expression with ops
        else {
            traverse(prefix);
        }
    }

    traverse: (virtual inout this, prefix: meta::prefix_expression) =
    {
        pre_traverse(prefix.get_postfix_expression());
    }

    pre_traverse: (virtual inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        //  If this has no additional terms, it's not a naked postfix expr,
        //  it's holding a lower grammar production so go traverse that
        if terms.empty() {
            traverse(postfix.get_primary_expression());
        }

        //  Else we're at an actual postfix expression with ops
        else {
            traverse(postfix);
        }
    }

    traverse: (virtual inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        traverse(postfix.get_primary_expression());

        for terms do (term) {
            if term.is_id_expression() {
                traverse(term.get_id_expression());
            }
            else if term.is_expression_list() {
                traverse(term.get_expression_list());
            }
            else if term.is_expression() {
                traverse(term.get_expression());
            }
        }
    }

    traverse: (virtual inout this, uid: meta::unqualified_id) =
    {
        _ = uid;
    }


    traverse: (virtual inout this, qid: meta::qualified_id) =
    {
        for qid.get_terms()
        do  (term)
        {
            traverse(term.get_unqualified());
        }
    }


    traverse: (virtual inout this, tid: meta::type_id) =
    {
        if tid.is_postfix_expression() {
            traverse(tid.as_postfix_expression());
        }
        else if tid.is_qualified_id() {
            traverse(tid.as_qualified_id());
        }
        else if tid.is_unqualified_id() {
            traverse(tid.as_unqualified_id());
        }
        else {
            // Regular type_id
        }
    }


    traverse: (virtual inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            // Regular identifier
        }
        else if primary.is_expression_list() {
            traverse(primary.as_expression_list());
        }
        else if primary.is_literal() {
            // Regular literal
        }
        else if primary.is_declaration() {
            // TODO: traverse(primary.as_declaration());
        }
        else {
            // Regular primary
        }
    }


    traverse: (virtual inout this, idexpr: meta::id_expression) =
    {
        if idexpr.is_identifier() {
            // Regular id
        }
        else if idexpr.is_qualified() {
            traverse(idexpr.as_qualified());
        }
        else if idexpr.is_unqualified() {
            traverse(idexpr.as_unqualified());
        }
        else {
            // Regular id expr
        }
    }
}


//-----------------------------------------------------------------------
//
//  sample_traverser serves two purposes:
// 
//      - infrastructure for writing reflection API test cases
// 
//      - a sample for how code can use the reflection API, notably
//        for reflecting on function bodies (statements, expressions)
//

sample_traverser: (decl: meta::declaration, indent: i32) =
{
    sample_print("Declaration: (decl.name())$", indent);

    if decl.is_function() {
        sample_traverser(decl.as_function(), indent+1);
    }

    if decl.is_object() {
        sample_traverser(decl.as_object(), indent+1);
    }

    if decl.is_type() {
        sample_traverser(decl.as_type(), indent+1);
    }

    // ...
    // ... extend as desired to namespace, alias, etc.
    // ...
}


sample_traverser: (f: meta::function_declaration, indent: i32 = 0) =
{
    sample_print("Function: (f.name())$", indent+1);

    parameters := f.get_parameters();
    if !parameters.empty() {
        sample_print("Parameters:", indent+2);
        for parameters do (param) {
            sample_traverser(param, indent+3);
        }
    }

    returns := f.get_returns();
    if !returns.empty() {
        sample_print("Returns:", indent+2);
        for returns do (param) {
            sample_traverser(param, indent+3);
        }
    }

    sample_print("Body:", indent+2);
    if !f.has_compound_body() {
        sample_traverser(f.get_body(), indent+3);
    }
    else {
        sample_traverser(f.get_compound_body(), indent+3);
    }
}


sample_traverser: (o: meta::object_declaration, indent: i32) =
{
    sample_print("Object: name (o.name())$, type (o.type())$", indent);
    if o.has_initializer() {
        sample_print("Initializer:", indent+1);
        sample_traverser(o.get_initializer(), indent+2);
    }
}


sample_traverser: (t: meta::type_declaration, indent: i32 = 0) =
{
    sample_print("Type: (t.name())$", indent);

    if t.parent_is_nonglobal_namespace() 
    {
        ns := t.get_parent().as_nonglobal_namespace();
        sample_print("is a member of namespace (ns.name())$ which contains the following names:", indent+1);
        for ns.get_members() do (m) {
            sample_print(m.name(), indent+2);
        }
        ns.add_member( "add_1: (x) = x+1;");
        _ = ns;
    }

    for t.get_members() do (m) {
        sample_traverser(m, indent+1);
    }
}


sample_traverser: (t: meta::parameter_declaration, indent: i32 = 0) =
{
    sample_print("parameter:", indent);

    pass := t.get_passing_style();
    if pass == passing_style::in          { sample_print("passing style: in", indent+1 ); }
    if pass == passing_style::in_ref      { sample_print("passing style: in_ref", indent+1 ); }
    if pass == passing_style::copy        { sample_print("passing style: copy", indent+1 ); }
    if pass == passing_style::inout       { sample_print("passing style: inout", indent+1 ); }
    if pass == passing_style::out         { sample_print("passing style: out", indent+1 ); }
    if pass == passing_style::move        { sample_print("passing style: move", indent+1 ); }
    if pass == passing_style::forward     { sample_print("passing style: forward", indent+1 ); }
    if pass == passing_style::forward_ref { sample_print("passing style: forward_ref", indent+1 ); }

    sample_print("declaration:", indent+1);
    sample_traverser(t.get_declaration(), indent+2);
}


sample_traverser: (stmt: meta::statement, indent: i32) =
{
    params := stmt.get_parameters();
    if !params.empty() {
        sample_print("statement parameters: ", indent);
        for params do (param) {
            sample_traverser( param, indent+1 );
        }
    }

    if stmt.is_expression_statement() {
        sample_traverser(stmt.as_expression_statement().get_expression(), indent);
    }

    if stmt.is_compound_statement() {
        sample_traverser(stmt.as_compound_statement(), indent);
    }

    if stmt.is_selection_statement()
    {
        sel := stmt.as_selection_statement();
        sample_print("(sel.get_identifier())$ statement", indent);

        sample_print("condition:", indent+1);
        sample_traverser(sel.get_expression(), indent+2);

        sample_print("true branch:", indent+1);
        sample_traverser(sel.get_true_branch(), indent+2);
        
        if sel.has_false_branch() {
            sample_print("false branch:", indent+1);
            sample_traverser(sel.get_false_branch(), indent+2);
        }
    }

    if stmt.is_declaration() {
        sample_traverser(stmt.as_declaration(), indent+1);
    }

    if stmt.is_return_statement() {
        sample_traverser(stmt.as_return_statement(), indent+1);
    }

    if stmt.is_iteration_statement() {
        sample_traverser(stmt.as_iteration_statement(), indent+1);
    }

    // TODO:
    //  using
    //  contract
    //  inspect
    //  jump
}


sample_traverser: (stmt: meta::compound_statement, indent: i32) =
{
    stmts := stmt.get_statements();

    if stmts.empty() {
        sample_print("compound statement (empty)", indent);
        return;
    }

    // Else
    sample_print("compound statement", indent);
    for stmts do (stmt2) {
        sample_traverser(stmt2, indent+1);
    }
}


sample_traverser: (stmt: meta::return_statement, indent: i32) =
{
    sample_print("return statement", indent);
    if stmt.has_expression() {
        sample_print("expression", indent+1);
        sample_traverser(stmt.get_expression(), indent+2);
    }
}


sample_traverser: (stmt: meta::iteration_statement, indent: i32) =
{
    if stmt.is_do() || stmt.is_while() {
        if stmt.is_do() {
            sample_print("do loop:", indent);
        }
        else {
            sample_print("while loop:", indent);
        }
        sample_print("condition:", indent+1);
        sample_traverser(stmt.get_do_while_condition(), indent+2);
        sample_print("body:", indent+1);
        sample_traverser(stmt.get_do_while_body(), indent+2);
    }
    else {
        assert(stmt.is_for());
        sample_print("for loop:", indent);
        sample_print("range:", indent+1);
        sample_traverser(stmt.get_for_range(), indent+2);
        sample_print("parameter:", indent+1);
        sample_traverser(stmt.get_for_parameter(), indent+2);
        sample_print("body:", indent+1);
        sample_traverser(stmt.get_for_body(), indent+2);
    }

    if stmt.has_next() {
        sample_print("next expression:", indent+1);
        sample_traverser(stmt.get_next_expression(), indent+2);
    }
}


sample_traverser: (expr: meta::expression, indent: i32) =
{
    //  An expression has other shortcuts to query deeper properties,
    //  but let's just traverse all the nested grammar elements to
    //  show how that traversal works

    //  The expression's basic payload is just an assignment expression
    //  today - this can change when we add try-expressions
    if expr.is_assignment_expression() {
        sample_traverser(expr.as_assignment_expression(), indent);
    }
}


sample_traverser: (binexpr: meta::assignment_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual assignment,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("assignment", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::logical_or_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual logical-or,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("logical-or", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::logical_and_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual logical-and,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("logical-and", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_or_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-or,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-or", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_xor_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-xor,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-xor", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::bit_and_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual bit-and,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("bit-and", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::equality_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual equality,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("equality", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::relational_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual relational,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("relational", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::compare_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual compare,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("compare", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::shift_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual shift,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("shift", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::additive_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual additive,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("additive", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (binexpr: meta::multiplicative_expression, indent: i32) =
{
    terms := binexpr.get_terms();
    assert(!terms.empty());

    //  If this has only one term, it's not an actual multiplicative,
    //  it's holding a lower grammar production so go traverse that
    if terms.ssize() == 1 {
        sample_traverser(terms.front().get_term(), indent);
    }

    //  Else we're at an actual binary expression with a rhs
    else {
        sample_print("multiplicative", indent);

        (copy first := true)
        for terms
        do  (term)
        {
            if !first {
                sample_print("op: (term.get_op())$", indent+1);
            }
            first = false;
            sample_print("term:", indent+1);
            sample_traverser(term.get_term(), indent+2);
        }
    }
}


sample_traverser: (isas: meta::is_as_expression, indent: i32) =
{
    terms := isas.get_terms();

    //  If this has no additional terms, it's not an actual is-as,
    //  it's holding a lower grammar production so go traverse that
    if terms.empty() {
        sample_traverser(isas.get_expression(), indent);
    }

    //  Else we're at an actual is-as expression with a rhs
    else {
        sample_print("is-as expression", indent);

        sample_print("expression", indent+1);
        sample_traverser(isas.get_expression(), indent+2);

        for terms do (term) {
            sample_print("op: (term.get_op())$", indent+1);
            sample_print("term:", indent+1);
            sample_traverser(term.get_expr(), indent+2);
        }
    }
}


sample_traverser: (exprs: meta::expression_list, indent: i32) =
{
    if exprs.is_empty() {
        sample_print("()", indent);
    }
    else {
        sample_print("(", indent);
        for exprs.get_expressions() do (expr) {
            sample_traverser(expr, indent+1);
        }
        sample_print(")", indent);
    }
}


sample_traverser: (prefix: meta::prefix_expression, indent: i32) =
{
    ops := prefix.get_ops();

    //  If this has no additional ops, it's not a naked prefix expr,
    //  it's holding a lower grammar production so go traverse that
    if ops.empty() {
        sample_traverser(prefix.get_postfix_expression(), indent);
    }

    //  Else we're at an actual prefix expression with ops
    else {
        sample_print("prefix expression", indent);

        for ops do (op) {
            sample_print("op: (op)$", indent+1);
        }

        sample_print("expression", indent+1);
        sample_traverser(prefix.get_postfix_expression(), indent+2);
    }
}


sample_traverser: (postfix: meta::postfix_expression, indent: i32) =
{
    terms := postfix.get_terms();

    //  If this has no additional terms, it's not a naked postfix expr,
    //  it's holding a lower grammar production so go traverse that
    if terms.empty() {
        sample_traverser(postfix.get_primary_expression(), indent);
    }

    //  Else we're at an actual postfix expression with ops
    else {
        sample_print("postfix expression", indent);

        sample_print("expression", indent+1);
        sample_traverser(postfix.get_primary_expression(), indent+2);

        for terms do (term) {
            sample_print("op: (term.get_op())$", indent+1);
            if term.is_id_expression() {
                sample_traverser(term.get_id_expression(), indent+1);
            }
            else if term.is_expression_list() {
                sample_traverser(term.get_expression_list(), indent+1);
            }
            else if term.is_expression() {
                sample_traverser(term.get_expression(), indent+1);
            }
        }
    }
}


sample_traverser: (uid: meta::unqualified_id, indent: i32) =
{
    if uid.is_identifier() {
        sample_print(uid.get_identifier(), indent);
    }
    else {
        sample_print(uid.to_string(), indent+1);
    }
}


sample_traverser: (qid: meta::qualified_id, indent: i32) =
{
    (copy first := true)
    for qid.get_terms()
    do  (term)
    {
        if !first {
            sample_print("op: (term.get_op())$", indent+1);
        }
        first = false;
        sample_print("unqualified:", indent+1);
        sample_traverser(term.get_unqualified(), indent+2);
    }
}


sample_traverser: (tid: meta::type_id, indent: i32) =
{
    if tid.is_postfix_expression() {
        sample_traverser(tid.as_postfix_expression(), indent);
    }
    else if tid.is_qualified_id() {
        sample_traverser(tid.as_qualified_id(), indent);
    }
    else if tid.is_unqualified_id() {
        sample_traverser(tid.as_unqualified_id(), indent);
    }
    else {
        sample_print(tid.to_string(), indent);
    }
}


sample_traverser: (primary: meta::primary_expression, indent: i32) =
{
    if primary.is_identifier() {
        sample_print(primary.as_identifier(), indent+1);
    }
    else if primary.is_expression_list() {
        sample_traverser(primary.as_expression_list(), indent+1);
    }
    else if primary.is_literal() {
        sample_print(primary.as_literal(), indent+1);
    }
    else if primary.is_declaration() {
        sample_traverser(primary.as_declaration(), indent+1);
    }
    else {
        sample_print(primary.to_string(), indent+1);
    }
}


sample_traverser: (idexpr: meta::id_expression, indent: i32) =
{
    if idexpr.is_identifier() {
        sample_print(idexpr.as_identifier(), indent+1);
    }
    else if idexpr.is_qualified() {
        sample_traverser(idexpr.as_qualified(), indent+1);
    }
    else if idexpr.is_unqualified() {
        sample_traverser(idexpr.as_unqualified(), indent+1);
    }
    else {
        sample_print(idexpr.to_string(), indent+1);
    }
}


//-----------------------------------------------------------------------
//
//  autodiff
//

autodiff_special_func: type = {
    public name      : std::string;
    public n_args    : int;
    public is_member : bool;

    public code_primal             : std::string;
    public code_fwd                : std::string;
    public code_rws                : std::string;
    public code_primal_higher_order: std::string;
    public code_fwd_higher_order   : std::string;
    public code_rws_higher_order   : std::string;

    operator=: (out this, name_: std::string, n_args_: int, is_member_: bool, code_primal_: std::string = "", code_fwd_: std::string = "",
                          code_rws_: std::string = "", code_primal_higher_order_: std::string = "", code_fwd_higher_order_: std::string = "",
                          code_rws_higher_order_: std::string = "") = {
        name      = name_;
        n_args    = n_args_;
        is_member = is_member_;

        code_primal              = code_primal_;
        code_fwd                 = code_fwd_;
        code_rws                 = code_rws_;
        code_primal_higher_order = code_primal_higher_order_;
        code_fwd_higher_order    = code_fwd_higher_order_;
        code_rws_higher_order    = code_rws_higher_order_;

        if code_primal_higher_order.empty() {
            code_primal_higher_order = code_primal;
        }
        if code_fwd_higher_order.empty() {
            code_fwd_higher_order = code_fwd;
        }
        if code_rws_higher_order.empty() {
            code_rws_higher_order = code_rws;
        }
    }

    operator=: (out this, that) = {} // Default copy.

    is_match: (this, o: autodiff_special_func) -> bool = {
        return name == o.name && n_args == o.n_args && is_member == o.is_member;
    }
}

autodiff_declared_variable: @copy_constructible type = {
    public name     : std::string = "";
    public decl     : std::string = ""; // TODO: Maybe use variant here.
    public is_active: bool        = false;
    public is_member: bool        = false;

    operator=:(out this) = {}

    operator=:(out this, name_: std::string, decl_: std::string, is_active_: bool, is_member_: bool) = {
        name      = name_;
        decl      = decl_;
        is_active = is_active_;
        is_member = is_member_;
    }

    operator=:(out this, that) = {}
}

autodiff_declaration_stack_item: @copy_constructible type = {
    public full_name:   std::string;  // namespace + type name
    public decl: meta::type_or_namespace_declaration;

    public diff_request: std::vector<meta::declaration> = ();
    public diff_done:    std::vector<meta::declaration> = ();

    public declared_variables_stack: std::vector<std::vector<autodiff_declared_variable>> = (1);

    operator=: (out this, full_name_: std::string, decl_: meta::type_or_namespace_declaration) = {
        full_name = full_name_;
        decl      = decl_;
    }

    lookup_declaration: (this, decl_name: std::string) -> (r: std::vector<meta::declaration> = ()) = {
        for decl.get_members() do (cur) {
            if cur.has_name() && decl_name  == cur.name() {
                r.push_back(cur);

                // Do not break for overloads. <3
            }
        }
    }

    lookup_variable_declaration: (this, decl_name: std::string) -> (found: bool = false, r: autodiff_declared_variable = ()) = {
        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur_context := declared_variables_stack.rbegin())
        while cur_context != declared_variables_stack.rend()
        next  cur_context++
        {
            for cur_context* do (cur) {
                if cur.name == decl_name {
                    found = true;
                    r = cur;
                    return;
                }
            }
        }
    }


}

autodiff_context: type = {
    private temporary_count : int = 0;

    // Code in special function is replaced. Placeholders are:
    //   _o_  : name of object for member functions.
    //   _o_  : name of derivative object for member functions.
    //   _a1_ : First argument value
    //   _ad1_: First derivative argument value
    //   _a2_ : Second argument value
    //   _ad2_: Second derivative argument value
    public special_funcs : std::vector<autodiff_special_func> = (
        autodiff_special_func("sin", 1, /* is_member = */ false,
            "sin(_a1_)",
            "cos(_a1_) * _ad1_",
            "_ab1_ += cos(_a1_) * _rb_;\n",
            "sin(_a1_)",
            "_ad1_.sin(_a1_)",
            "TODO",

        ),
        autodiff_special_func("cos", 1, /* is_member = */ false,
            "cos(_a1_)",
            "-sin(_a1_) * _ad1_",
            "_ab1_ += -sin(_a1_) * _rb_;\n",
            "cos(_a1_)",
            "_ad1_.cos(_a1_)",
            "TODO",
        ),
        autodiff_special_func("exp", 1, /* is_member = */ false,
            "exp(_a1_)",
            "exp(_a1_) * _ad1_",
            "_ab1_ += exp(_a1_) * _rb_;\n",
            "exp(_a1_)",
            "_ad1_.exp(_a1_)",
            "TODO",
        ),
        autodiff_special_func("sqrt", 1, /* is_member = */ false,
            "sqrt(_a1_)",
            "0.5 * _ad1_ / sqrt(_a1_)",
            "_ab1_ += 0.5 * _rb_ / sqrt(_a1_);\n",
            "sqrt(_a1_)",
            "_ad1_.sqrt(_a1_)",
            "TODO",
        ),
        autodiff_special_func("push_back", 1, /* is_member = */ true,
            "_o_.push_back(_a1_);",
            "_od_.push_back(_ad1_);",
            "TODO")
    );

    public  fwd_suffix : std::string = "_d";
    public  rws_suffix : std::string = "_b";
    private order  : int         = 1;
    public  reverse: bool        = false;

    // Members depending on order
    public fwd_ad_type: std::string = "double";
    public rws_ad_type: std::string = "double";

    public declaration_map  : std::map<std::string, std::vector<meta::declaration>> = ();
    public declaration_stack: std::vector<autodiff_declaration_stack_item> = ();

    operator=:(out this) = {}
    operator=:(out this, order_: int, reverse_: bool) = {
        order = order_;
        reverse = reverse_;

        if 1 != order {
            if reverse {
                fwd_ad_type = "cpp2::taylor<double, (order-1)$>";
                rws_ad_type = "cpp2::taylor<double, (order)$>";
            }
            else {
                fwd_ad_type = "cpp2::taylor<double, (order)$>";
            }
        }

    }

    add_variable_declaration: (inout this, name: std::string, type: std::string, is_active: bool, is_member: bool = false) = {
        declaration_stack.back().declared_variables_stack.back().push_back(autodiff_declared_variable(name, type, is_active, is_member));
    }

    is_variable_active: (inout this, name: std::string) -> bool = {
        return lookup_variable_declaration(name).is_active;
    }

    create_namespace_stack: (inout this, t: meta::type_or_namespace_declaration) = {
        if t.parent_is_nonglobal_namespace() {
            create_namespace_stack(t.get_parent().as_nonglobal_namespace());
        }
        else if t.parent_is_type() {
            create_namespace_stack(t.get_parent().as_type());
        }

        full_name: std::string = "::";
        if !declaration_stack.empty() {
            full_name = declaration_stack.back().full_name + "::";
        }
        full_name += t.name();

        _ = declaration_stack.push_back(autodiff_declaration_stack_item(full_name, t));
    }

    is_forward: (this) = !reverse || (reverse && order != 1);
    is_reverse: (this) = reverse;
    is_taylor : (this) = order != 1;

    gen_temporary : (inout this) -> std::string = {
        temporary_count += 1;
        return "temp_(temporary_count)$";
    }

    is_type_active: (inout this, type: std::string) -> bool = {
        decls := lookup_type_declaration(type);
        r := false;

        if !decls.empty() {
            assert(decls.ssize() == 1);
            ada: autodiff_activity_check = (this&);
            ada.pre_traverse(decls[0]);
            r = ada.active;
        }

        // TODO: Add template activity lookup.

        if !r {
            // Declaration lookup did not yield an activity: Apply some heuristics.
            r = type.contains("double");
        }

        return r;
    }

    get_fwd_ad_type: (inout this, type: std::string) -> std::string = {
        type_d := type;

        if "double" != type {
            type_decls := lookup_type_declaration(type);
            if !type_decls.empty() {
                // We found a cpp2 type declaration, mark it for differentiation.
                add_for_differentiation(type_decls[0]);

                // Add the AD suffix to the type
                type_d += fwd_suffix;
            }
        }

        // Replace with AD type for the AD order.
        return string_util::replace_all(type_d, "double", fwd_ad_type);
    }

    get_rws_ad_type: (inout this, type: std::string) -> std::string = {
        type_d := type;

        if "double" != type {
            type_decls := lookup_type_declaration(type);
            if !type_decls.empty() {
                // We found a cpp2 type declaration, mark it for differentiation.
                add_for_differentiation(type_decls[0]);

                // Add the AD suffix to the type
                type_d += rws_suffix;
            }
        }

        // Replace with AD type for the AD order.
        return string_util::replace_all(type_d, "double", rws_ad_type);
    }

    get_reverse_passing_style: (this, p: passing_style) -> passing_style = {
        // TODO: inspect does not work here: error: error: no matching function for call to ‘is<cpp2::passing_style::in>(const cpp2::passing_style&)’
        // return inspect p -> passing_style  {
        //     is passing_style::in          = passing_style::inout;
        //     is passing_style::in_ref      = passing_style::inout;
        //     is passing_style::copy        = passing_style::inout;
        //     is passing_style::inout       = passing_style::inout;
        //     is passing_style::out         = passing_style::inout;
        //     is passing_style::move        = passing_style::inout;
        //     is passing_style::forward     = passing_style::inout;
        //     is passing_style::forward_ref = passing_style::inout;
        //     is _                          = passing_style::inout;
        // };
        if p == passing_style::in          { return  passing_style::inout; }
        if p == passing_style::in_ref      { return  passing_style::inout; }
        if p == passing_style::copy        { return  passing_style::inout; }
        if p == passing_style::inout       { return  passing_style::inout; }
        if p == passing_style::out         { return  passing_style::inout; }
        if p == passing_style::move        { return  passing_style::inout; }
        if p == passing_style::forward     { return  passing_style::inout; }
        if p == passing_style::forward_ref { return  passing_style::inout; }


        declaration_stack.back().decl.error("AD: Do not know how to handle passing style:(p)$");

        return  passing_style::inout;
    }

    lookup_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::declaration> = ()) = {
        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur := declaration_stack.rbegin())
        while cur != declaration_stack.rend()
        next  cur++
        {
            cur_full_name : std::string = cur*.full_name + "::" + decl_name;
            ele := declaration_map.find(cur_full_name);
            if ele == declaration_map.end() {
                ele = declaration_map.insert_or_assign(cur_full_name, cur*.lookup_declaration(decl_name)).first;
            }

            if !ele*.second.empty() {
                // A simple assignment or emplace_back did not work. It tired to use move copy operators.
                for ele*.second do (cp) {
                    r.push_back(cp);
                }
                //r = ele*.second;
                break;
                // TODO: For overload resolution we may want to continue here and just add everything for all parent namespaces.
            }
        }

        return;
    }

    lookup_variable_declaration: (inout this, name: std::string) -> autodiff_declared_variable = {
        if name == "_" {
            return autodiff_declared_variable(name, "_", false, false);
        }

        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur_context := declaration_stack.rbegin())
        while cur_context != declaration_stack.rend()
        next  cur_context++
        {
            r := cur_context*.lookup_variable_declaration(name);
            if r.found {
                return r.r;
            }
        }

        declaration_stack.back().decl.error("AD: Could not find declaration of variable with name `(name)$`.");

        return autodiff_declared_variable();
    }

    lookup_function_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::function_declaration> = ()) = {
        r_all := lookup_declaration(decl_name);

        for r_all do (cur) {
            if cur.is_function() {
                r.push_back(cur.as_function());
            }
        }
    }

    lookup_member_function_declaration: (inout this, obj_type: meta::type_declaration, decl_name: std::string) -> (r : std::vector<meta::function_declaration> = ()) = {
        for obj_type.get_members() do (cur) {
            if cur.is_function() && cur.has_name() && decl_name  == cur.name() {
                r.push_back(cur.as_function());

                // Do not break for overloads. <3
            }
        }
    }

    lookup_type_declaration: (inout this, decl_name: std::string) -> (r : std::vector<meta::type_declaration> = ()) = {
        r_all := lookup_declaration(decl_name);

        for r_all do (cur) {
            if cur.is_type() {
                r.push_back(cur.as_type());
            }
        }
    }

    lookup_special_function_handling: (this, func_name: std::string, n_args: int, is_member: bool) -> (m: bool, code_primal: std::string, code_fwd: std::string, code_rws: std::string) = {
        lookup : autodiff_special_func = (func_name, n_args, is_member);

        m = false;
        code_primal = "";
        code_fwd    = "";
        code_rws    = "";
        for special_funcs do (func) {
            if func.is_match(lookup) {
                m = true;
                if is_taylor() {
                    code_primal = func.code_primal_higher_order;
                    code_fwd    = func.code_fwd_higher_order;
                    code_rws    = func.code_rws_higher_order;
                }
                else {
                    code_primal = func.code_primal;
                    code_fwd    = func.code_fwd;
                    code_rws    = func.code_rws;
                }
                return;
            }
        }
    }

    add_as_differentiated: (inout this, t: meta::declaration) = {
        top := declaration_stack.back()&;

        assert(t.get_parent().is_same(top*.decl));

        top*.diff_done.push_back(t);
    }

    add_for_differentiation: (inout this, t: meta::declaration) = {
        t_parent := t.get_parent();

        found := false;

        //  Note: Not using "for std::ranges::views::reverse(...)" because
        //  that does not work correctly in Clang 12 + older libstdc++
        (copy cur := declaration_stack.rbegin())
        while cur != declaration_stack.rend()
        next  cur++
        {
            if t_parent.is_same(cur*.decl) {
                if !is_in_list(t, cur*.diff_request) {
                    cur*.diff_request.push_back(t);
                }

                found = true;
                break;
            }
        }

        if !found {
            t.error("AD: Could not find parent type/namespace for: (t)$");
        }
    }

    is_in_list: (v: meta::declaration, list: std::vector<meta::declaration>) -> bool = {
        for list do (cur) {
            if cur.is_same(v) {
                return true;
            }
        }

        return false;
    }

    enter_function: (inout this) = {
        temporary_count = 0;
        declaration_stack.back().declared_variables_stack.push_back(std::vector<autodiff_declared_variable>());
    }

    leave_function: (inout this) = {
        declaration_stack.back().declared_variables_stack.pop_back();
    }

    push_stack: (inout this, decl: meta::type_or_namespace_declaration) = {
        full_name: std::string = "";

        if !declaration_stack.empty() {
            full_name += declaration_stack.back().full_name;
        }

        full_name += "::";
        full_name += decl.name();

        declaration_stack.push_back(autodiff_declaration_stack_item(full_name, decl));
    }

    pop_stack: (inout this) = {
        assert(!declaration_stack.empty());

        top := declaration_stack.back()&;
        ad: autodiff_declaration_handler = (this&, top*.decl);

        for top*.diff_request do (cur) {
            if !is_in_list(cur, top*.diff_done) {
                ad.pre_traverse(cur);
            }
        }

        declaration_stack.pop_back();
    }

    finish: (inout this) = {
        while !declaration_stack.empty() {
            pop_stack();
        }
    }
}

autodiff_diff_code: type = {
    public ctx: *autodiff_context;

    public fwd         : std::string = "";
    public rws_primal  : std::string = "";
    public rws_backprop: std::string = "";

    operator=:(out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
    }
    operator=:(out this, that) = {}

    add_forward         : (inout this, v: std::string) = { if ctx*.is_forward() { fwd          += v; }}
    add_reverse_primal  : (inout this, v: std::string) = { if ctx*.is_reverse() { rws_primal   += v; }}
    add_reverse_backprop: (inout this, v: std::string) = { if ctx*.is_reverse() { rws_backprop = v + rws_backprop; }}

    reset: (inout this) = {
        fwd          = "";
        rws_primal   = "";
        rws_backprop = "";
    }

    // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
    operator=:(inout this, v: std::string) = {
        ctx = ctx;
        fwd = v;
    }

    // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
    operator+=: (inout this, v: std::string) = {
        fwd += v;
    }

    // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
    operator+=: (inout this, v: autodiff_diff_code) = {
        fwd += v.fwd;
    }

    // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
    empty: (this) -> bool = {
        return fwd.empty();
    }
}

// // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
// to_string: (v: autodiff_diff_code) -> std::string = {
//     return v.fwd;
// }

autodiff_activity_check: type = {
    this: simple_traverser = ();

    public ctx   : *autodiff_context;
    public active: bool              = false;

    operator=: (out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
    }

    traverse: (override inout this, t: meta::type_declaration) = {
        for t.get_members()
        do  (m)
        {
            if m.is_object() || m.is_member_object() {
                pre_traverse(m);
            }

            // TODO: Maybe also add functions.
        }
    }

    traverse: (override inout this, o: meta::object_declaration) = {

        type := o.type();

        if "_" == type {
            if o.has_initializer() {
                pre_traverse(o.get_initializer());
            }
            else {
                // Assume active
                active = true;
            }
        }
        else {
            active |= ctx*.is_type_active(type);
        }
    }

    traverse: (override inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            active |= ctx*.is_variable_active(primary.to_string());
        }
        else if primary.is_expression_list() {
            for primary.as_expression_list().get_expressions() do (cur) {
                pre_traverse(cur);
            }
        }
        else if primary.is_literal() {
            // TODO: Improve check
            if primary.to_string().contains(".") {
                active = true;
            }
        }
        else if primary.is_declaration() {
            pre_traverse(primary.as_declaration());
        }
        else {
            primary.error("AD: Unknown primary expression kind: (primary.to_string())$");
        }
    }

    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            }
            else {
                postfix.error("AD: Unknown operator for postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        // TODO: Really check for members
        if !is_func || terms.ssize() != 1 {
            active |= ctx*.is_variable_active(postfix.get_primary_expression().to_string());
        }

        if is_func {
            // Check arguments of function
            for terms.back().get_expression_list().get_expressions() do (cur) {
                pre_traverse(cur);
            }
        }
    }
}

autodiff_handler_base: type = {
    public ctx: *autodiff_context;

    public diff : autodiff_diff_code;

    operator=: (out this, ctx_: *autodiff_context) = {
        ctx = ctx_;
        diff = (ctx);
    }

    // Temporary: TODO: remove when everything has been adapted to primal, fwd, rws pushes.
    append: (inout this, in_ref o: autodiff_handler_base) = {
        diff.fwd          += o.diff.fwd;
        diff.rws_primal   += o.diff.rws_primal;
        diff.rws_backprop  = o.diff.rws_backprop + diff.rws_backprop;
    }
}

autodiff_expression_handler: type = {
    this: simple_traverser = ();
    this: autodiff_handler_base;

    base: type == simple_traverser;

    public primal_expr: std::string = "";
    public fwd_expr   : std::string = "";
    public rws_expr   : std::string = "";

    operator=: (out this, ctx_: *autodiff_context) = {
        autodiff_handler_base = (ctx_);
    }

    add_suffix_if_not_wildcard: (this, lhs: std::string, suffix: std::string) -> std::string = {
        if "_" == lhs {
            return lhs;
        }
        else {
            return lhs + suffix;
        }
    }

    prepare_backprop: (this, rhs_b: std::string, lhs: std::string, lhs_d: std::string, lhs_b: std::string) -> std::string = {
        r := rhs_b;
        r  = string_util::replace_all(r, "_r_", lhs);
        r  = string_util::replace_all(r, "_rd_", lhs_d);
        r  = string_util::replace_all(r, "_rb_", lhs_b);

        return r;
    }
    prepare_backprop: (this, rhs_b: std::string, lhs: std::string) -> std::string = prepare_backprop(rhs_b, lhs, lhs + ctx*.fwd_suffix, lhs + ctx*.rws_suffix);

    gen_assignment: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string) = {
        diff.add_forward("(lhs_d)$ = (rhs_d)$;\n");
        diff.add_forward("(lhs)$   = (rhs)$;\n");

        if ctx*.is_taylor() {
            diff.add_reverse_primal("(lhs_d)$ = (rhs_d)$;\n");
        }
        diff.add_reverse_primal("(lhs)$   = (rhs)$;\n");
        diff.add_reverse_backprop("(lhs_b)$ = 0.0;\n");
        diff.add_reverse_backprop(prepare_backprop(rhs_b, lhs, lhs_d, lhs_b));
    }
    gen_assignment: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string)
        = gen_assignment(lhs, lhs_d, lhs_b, primal_expr, fwd_expr, rws_expr);
    gen_assignment: (inout this, lhs: std::string)
        = gen_assignment(lhs, add_suffix_if_not_wildcard(lhs, ctx*.fwd_suffix), add_suffix_if_not_wildcard(lhs, ctx*.rws_suffix), primal_expr, fwd_expr, rws_expr);


    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string, type: std::string, type_d: std::string, type_b: std::string) = {
        diff.add_forward("(lhs_d)$: (type_d)$ = (rhs_d)$;\n");
        diff.add_forward("(lhs)$  : (type)$ = (rhs)$;\n");

        if ctx*.is_taylor() {
            diff.add_reverse_primal("(lhs_d)$: (type_d)$ = (rhs_d)$;\n");
        }
        diff.add_reverse_primal("(lhs_b)$ : (type_b)$ = 0.0;\n");
        diff.add_reverse_primal("(lhs)$  : (type)$ = (rhs)$;\n");
        diff.add_reverse_backprop("(lhs_b)$ = 0.0;\n");
        diff.add_reverse_backprop(prepare_backprop(rhs_b, lhs, lhs_d, lhs_b));
    }
    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, rhs: std::string, rhs_d: std::string, rhs_b: std::string, type: std::string)
        = gen_declaration(lhs, lhs_d, lhs_b, rhs, rhs_d, rhs_b, type, ctx*.get_fwd_ad_type(type) , ctx*.get_rws_ad_type(type));
    gen_declaration: (inout this, lhs: std::string, lhs_d: std::string, lhs_b: std::string, type: std::string)
        = gen_declaration(lhs, lhs_d, lhs_b, primal_expr, fwd_expr, rws_expr, type);
    gen_declaration: (inout this, lhs: std::string, type: std::string)
        = gen_declaration(lhs, lhs + ctx*.fwd_suffix, lhs + ctx*.rws_suffix, type);



    primal_fwd_rws_name: @struct<noforward> type = {
        primal: std::string = "";
        fwd   : std::string = "";
        rws   : std::string = "";
        active: bool        = false;
    }

    handle_expression_list: (inout this, list: meta::expression_list) -> std::vector<primal_fwd_rws_name> = {
        args : std::vector<primal_fwd_rws_name> = ();
        for list.get_expressions() do (expr) {
            args.push_back(handle_expression_term(expr));
        }

        return args;
    }

    handle_expression_term :(inout this, term) -> primal_fwd_rws_name = {
        if term.is_identifier() {
            primal := term.to_string();
            fwd    := primal + ctx*.fwd_suffix;
            rws    := primal + ctx*.rws_suffix;

            decl := ctx*.lookup_variable_declaration(primal);
            if decl.is_member {
                fwd = "this(ctx*.fwd_suffix)$." + fwd;
                rws = "this(ctx*.rws_suffix)$." + rws;
            }

            if decl.is_active {
                return (primal, fwd, rws, true);
            }
            else {
                return (primal, "", "", false);
            }

        }
        else if term.is_expression_list() {
            exprs := term..as_expression_list()..get_expressions();
            if exprs.ssize() != 1 {
                term.error("Can not handle multiple expressions. (term.to_string())");
                return ("error", "", "", false);
            }
            expr := exprs[0];
            bin_expr := expr..as_assignment_expression();

            if bin_expr.terms_size() != 0 {
                term.error("Can not handle assign expr inside of expression. (expr.to_string())$");
                return ("error", "", "", false);
            }

            return handle_expression_term(bin_expr.get_terms().front().get_term());
        }
        else {
            // Nothing special. A regular expression.
            expr := term;

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(expr);

            if ada.active {

                ad : autodiff_expression_handler = (ctx);
                ad..pre_traverse(expr);
                t := ctx*.gen_temporary();
                ad.gen_declaration(t, "double"); // TODO: get type of expression
                append(ad);

                r : primal_fwd_rws_name = (t, t + ctx*.fwd_suffix, t + ctx*.rws_suffix, true); // TODO: Check why on return (t, t + ctx*.fwd_suffix) the primal is initialized empty. Probably because of the move(t)
                _ = t;
                return r;
            }
            else {
                return (expr.to_string(), "", "", false);
            }
        }
    }

    handle_function_call: (inout this, postfix: meta::postfix_expression, has_return: bool) = {
        terms := postfix.get_terms();

        is_func  := true;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                continue;
            }

            is_func = false;
        }

        // Check for function call, everything else is not handled.
        if !(is_func) {
            postfix.error( "AD: Postfix expressions are only handled for function calls, or member function calls. Do not know how to handle: (postfix.to_string())$" );
            return;
        }

        object         : std::string = "";
        object_d       : std::string = "";
        object_b       : std::string = "";
        function_name : std::string = "";
        args          : std::vector<primal_fwd_rws_name> = ();

        primary := postfix.get_primary_expression();

        if 1 != terms.ssize() {
            object   = primary.to_string();
            object_d = primary.to_string() + ctx*.fwd_suffix;
            object_b = primary.to_string() + ctx*.rws_suffix;
        }
        else {
            function_name = primary.to_string();
        }

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                assert(term.is_id_expression());
                name := term.get_id_expression().to_string();

                if i + 2 == terms.ssize() { // Second last term is function name, last term is function argument list
                    function_name = name;
                }
                else {
                    object   += "." + name;
                    object_d += "." + name + ctx*.fwd_suffix;
                }
            }
            else if term.get_op() == "(" {
                assert(term.is_expression_list());

                args = handle_expression_list(term.get_expression_list());
            }
            else {
                postfix.error("AD: Do not know how to handle postfix term: (term.to_string())$");
            }
        }

        if handle_special_function(object, object_d, object_b, function_name, args) {
            return;
        }

        if object.contains(".") {
            postfix.error("AD: can not handle nested member function calls: (postfix.to_string())$");
            return;
        }

        call_primal: std::string = "";
        call_fwd   : std::string = "";
        call_rws   : std::string = "";

        // All arguments have now been handled. Form the function call
        ret_temp : std::string = "";
        if has_return {
            ret_temp = ctx*.gen_temporary();
            call_fwd += "(ret_temp)$ := ";
        }

        // TODO: This is untested for functions with no return value. Requires handling of out and inout parameters in functions.
        if !object.empty() { // Prepend object call
            call_primal += "(object)$.";
            call_fwd    += "(object)$.";
            call_rws    += "(object)$.";
        }
        call_primal += "(function_name)$(";
        call_fwd    += "(function_name)$(ctx*.fwd_suffix)$(";
        call_rws    += "(function_name)$(ctx*.rws_suffix)$(";
        if !object.empty() { // Add this_d argument.
            call_fwd += "(object_d)$, ";
            call_rws += "(object_b)$, ";
        }
        for args do (arg) {
            // TODO: Add taylor reverse handling.
            call_primal += "(arg.primal)$, ";
            call_fwd    += "(arg.primal)$, ";
            call_rws    += "(arg.primal)$, ";
            if arg.active {
                call_fwd += "(arg.fwd)$, ";
                call_rws += "(arg.rws)$, ";
            }
        }

        if has_return {
            functions : std::vector<meta::function_declaration> = ();
            if !object.empty() {
                obj_decl := ctx*.lookup_variable_declaration(object);
                obj_decl_types := ctx*.lookup_type_declaration(obj_decl.decl);

                if obj_decl_types.empty() {
                    postfix.error("AD: Could not find type declaration for `(object)$ with type (obj_decl.decl)$`.\n"
                              "    If cpp2 object: this is an alpha limitation, please declare it befor the current declaration.\n"
                              "    If cpp function: please add a special handling for this member function.");
                    return;
                }
                functions = ctx*.lookup_member_function_declaration(obj_decl_types[0], function_name);

                ctx*.add_for_differentiation(obj_decl_types[0]); // TODO: Add more fine grained differentiation.
            }
            else {
                functions = ctx*.lookup_function_declaration(function_name);
                if functions.ssize() == 0 {
                    postfix.error("AD: Could not find function declaration for `(function_name)$`.\n"
                                "    If cpp2 function: this is an alpha limitation, please declare it befor the current declaration.\n"
                                "    If cpp function: please add a special handling for this function.");
                    return;
                }
                else if functions.ssize() != 1 {
                    postfix.error("AD: No handling for overload resultion is currently implemented.");
                    return;
                }

                ctx*.add_for_differentiation(functions[0]);
            }

            ret_name : std::string = "r"; // Default for regular return.
            returns := functions[0].get_returns();
            if !returns.empty() {
                if returns.ssize() != 1 {
                    postfix.error("AD: Expecting single return.");
                }

                for returns do (cur) {
                    ret_name = cur.get_declaration().name();
                }
            }

            ret_name_d : std::string = ret_name + ctx*.fwd_suffix;
            ret_name_b : std::string = ret_name + ctx*.rws_suffix;

            call_rws += "_rb_, ";

            call_primal += ")";
            call_fwd    += ");\n";
            call_rws    += ");\n";

            diff.add_forward(call_fwd);

            primal_expr = call_primal;
            fwd_expr    = "(ret_temp)$.(ret_name_d)$";
            rws_expr    = "_ = (call_rws)$";
        }
        else {
            call_primal += ");\n";
            call_fwd    += ");\n";
            call_rws    += ");\n";

            diff.add_forward(call_fwd);
            diff.add_reverse_primal(call_primal);
            diff.add_reverse_backprop(call_rws);
        }

        // TODO: Add function to list of functions/objects for differentiation for the no return case.
    }

    handle_special_function: (inout this, object: std::string, object_d: std::string, object_b: std::string, function_name: std::string, args: std::vector<primal_fwd_rws_name>) -> bool = {

        r := ctx*.lookup_special_function_handling(function_name, unchecked_narrow<int>(args.ssize()), !object.empty());

        if !r.m {
            return false; // No match
        }

        // Have a match, do the replacement
        code_primal: std::string = r.code_primal;
        code_fwd   : std::string = r.code_fwd;
        code_rws   : std::string = r.code_rws;

        if !object.empty() {
            code_primal = string_util::replace_all(code_primal, "_o_", object);
            code_primal = string_util::replace_all(code_primal, "_od_", object_d);

            code_fwd = string_util::replace_all(code_fwd, "_o_", object);
            code_fwd = string_util::replace_all(code_fwd, "_od_", object_d);

            code_rws = string_util::replace_all(code_fwd, "_o_", object);
            code_rws = string_util::replace_all(code_rws, "_od_", object_d);
            code_rws = string_util::replace_all(code_fwd, "_ob_", object_b);
        }

        (copy i := 1)
        for args do (arg) {
            code_primal = string_util::replace_all(code_primal, "_a(i)$_", arg.primal);
            code_primal = string_util::replace_all(code_primal, "_ad(i)$_", arg.fwd);

            code_fwd = string_util::replace_all(code_fwd, "_a(i)$_", arg.primal);
            code_fwd = string_util::replace_all(code_fwd, "_ad(i)$_", arg.fwd);

            code_rws = string_util::replace_all(code_rws, "_a(i)$_", arg.primal);
            code_rws = string_util::replace_all(code_rws, "_ad(i)$_", arg.fwd);
            code_rws = string_util::replace_all(code_rws, "_ab(i)$_", arg.rws);
        }

        primal_expr = code_primal;
        fwd_expr    = code_fwd;
        rws_expr    = code_rws;

        return true;
    }

    traverse: (override inout this, expr: meta::expression) = {
        base::traverse(expr);
    }

    traverse: (override inout this, binexpr: meta::assignment_expression) = {
        binexpr.error( "AD: Assign expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::logical_or_expression) = {
        binexpr.error( "AD: Logical or expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::logical_and_expression) = {
        binexpr.error( "AD: Logical and expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::bit_or_expression) = {
        binexpr.error( "AD: Bit or expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::bit_xor_expression) = {
        binexpr.error( "AD: Bit xor expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::bit_and_expression) = {
        binexpr.error( "AD: Bit and expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::equality_expression) = {
        binexpr.error( "AD: Equality or expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::relational_expression) = {
        binexpr.error( "AD: Relational expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::compare_expression) = {
        binexpr.error( "AD: Compare or expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::shift_expression) = {
        binexpr.error( "AD: Shift or expressions are not yet handled." );
    }

    traverse: (override inout this, binexpr: meta::additive_expression) = {
        terms := binexpr.get_terms();

        first     := true;
        first_fwd := true;
        op  :   std::string = "+";
        fwd :   std::string = "";
        rws :   std::string = "";
        primal: std::string = "";
        for terms do (term) {
            if !first {
                op      = term.get_op().to_string();
                primal += " (op)$ ";
            }

            var   := handle_expression_term(term.get_term());
            if var.active {
                if first_fwd {
                    if op == "-" {// Special handling for first fwd termn with minus
                        fwd += "-(var.fwd)$";
                    }
                    else { // Special handling for first fwd term with plus
                        fwd += var.fwd;
                    }
                }
                else {
                    fwd += "(op)$ (var.fwd)$";
                }
                rws    += "(var.rws)$ (op)$= _rb_;\n";

                first_fwd = false;
            }
            primal += var.primal;

            first = false;
        }

        primal_expr = primal;
        fwd_expr    = fwd;
        rws_expr    = rws;
    }

    traverse: (override inout this, binexpr: meta::multiplicative_expression) = {
        terms := binexpr.get_terms();

        var_a := handle_expression_term(terms[0].get_term());

        i : int = 1;
        while i < terms.ssize() next i += 1 {
            var_b := handle_expression_term(terms[i].get_term());

            op := terms[i].get_op().to_string();

            fwd    : std::string = "";
            rws    : std::string = "";
            primal : std::string = "";

            if "*" == op {
                if ctx*.is_taylor() {
                    // TODO: Add taylor overloads
                    fwd = "(var_a.fwd)$..mul((var_b.fwd)$, (var_a.primal)$, (var_b.primal)$)";
                    if var_a.active {
                        //fwd += "(var_b.primal)$ * (var_a.fwd)$";
                        rws += "(var_a.rws)$ += (var_b.fwd)$..mul(_rb_, (var_b.primal)$, _r_);\n";
                    }
                    if var_b.active {
                        //if !fwd.empty() { fwd += " + "; }
                        //fwd += "(var_a.primal)$ * (var_b.fwd)$";
                        rws += "(var_b.rws)$ += (var_a.fwd)$..mul(_rb_, (var_a.primal)$, _r_);\n";
                    }
                }
                else {
                    if var_a.active {
                        fwd += "(var_b.primal)$ * (var_a.fwd)$";
                        rws += "(var_a.rws)$ += (var_b.primal)$ * _rb_;\n";
                    }
                    if var_b.active {
                        if !fwd.empty() { fwd += " + "; }
                        fwd += "(var_a.primal)$ * (var_b.fwd)$";
                        rws += "(var_b.rws)$ += (var_a.primal)$ * _rb_;\n";
                    }
                }
                primal = "(var_a.primal)$ * (var_b.primal)$";
            }
            else if "/" == op {
                if ctx*.is_taylor() {
                    // TODO: Add taylor overloads
                    fwd = "(var_a.fwd)$.div((var_b.fwd)$, (var_a.primal)$, (var_b.primal)$)";
                    if var_a.active {
                        rws += "(var_a.rws)$ += _rb_.div((var_b.fwd)$, _r_, (var_b.primal)$);\n";
                    }
                    if var_b.active {
                        rws += "(var_b.rws)$ -= (var_a.fwd)$.mul(_rb_, (var_a.primal)$, _r_).div((var_b.fwd)$.mul((var_b.fwd)$, (var_b.primal)$, (var_b.primal)$), (var_a.primal)$ * _r_, (var_b.primal)$ * (var_b.primal)$);\n";
                    }
                }
                else {
                    if var_a.active {
                        fwd += "(var_a.fwd)$ / (var_b.primal)$";
                        rws = "(var_a.rws)$ += _rb_ / (var_b.primal)$;\n";
                    }
                    if var_b.active {
                        if !fwd.empty() { fwd += " + "; }
                        fwd += "-(var_a.primal)$ * (var_b.fwd)$ / ((var_b.primal)$ * (var_b.primal)$)";
                        rws += "(var_b.rws)$ -= (var_a.primal)$ * _rb_ / ((var_b.primal)$ * (var_b.primal)$);\n";
                    }
                }
                primal = "(var_a.primal)$ / (var_b.primal)$";
            }
            else {
                binexpr.error( "unkown multiplicative operator '(op)$'");
            }


            if i + 1 == terms.ssize() {
                primal_expr = primal;
                fwd_expr    = fwd;
                rws_expr    = rws;
            }
            else {
                // Temporary
                var_a.primal = ctx*.gen_temporary();
                var_a.fwd    = var_a.primal + ctx*.fwd_suffix;
                var_a.rws    = var_a.primal + ctx*.rws_suffix;
                var_a.active = var_a.active | var_b.active;
                gen_declaration(var_a.primal, var_a.fwd, var_a.rws, primal, fwd, rws, "", "", "");
            }
        }
    }

    traverse: (override inout this, isas: meta::is_as_expression) = {
        isas.error( "AD: Is as expressions are not yet handled." );
    }

    traverse: (override inout this, prefix: meta::prefix_expression) =
    {
        ops := prefix.get_ops();

        if ops.ssize() != 1 {
            prefix.error( "AD: Can only handle one prefix operation. Expression is: (prefix.to_string())$" );
        }

        ad: autodiff_expression_handler = (ctx);
        ad.pre_traverse(prefix.get_postfix_expression());
        append(ad);

        primal_expr = ops[0] + ad.primal_expr;
        fwd_expr    = ops[0] + ad.fwd_expr;
    }

    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            }
            else {
                postfix.error("AD: Unknown operator for postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        if is_func {
            handle_function_call(postfix, true);
        }
        else {
            // Member access

            primary      :             = postfix.get_primary_expression();
            obj_access   : std::string = primary.to_string();
            obj_access_d : std::string = obj_access + ctx*.fwd_suffix;

            for terms do (term)  {
                obj_access   += term.get_op() + term.get_id_expression().to_string();
                obj_access_d += term.get_op() + term.get_id_expression().to_string() + ctx*.fwd_suffix;
            }

            primal_expr = obj_access;
            fwd_expr    = obj_access_d;
        }
    }

    traverse: (override inout this, primary: meta::primary_expression) =
    {
        if primary.is_identifier() {
            primal_expr = primary.to_string();
            fwd_expr    = add_suffix_if_not_wildcard(primal_expr, ctx*.fwd_suffix);
            rws_expr    = add_suffix_if_not_wildcard(primal_expr, ctx*.rws_suffix);

            decl := ctx*.lookup_variable_declaration(primal_expr);
            if decl.is_member {
                fwd_expr = "this(ctx*.fwd_suffix)$." + fwd_expr;
                rws_expr = "this(ctx*.rws_suffix)$." + rws_expr;
            }
        }
        else if primary.is_expression_list() {
            if primary.as_expression_list().is_empty() {
                primal_expr = "()";
                fwd_expr    = "()";
                rws_expr    = "()";   // TODO: Check for reverse
            }
            else {
                primary.error("AD: Do not know how to handle non empty expression list inside of primary_expression: (primary.to_string())$");
            }
        }
        else if primary.is_literal() {
            primal_expr = primary.to_string();
            fwd_expr    = "()";
            rws_expr    = "()";  // TODO: Check for reverse
        }
        else if primary.is_declaration() {
            primary.error("AD: Do not know how to handle declaration inside of primary_expression: (primary.to_string())$");
        }
        else {
            primary.error("AD: Unknown primary expression kind: (primary.to_string())$");
        }
    }
}

autodiff_stmt_handler: type = {
    this: simple_traverser      = ();
    this: autodiff_handler_base;

    base: type == simple_traverser;

    mf: meta::function_declaration;

    last_params: std::vector<meta::parameter_declaration> = ();
    overwritten: std::vector<std::string> = ();

    overwrite_push_pop: bool = false;

    operator=: (out this, ctx_: *autodiff_context, mf_: meta::function_declaration) = {
        autodiff_handler_base = (ctx_);
        mf = mf_;
    }

    handle_stmt_parameters: (inout this, params: std::vector<parameter_declaration>) -> autodiff_diff_code = {
        r : autodiff_diff_code = (ctx);
        if params.empty() {
            return r;
        }

        for params do (param) {
            name: std::string = param.get_declaration().name();
            type: std::string = param.get_declaration().type();

            fwd_pass_style := to_string_view(param.get_passing_style());

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(param);

            init  : std::string = "";
            init_d: std::string = "";
            // TODO: Add handling for reverse expressions

            if param.get_declaration().has_initializer() {
                ad: autodiff_expression_handler = (ctx);
                ad.pre_traverse(param.get_declaration().get_initializer());
                init = " = (ad.primal_expr)$";

                if ada.active {
                    init_d = " = (ad.fwd_expr)$";
                }
            }


            r.add_forward("(fwd_pass_style)$ (name)$ : (type)$(init)$, ");
            r.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$(init)$, ");
            if ada.active {
                r.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$(init_d)$, ");
            }

            ctx*.add_variable_declaration(name, type, ada.active);
        }

        return r;
    }

    traverse: (override inout this, decl: meta::declaration) = {
        base::traverse(decl);
    }


    traverse: (override inout this, f: meta::function_declaration) = {
        f.error("AD: Do not know how to handle function_declaration: (f.to_string())$");
    }


    traverse: (override inout this, o: meta::object_declaration) = {
        lhs  : std::string = o.name();
        type :             = o.type();

        active := false;
        if "_" != type {
            active = ctx*.is_type_active(type);
        }
        else {
            assert(o.has_initializer());

            ada: autodiff_activity_check = (ctx);
            ada.pre_traverse(o.get_initializer());
            active = ada.active;
        }

        if active {

            fwd_ad_type : = ctx*.get_fwd_ad_type(type);
            rws_ad_type : = ctx*.get_rws_ad_type(type);

            prim_init: std::string = "";
            fwd_init : std::string = "";
            rws_init : std::string = "";

            if o.has_initializer() {
                ad: autodiff_expression_handler = (ctx);
                ad.pre_traverse(o.get_initializer());
                append(ad);

                prim_init = " = " + ad.primal_expr;
                fwd_init  = " = " + ad.fwd_expr;
                rws_init  = " = ()"; // TODO: Proper initialization.

                if ad.rws_expr != "()" {
                    diff.add_reverse_backprop(ad.prepare_backprop(ad.rws_expr, lhs));
                }

                if type == "_" && ad.fwd_expr == "()" {
                    // Special handling for auto initialization from a literal.
                    fwd_init = " = " + ctx*.get_fwd_ad_type("double") + "()";
                }
            }

            diff.add_forward("(lhs)$(ctx*.fwd_suffix)$ : (fwd_ad_type)$(fwd_init)$;\n");
            diff.add_forward("(lhs)$   : (type)$(prim_init)$;\n");

            diff.add_reverse_primal("(lhs)$(ctx*.rws_suffix)$ : (rws_ad_type)$(rws_init)$;\n");
            diff.add_reverse_primal("(lhs)$   : (type)$(prim_init)$;\n");
        }
        else {
            diff += "(lhs)$: (type)$";
            if o.has_initializer() {
                diff += " = (o.get_initializer().to_string())$";
            }
            diff += ";\n";
        }

        ctx*.add_variable_declaration(lhs, type, active);
    }


    traverse: (override inout this, t: meta::type_declaration) = {
        t.error("AD: Do not know how to handle type_declaration: (t.to_string())$");
    }


    traverse: (override inout this, t: meta::parameter_declaration) = {
        t.error("AD: Do not know how to handle parameter_declaration: (t.to_string())$");
    }


    traverse: (override inout this, stmt: meta::statement) = {
        // TODO: Remove this hack when statements like compound_statement can access their root statement.
        last_params = stmt.get_parameters();
        base::traverse(stmt);
    }


    traverse: (override inout this, stmt: meta::compound_statement) = {
        ad         : autodiff_stmt_handler = (ctx, mf);
        ad_push_pop: autodiff_stmt_handler = (ctx, mf);
        ad_push_pop.overwrite_push_pop = true;

        diff.add_forward("{\n");
        diff.add_reverse_primal("{\n");
        diff.add_reverse_backprop("}\n");

        for stmt.get_statements() do (cur) {
            ad.pre_traverse(cur);
            ad_push_pop.pre_traverse(cur);
        }

        for ad.overwritten do (cur) {
            r := ctx*.lookup_variable_declaration(cur);
            diff.add_reverse_primal("cpp2::ad_stack::push<(r.decl)$>((cur)$);");
        }

        diff.add_forward(ad.diff.fwd);
        diff.add_reverse_primal(ad.diff.rws_primal);
        diff.add_reverse_backprop(ad_push_pop.diff.rws_backprop);
        diff.add_reverse_backprop(ad_push_pop.diff.rws_primal);

        for ad.overwritten do (cur) {
            r := ctx*.lookup_variable_declaration(cur);
            diff.add_reverse_backprop("(cur)$ = cpp2::ad_stack::pop<(r.decl)$>();");
        }

        diff.add_forward("}\n");
        diff.add_reverse_primal("}\n");
        diff.add_reverse_backprop("{\n");
    }


    traverse: (override inout this, stmt: meta::return_statement) = {
        if stmt.has_expression() {
            // Return with expression.
            // TODO: Remove assumptions
            //     - Return expression is always active. (Look this up in mf or so.)
            //     - Return was converted to a two parameter return with the name r.
            ad: autodiff_expression_handler = (ctx);
            ad..pre_traverse(stmt.get_expression());
            ad.gen_assignment("r",);
            append(ad);
        }
        else {
            diff += "return;\n";
        }
    }

    reverse_next: (this, expr: std::string) -> std::string = {
        if expr.contains("+=") {
            return string_util::replace_all(expr, "+=", "-=");
        }
        else if expr.contains("-=") {
            return string_util::replace_all(expr, "-=", "+=");
        }

        mf.error("AD: Do not know how to reverse: (expr)$");

        return "Error";

    }


    traverse: (override inout this, stmt: meta::iteration_statement) = {
        diff_params := handle_stmt_parameters(last_params);

        if ctx*.is_reverse() && (stmt.is_while() || stmt.is_do()) {
            stmt.error("AD: Alpha limitiation now reverse mode for while or do while.");
        }

        if stmt.is_while() {
            if !last_params.empty() {
                diff.add_forward("(" + diff_params.fwd + ")");
            }
            // TODO: Assumption is here that nothing is in the condition
            diff += "while (stmt.get_do_while_condition().to_string())$ ";
            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff += "next (stmt.get_next_expression().to_string())$ ";
            }

            pre_traverse(stmt.get_do_while_body());
        }
        else if stmt.is_do() {
            if !last_params.empty() {
                diff.add_forward("(" + diff_params.fwd + ")");
            }

            // TODO: Assumption is here that nothing is in the condition
            diff += "do ";
            pre_traverse(stmt.get_do_while_body());

            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff += "next (stmt.get_next_expression().to_string())$ ";
            }
            diff += "while (stmt.get_do_while_condition().to_string())$;";
        }
        else {
            assert(stmt.is_for());
            // No zip view available in cpp 20 do a piggy back for range

            // TODO: Assumption that this is just an id expression.
            range := stmt.get_for_range().to_string();

            param := stmt.get_for_parameter();
            param_style := to_string_view(param.get_passing_style());
            param_decl := param.get_declaration();

            rws        : std::string = "(";
            rws_restore: std::string = "";
            diff.add_forward("("); // Open statment parameter scope. If the loop has parameters, they are alrady handled and the brace is left open.
            diff.add_reverse_primal("{\n");
            if !last_params.empty() {
                for last_params do (cur) {
                    if cur.get_declaration().has_initializer() {
                        // TODO: Handle no type and no initializer. Handle passing style.
                        diff.add_reverse_primal("(cur.get_declaration().name())$: (cur.get_declaration().type())$ = (cur.get_declaration().get_initializer().to_string())$;\n");
                        rws_restore += "cpp2::ad_stack::push<(cur.get_declaration().type())$>((cur.get_declaration().name())$);\n";
                        rws += "(to_string_view(cur.get_passing_style()))$ (cur.get_declaration().name())$: (cur.get_declaration().type())$ = cpp2::ad_stack::pop<(cur.get_declaration().type())$>(), ";
                    }
                }
                diff.add_forward(diff_params.fwd);
            }
            diff.add_forward("copy (param_decl.name())$(ctx*.fwd_suffix)$_iter := (range)$(ctx*.fwd_suffix)$.begin())\n");
            diff.add_forward("for (range)$ next (");

            rws += "copy (param_decl.name())$(ctx*.rws_suffix)$_iter := (range)$(ctx*.rws_suffix)$.rbegin())\n";
            rws += "for std::ranges::reverse_view((range)$) next (";
            diff.add_reverse_primal("for (range)$ next (");
            if stmt.has_next() {
                // TODO: Assumption is here that nothing is in the next expression
                diff.add_forward("(stmt.get_next_expression().to_string())$, ");
                diff.add_reverse_primal("(stmt.get_next_expression().to_string())$, ");
                rws += "(reverse_next(stmt.get_next_expression().to_string()))$, ";
            }
            diff.add_forward("(param_decl.name())$(ctx*.fwd_suffix)$_iter++");
            diff.add_forward(") do ((param_style)$ (param_decl.name())$: (param_decl.type())$) {\n");
            rws += "(param_decl.name())$(ctx*.rws_suffix)$_iter++";
            rws += ") do ((param_style)$ (param_decl.name())$: (param_decl.type())$) {\n";
            rws +=  "(inout (param_decl.name())$(ctx*.rws_suffix)$ := (param_decl.name())$(ctx*.rws_suffix)$_iter*)\n";

            diff.add_reverse_primal(") do ((param_style)$ (param_decl.name())$: (param_decl.type())$)");
            diff.add_forward("((param_style)$ (param_decl.name())$(ctx*.fwd_suffix)$: (param_decl.type())$ = (param_decl.name())$(ctx*.fwd_suffix)$_iter*)");

            ctx*.add_variable_declaration("(param_decl.name())$", "(param_decl.type())$", true); // TODO: Handle loop/compound context variable declarations.
            diff.add_reverse_backprop("}\n");

            pre_traverse(stmt.get_for_body());
            diff.add_forward("}\n");

            if stmt.has_next() {
                diff.add_reverse_primal("(reverse_next(stmt.get_next_expression().to_string()))$;\n");
            }
            diff.add_reverse_primal(rws_restore);
            diff.add_reverse_primal("}\n");
            diff.add_reverse_backprop(rws);
        }
    }


    traverse: (override inout this, stmt: meta::selection_statement) = {
        // TODO: Currently assuming that nothing bad happens in the condition
        diff += "if (stmt.get_expression().to_string())$";
        pre_traverse(stmt.get_true_branch());

        if stmt.has_false_branch() {
            diff += "else ";
            pre_traverse(stmt.get_false_branch());
        }
    }

    traverse : (override inout this, expr: meta::expression) = {
        base::traverse(expr);
    }

    traverse: (override inout this, binexpr: meta::assignment_expression) = {
        ada: autodiff_activity_check = (ctx);
        ada.pre_traverse(binexpr.get_lhs_postfix_expression());
        if "_" == binexpr.get_lhs_postfix_expression().to_string() {
            ada.pre_traverse(binexpr.get_terms()[1].get_term());
        }

        if ada.active {
            h_lhs: autodiff_expression_handler = (ctx);
            h_lhs.pre_traverse(binexpr.get_lhs_postfix_expression());

            //  Cpp2 doesn't allow chained assignment, so rhs must be a single logical_or_expression
            assignment_terms := binexpr.get_terms();

            h: autodiff_expression_handler = (ctx);
            h.pre_traverse(assignment_terms[1].get_term());

            is_overwrite := h.primal_expr.contains(h_lhs.primal_expr);
            if overwrite_push_pop && is_overwrite {
                r := ctx*.lookup_variable_declaration(h_lhs.primal_expr);
                diff.add_reverse_primal("cpp2::ad_stack::push<(r.decl)$>((h_lhs.primal_expr)$);");
            }

            if is_overwrite && ctx*.is_reverse() {
                t_b := ctx*.gen_temporary() + ctx*.rws_suffix;
                h.gen_assignment(h_lhs.primal_expr, h_lhs.fwd_expr, t_b);
                append(h);
                diff.add_reverse_backprop("(h_lhs.rws_expr)$ = 0.0;\n");
                diff.add_reverse_backprop("(t_b)$ := (h_lhs.rws_expr)$;\n");
            }
            else {
                h.gen_assignment(h_lhs.primal_expr, h_lhs.fwd_expr, h_lhs.rws_expr);
                append(h);
            }

            if overwrite_push_pop && is_overwrite {
                r := ctx*.lookup_variable_declaration(h_lhs.primal_expr);
                diff.add_reverse_backprop("(h_lhs.primal_expr)$ = cpp2::ad_stack::pop<(r.decl)$>();");
            }

            // Simple overwrite check
            if is_overwrite {
                overwritten.push_back(h_lhs.primal_expr);
            }
        }
        else {
            diff.add_forward(binexpr.to_string() + ";\n");
            diff.add_reverse_primal(binexpr.to_string() + ";\n");
        }
    }

    traverse: (override inout this, binexpr: meta::logical_or_expression) = {
        binexpr.error( "AD: Logical or expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::logical_and_expression) = {
        binexpr.error( "AD: Logical and expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::bit_or_expression) = {
        binexpr.error( "AD: Bit or expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::bit_xor_expression) = {
        binexpr.error( "AD: Bit xor expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::bit_and_expression) = {
        binexpr.error( "AD: Bit and expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::equality_expression) = {
        binexpr.error( "AD: Equality or expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::relational_expression) = {
        binexpr.error( "AD: Relational expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::compare_expression) = {
        binexpr.error( "AD: Compare or expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::shift_expression) = {
        binexpr.error( "AD: Shift or expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::additive_expression) = {
        binexpr.error( "AD: Additive expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, binexpr: meta::multiplicative_expression) = {
        binexpr.error( "AD: Multiplicative expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, isas: meta::is_as_expression) = {
        isas.error( "AD: Is as expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, prefix: meta::prefix_expression) =
    {
        prefix.error( "AD: Prefix expressions are not yet handled as standalone statements." );
    }

    traverse: (override inout this, postfix: meta::postfix_expression) =
    {
        terms := postfix.get_terms();

        is_func  := false;

        (copy i := 0)
        for terms next i += 1 do (term)  {
            if term.get_op() == "." {
                continue;
            }
            if term.get_op() == "(" && i + 1 == terms.ssize() { // Function operator has to be the last
                is_func = true;
                continue;
            } else {
                postfix.error("AD: Unknown operator for standalone postfix expression. op: (term.get_op())$ expr: (postfix)$");
            }
        }

        // Check for function call, everything else is not handled.
        if !(is_func) {
            postfix.error( "AD: Postfix expressions are only handled for function calls, or member function calls. Do not know how to handle: (postfix.to_string())$" );
            return;
        }

        ad: autodiff_expression_handler = (ctx);
        ad.handle_function_call(postfix, false);
        ad.diff += ad.fwd_expr + "\n";
        ad.diff += ad.primal_expr + "\n";
        append(ad);
    }

    traverse: (override inout this, primary: meta::primary_expression) =
    {
        primary.error( "AD: Primary expressions are not yet handled as standalone statements." );
    }
}

autodiff_declaration_handler: type = {
    this: simple_traverser      = ();
    this: autodiff_handler_base;

    base: type == simple_traverser;

    decl: meta::type_or_namespace_declaration;

    is_type_context: bool        = false;
    diff_ad_type   : std::string = "";

    operator=: (out this, ctx_: *autodiff_context, decl_: meta::type_or_namespace_declaration) = {
        autodiff_handler_base = (ctx_);
        decl = decl_;
    }

    traverse: (override inout this, decl_: meta::declaration) = {
        base::traverse(decl_);
    }


    traverse: (override inout this, f: meta::function_declaration) = {
        ctx*.enter_function();

        // TODO: Add activity for member functions

        diff.add_forward("    (f.name())$(ctx*.fwd_suffix)$: (");
        diff.add_reverse_primal("    (f.name())$(ctx*.rws_suffix)$: (");

        //  1. Generate the modified signature
        //  a) Parameters

        for f.get_parameters() do (param) {
            name: std::string = param.get_declaration().name();

            fwd_pass_style := to_string_view(param.get_passing_style());
            rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));

            if "this" ==  name {
                fwd_ad_type := ctx*.get_fwd_ad_type(std::string(decl.name()));
                rws_ad_type := ctx*.get_rws_ad_type(std::string(decl.name()));

                diff.add_forward("(fwd_pass_style)$ (name)$, ");
                diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$: (fwd_ad_type)$, ");

                diff.add_reverse_primal("(fwd_pass_style)$ (name)$, ");
                if ctx*.is_taylor() { // Add forward type for higher order
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$: (fwd_ad_type)$, ");
                }
                diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$: (rws_ad_type)$, ");
            }
            else {
                type := param.get_declaration().type();

                ada: autodiff_activity_check = (ctx);
                ada.pre_traverse(param);

                if ada.active {
                    diff.add_forward("(fwd_pass_style)$ (name)$ : (type)$, ");
                    diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$, ");

                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$, ");
                    if ctx*.is_taylor() {
                        diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$, ");
                    }
                    diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$ : (ctx*.get_rws_ad_type(type))$, ");
                }
                else {
                    diff.add_forward("(fwd_pass_style)$ (name)$ : (type)$, ");
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (type)$, ");
                }

                ctx*.add_variable_declaration(name, type, ada.active);
            }
        }

        //  b) Add arguments for returns that become inputs

        if f.has_non_void_return_type() && f.get_returns().empty() { // TODO: has_non_void_return_type is true for return lists: (r: double) bug/feature?
            // TODO: check if name "r" is available. (Also needs inspection of functions at call sides.)
            if f.has_deduced_return_type() {
                // TODO: Take care of initialization order error.
                diff.add_reverse_primal("inout r(ctx*.rws_suffix)$, ");
            }
            else {
                diff.add_reverse_primal("inout r(ctx*.rws_suffix)$: (ctx*.get_rws_ad_type(f.get_unnamed_return_type()))$, ");
            }
        }
        else {
            for f.get_returns() do (param) {
                name := param.get_declaration().name();
                type := param.get_declaration().type();

                rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));
                diff.add_reverse_primal("(rws_pass_style)$ (name)$(ctx*.rws_suffix)$ : (ctx*.get_rws_ad_type(type))$ , ");
            }
        }

        diff.add_forward(") -> (");
        diff.add_reverse_primal(") -> (");

        //  c) Returns

        if f.has_non_void_return_type() && f.get_returns().empty() { // TODO: has_non_void_return_type is true for return lists: (r: double) bug/feature?
            // TODO: check if name "r" is available. (Also needs inspection of functions at call sides.)
            if f.has_deduced_return_type() {
                // TODO: Take care of initialization order error.
                diff.add_forward("r, r(ctx*.fwd_suffix)$, ");
                diff.add_reverse_primal("r, ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("r(ctx*.fwd_suffix)$,");
                }
            }
            else {
                diff.add_forward("r: (f.get_unnamed_return_type())$ = (), r(ctx*.fwd_suffix)$: (ctx*.get_fwd_ad_type(f.get_unnamed_return_type()))$ = (), ");
                diff.add_reverse_primal("r: (f.get_unnamed_return_type())$ = (), ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("r(ctx*.fwd_suffix)$: (ctx*.get_fwd_ad_type(f.get_unnamed_return_type()))$ = (), ");
                }
            }
        }
        else {
            for f.get_returns() do (param) {
                name := param.get_declaration().name();
                type := param.get_declaration().type();

                fwd_pass_style := to_string_view(param.get_passing_style());
                //rws_pass_style := to_string_view(ctx*.get_reverse_passing_style(param.get_passing_style()));
                diff.add_forward("(fwd_pass_style)$ (name)$ : (param.get_declaration().type())$ = 0.0, ");
                diff.add_forward("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$ = 0.0, ");

                diff.add_reverse_primal("(fwd_pass_style)$ (name)$ : (param.get_declaration().type())$ = 0.0, ");
                if ctx*.is_taylor() {
                    diff.add_reverse_primal("(fwd_pass_style)$ (name)$(ctx*.fwd_suffix)$ : (ctx*.get_fwd_ad_type(type))$ = 0.0, ");
                }

                ctx*.add_variable_declaration("(name)$", "(type)$", true); // TODO_a: Add acitivty check
            }
        }

        diff.add_forward(") = {");
        diff.add_reverse_primal(") = {");

        //  Generate the body

        if !f.has_compound_body() {
            f.error( "temporary alpha limitation: a differentiable function must have a {}-enclosed body" );
            return;
        }


        ad_impl : autodiff_stmt_handler = (ctx*&, f);


        for f.get_compound_body().get_statements() do (stmt)
        {
            ad_impl..pre_traverse(stmt);
        }
        diff.add_forward(ad_impl.diff.fwd);
        diff.add_reverse_primal(ad_impl.diff.rws_primal);
        diff.add_reverse_primal(ad_impl.diff.rws_backprop);

        diff.add_forward("}");
        diff.add_reverse_primal("}");

        ctx*.leave_function();

        if ctx*.is_forward() {
            decl.add_member( diff.fwd );
        }
        if ctx*.is_reverse() {
            decl.add_member( diff.rws_primal );
        }
        diff.reset();

        ctx*.add_as_differentiated(f);
    }


    traverse: (override inout this, o: meta::object_declaration) = {
        ad_name : std::string = "(o.name())$(ctx*.fwd_suffix)$";
        fwd_ad_type : std::string = ctx*.get_fwd_ad_type(o.type());
        ad_init : std::string = "";

        if o.has_initializer() {
            ad: autodiff_expression_handler = (ctx);
            ad.pre_traverse(o.get_initializer());

            assert(ad.diff.empty());
            ad_init = " = " +ad.fwd_expr;
        }

        diff = "(ad_name)$ : (fwd_ad_type)$(ad_init)$;";

        if is_type_context {

            diff_ad_type += "public (diff.fwd)$\n";
        }
        else {
            decl.add_member(diff.fwd);
        }
        diff = "";

        ctx*.add_variable_declaration("(o.name())$", "(o.type())$", true, true); // TODO_a: Add acitivty check
    }


    traverse: (override inout this, t: meta::type_declaration) = {
        ctx*.push_stack(t);
        ad: autodiff_declaration_handler = (ctx, t);
        ad.is_type_context = true;

        for t.get_members()
        do  (m)
        {
            ad.pre_traverse(m);
        }

        ctx*.pop_stack();

        if !ad.diff_ad_type.empty() {
            diff = "(t.name())$(ctx*.fwd_suffix)$ : type = {\n";
            diff += "(ad.diff_ad_type)$";
            diff += "}";

            decl.add_member(diff.fwd);
            diff = "";
        }
    }


    traverse: (override inout this, t: meta::parameter_declaration) = {
        t.error("AD: Do not know how to handle parameter_declaration: (t.to_string())$");
    }


    traverse: (override inout this, stmt: meta::statement) = {
        stmt.error("AD: Do not know how to handle statement in declaration context: (stmt.to_string())$");
    }
}


autodiff: (inout t: meta::type_declaration) =
{

    suffix_token      : std::string_view == "suffix=";
    rws_suffix_token  : std::string_view == "rws_suffix=";
    order_token       : std::string_view == "order=";
    reverse_token     : std::string_view == "reverse";

    args := t.get_arguments();

    suffix    : std::string = "_d";
    rws_suffix: std::string = "_b";
    order     : int         = 1;
    reverse   : bool        = false;
    for args do (arg_str) {
        if arg_str.starts_with("\"") && arg_str.ends_with("\"") {
            arg := arg_str.substr(1, arg_str.ssize() - 2);

            if arg.starts_with(suffix_token) {
                suffix = arg.substr(suffix_token.size());
                continue;
            }
            else if arg.starts_with(rws_suffix_token) {
                suffix = arg.substr(rws_suffix_token.size());
                continue;
            }
            else if arg.starts_with(order_token) {
                if !string_util::string_to_int(arg.substr(order_token.size()), order) {
                    t.error("AD: Could not parse derivative order: (arg.substr(order_token.size()))$");
                    return;
                }
                continue;
            }
            else if arg == reverse_token {
                reverse = true;
                continue;
            }
        }

        t.error("AD: Unknown argument: (arg_str)$");
        return;
    }

    ad_ctx: autodiff_context = (order, reverse);
    ad_ctx.fwd_suffix = suffix;
    ad_ctx.rws_suffix = rws_suffix;

    if t.parent_is_nonglobal_namespace() {
        p := t.get_parent().as_nonglobal_namespace();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);

    }
    else if t.parent_is_type() {
        p := t.get_parent().as_type();
        ad_ctx.create_namespace_stack(p);
        ad: autodiff_declaration_handler = (ad_ctx&, p);
        ad.pre_traverse(t);
    }
    else {
        // TODO: Remove when global namespace is available.
        // Traverse without parent context
        ad_ctx.push_stack(t);
        ad: autodiff_declaration_handler = (ad_ctx&, t);

        for t.get_members()
        do  (m)
        if  m.is_function()
        {
            ad.pre_traverse(m);
        }
        ad_ctx.pop_stack();
    }

    if 1 != order {
        t.add_runtime_support_include( "cpp2taylor.h" );
    }
    if reverse {
        t.add_runtime_support_include( "cpp2ad_stack.h" );
    }

    ad_ctx.finish();

    _ = ad_ctx;
}


//-----------------------------------------------------------------------
//
//  regex - creates regular expressions from members
//
//  Each member that starts with `regex` is replaced by a regular expression
//  of the initializer string. E.g.:
//  ```
//    regex := "ab";
//  ```
//  is replaced with
//  ```
//    regex := ::cpp2::regex::regular_expression<...>;
//  ```
//
error_func: type == std::function< (x: std::string) -> void >;

//  Possible modifiers for a regular expression.
//
expression_flags: @flag_enum<u8> type = 
{
    case_insensitive;             // mod: i
    multiple_lines;               // mod: m
    single_line;                  // mod: s
    no_group_captures;            // mod: n
    perl_code_syntax;             // mod: x
    perl_code_syntax_in_classes;  // mod: xx
}


//  Tokens for regular expressions.
//

// Basic class for a regex token.
//
regex_token: @polymorphic_base type = 
{
    public string_rep: std::string;

    operator=:(out this, str: std::string) = {
        string_rep = str;
    }

    operator=:(out this) = {
        string_rep = "";
    }

    //parse: (inout ctx: parse_context) -> token_ptr;
    generate_code: (virtual this, inout _: generation_context);        // Generate the matching code.
    reverse:       (virtual this) -> std::shared_ptr<regex_token>;     // Create a reverse token for look behind expressions.

    add_groups: (virtual this, inout _: std::set<int>) = {}            // Adds all group indices to the set.
    to_string: (this) -> std::string         = { return string_rep; }  // Create a string representation.
    set_string: (inout this, s: std::string) = { string_rep = s; }     // Set the string representation.
}

token_ptr : type == std::shared_ptr<regex_token>;
token_vec: type == std::vector<token_ptr>;


//  Adds a check in code generation.
//
regex_token_check: @polymorphic_base type = 
{
    this: regex_token;

    check: std::string;

    operator=:(out this, str: std::string, check_: std::string) = {
        regex_token = (str);
        check = check_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check(check + "(" + ctx..match_parameters() + ")");
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_check>(this.to_string(), this.check);
}


//  Adds code in code generation.
//
regex_token_code: @polymorphic_base type = 
{
    this: regex_token;

    code: std::string;

    operator=:(out this, str: std::string, code_: std::string) = {
        regex_token = (str);
        code = code_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add(code);
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_code>(this.to_string(), this.code);
}


//  Token that does not influence the matching. E.g. comment.
//
regex_token_empty: @polymorphic_base type = 
{
    this: regex_token;

    operator=:(out this, str: std::string) = {
        regex_token = (str);
    }

    generate_code: (override this, inout _: generation_context) = {
        // Nothing.
    }

    reverse: (override this) -> token_ptr = shared.new<regex_token_empty>(this.to_string());
}


//  Represents a list of regex tokens as one token.
//
regex_token_list: @polymorphic_base type = 
{
    this: regex_token;

    public tokens: token_vec;

    operator=:(out this, t: token_vec) = {
        regex_token = (gen_string(t));
        tokens = t;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        for tokens do (token) {
            token*..generate_code(ctx);
        }
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        for tokens do (token) {
            token*..add_groups(groups);
        }
    }

    gen_string: (vec: token_vec) -> std::string = {
        r : std::string = "";
        for vec do (token) {
            r += token*..to_string();
        }
        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(tokens..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < tokens.ssize() next (i += 1) {
            reverse_vec[s - 1 -i] = tokens[i]*.reverse();
        }
        return shared.new<regex_token_list>(reverse_vec);
    }
}


//
//  Parse and generation context.
//

//  State of the current capturing group. See '(<pattern>)'
//
parse_context_group_state: @struct<noforward> type = 
{    
    cur_match_list:        token_vec = ();         // Current list of matchers.
    alternate_match_lists: token_vec = ();         // List of alternate matcher lists. E.g. ab|cd|xy.
    modifiers :            expression_flags = ();  // Current modifiers for the group/regular expression.

    //  Start a new alternative.
    next_alternative: (inout this) = {
        new_list: token_vec = ();
        std::swap(new_list, cur_match_list);
        post_process_list(new_list);
        _ = alternate_match_lists..insert(alternate_match_lists..end(), shared.new<regex_token_list>(new_list));
    }

    //  Swap this state with the other one. NOLINTNEXTLINE(performance-noexcept-swap)
    swap: (inout this, inout t: parse_context_group_state) = { // NOLINT(performance-noexcept-swap)
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        std::swap(modifiers, t.modifiers);
    }

    //  Convert this state into a regex token.
    get_as_token: (inout this) -> token_ptr = {
        if alternate_match_lists..empty() {
            post_process_list(cur_match_list);
            return shared.new<regex_token_list>(cur_match_list);
        }
        else {
            next_alternative();
            return shared.new<alternative_token_gen>(alternate_match_lists);
        }
    }

    //  Add a token to the current matcher list.
    add: (inout this, token: token_ptr) = {
        cur_match_list..push_back(token);
    }

    //  True if current matcher list is empty.
    empty: (this) -> bool = cur_match_list..empty();

    
    //  Apply optimizations to the matcher list.
    post_process_list: (inout list: token_vec) = {
        // Merge all characters
        merge_pos := list..begin();
        while merge_pos != list..end() next (merge_pos++) {
            if merge_pos** is char_token {
                combine_pos := merge_pos + 1;
                while combine_pos != list..end() && combine_pos** is char_token { // The erase advances combine_pos
                    (merge_pos** as char_token)..append(combine_pos** as char_token);
                    combine_pos = list..erase(combine_pos);
                }
            }
        }
    }
}


//  State for the branch reset. Takes care of the group numbering. See '(|<pattern>)'.
//
parse_context_branch_reset_state: @struct<noforward> type = 
{
    is_active : bool = false; // If we have a branch reset group.
    cur_group : int  = 1;     // Next group identifier. 0 == global capture group.
    max_group : int  = 1;     // Maximum group identifier generated.
    from      : int  = 1;     // Starting identifier on new alternative branch.

    //  Next group identifier.
    next: (inout this) -> int = {
        g := cur_group;
        cur_group += 1;
        max_group = max(max_group, cur_group);

        return g;
    }

    //  Set next group identifier.
    set_next: (inout this, g: int) = {
        cur_group = g;
        max_group = max(max_group, g);
    }

    //  Start a new alternative branch.
    next_alternative: (inout this) = {
        if is_active {
            cur_group = from;
        }
    }

    //  Initialize for a branch reset group.
    set_active_reset: (inout this, restart: int) = {
        is_active = true;
        cur_group = restart;
        from      = restart;
        max_group = restart;
    }
}


//  Context during parsing of the regular expressions.
// 
//  Keeps track of the distributed group identifiers, current parsed group and branch resets.
//
parse_context: type = 
{
    regex: std::string_view;   // Regular expression string.
    pos:   size_t = 0;         // Current parsing position.
    root:  token_ptr;          // Token representing the regular expression.

    public is_start_match: bool = false;  // If the regex contains \G at the beginning.

    cur_group_state:        parse_context_group_state = ();
    cur_branch_reset_state: parse_context_branch_reset_state = ();

    
    public named_groups:  std::map<std::string, int> = ();

    error_out: error_func; // TODO: Declaring std::function<void(std::string)> fails for cpp2.
    has_error: bool      = false;

    operator=:(out this, r: std::string_view, e) = {
        regex = r;
        root = shared.new<regex_token_empty>("");
        error_out = e;
    }

    //  State management functions
    //

    //  Returned group state needs to be stored and provided in `end_group`.
    start_group: (inout this) -> parse_context_group_state = 
    {
        old_state: parse_context_group_state = ();
        old_state..swap(cur_group_state);
        cur_group_state.modifiers = old_state.modifiers;

        return old_state;
    }

    //  `old_state` argument needs to be from start group.
    end_group: (inout this, old_state: parse_context_group_state) -> token_ptr =
    {
        inner := cur_group_state..get_as_token();
        cur_group_state = old_state;
        return inner;
    }

    get_modifiers: (this) -> expression_flags = {
        return cur_group_state.modifiers;
    }

    set_modifiers: (inout this, mod: expression_flags) = {
        cur_group_state.modifiers = mod;
    }

    //  Branch reset management functions
    //

    branch_reset_new_state: (inout this) -> parse_context_branch_reset_state = 
    {
        old_state: parse_context_branch_reset_state = ();
        std::swap(old_state, cur_branch_reset_state);

        cur_branch_reset_state..set_active_reset(old_state.cur_group);
        return old_state;
    }

    branch_reset_restore_state: (inout this, old_state: parse_context_branch_reset_state) = 
    {
        max_group := cur_branch_reset_state.max_group;
        cur_branch_reset_state = old_state;
        cur_branch_reset_state..set_next(max_group);
    }

    next_alternative: (inout this) = 
    {
        cur_group_state..next_alternative();
        cur_branch_reset_state..next_alternative();
    }

    //  Regex token management
    //
    add_token: (inout this, token: token_ptr) = {
        cur_group_state..add(token);
    }

    has_token: (this) -> bool = {
        return !cur_group_state..empty();
    }

    pop_token: (inout this) -> token_ptr = 
    {
        r : token_ptr = nullptr;
        if has_token() {
            r = cur_group_state.cur_match_list..back();
            cur_group_state.cur_match_list..pop_back();
        }

        return r;
    }

    get_as_token: (inout this) -> token_ptr = {
        return root;
    }

    //  Group management
    //
    get_cur_group: (this) -> int = {
        return cur_branch_reset_state.cur_group;
    }

    next_group: (inout this) -> int = {
        return cur_branch_reset_state..next();
    }

    set_named_group: (inout this, name: std::string, id: int) = 
    {
        if !named_groups..contains(name) { // Redefinition of group name is not an error. The left most one is retained.
            named_groups[name] = id;
        }
    }

    get_named_group: (this, name: std::string) -> int = 
    {
        iter := named_groups..find(name);
        if iter == named_groups..end() {
             return -1;
        }
        else {
            return iter*.second;
        }
    }
    
    //  Position management functions
    //
    current: (this) -> char = { return regex[pos]; }

    //  Get the next token in the regex, skipping spaces according to the parameters. See `x` and `xx` modifiers.
    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t = 
    {
        perl_syntax := false;
        if !no_skip {
            if in_class {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax) && get_modifiers()..has(expression_flags::perl_code_syntax_in_classes);
            }
            else {
                perl_syntax = get_modifiers()..has(expression_flags::perl_code_syntax);
            }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex..size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex..find('\n', cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex..size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        //  Check for end of file.
        if cur > regex..size() {
            cur = regex..size();
        }
        return cur;
    }

    //  Return true if next token is available.
    private next_impl: (inout this, in_class: bool, no_skip: bool) -> bool = 
    {
        pos = get_next_position(in_class, no_skip);
        if pos != regex..size() {
            return true;
        }
        else {
            return false;
        }
    }

    next         : (inout this) = next_impl(false, false);
    next_in_class: (inout this) = next_impl( true, false);
    next_no_skip : (inout this) = next_impl(false,  true);

    next_n: (inout this, n: int) -> bool = {
        r := true;
        cur := 0;
        while r && cur < n next (r = next()) {
            cur += 1;
        }
        return r;
    }

    has_next: (this) -> bool = { return pos < regex..size(); }

    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool = 
    {
        end:= pos; // NOLINT(clang-analyzer-deadcode.DeadStores)
        if any {
            end = regex..find_first_of(e, pos);
        }
        else {
            end = regex..find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex..substr(pos, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        = grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               = grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) = grab_until_impl(e, out r, true);

    grab_n: (inout this, in n: int, out r: std::string) -> bool = 
    {
        if pos + n as size_t <= regex..size() {
            r = regex..substr(pos, n as size_t);
            pos += (n as size_t) - 1;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string = 
    {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex..find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string::npos {
            r = regex..substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex..substr(start);
            pos = regex..size() - 1;
        }
        return r;
    }

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex..size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek         : (in this) = peek_impl(false);
    peek_in_class: (in this) = peek_impl( true);


    //  Parsing functions
    //
    parser_group_modifiers: (inout this, change_str: std::string, inout parser_modifiers: expression_flags) -> bool = 
    {
        is_negative := false;
        is_reset    := false;

        apply := :(flag: expression_flags) = {
            if is_negative&$* {
                parser_modifiers&$*..clear(flag);
            }
            else {
                parser_modifiers&$*..set(flag);
            }
        };

        iter := change_str..begin();
        while iter != change_str..end() next (iter++) 
        {
            cur := iter*;
            if cur == '^' {
                is_reset = true;
                parser_modifiers = expression_flags::none;
            }
            else if cur == '-' {
                if is_reset { _= error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else if cur == 'n' { apply(expression_flags::no_group_captures); }
            else if cur == 'x' {
                if (iter + 1) == change_str..end() || (iter + 1)* != 'x' {
                    // x modifier
                    apply(expression_flags::perl_code_syntax);

                    // Just x unsets xx and remove x also removes xx
                    parser_modifiers..clear(expression_flags::perl_code_syntax_in_classes);
                }
                else { // xx modifier
                    // xx also sets or unsets x
                    apply(expression_flags::perl_code_syntax);
                    apply(expression_flags::perl_code_syntax_in_classes);

                    iter++; // Skip the second x
                }
            }
            else {
                _= error("Unknown modifier: (cur)$"); return false;
            }
        }

        return true;
    }

    parse_until: (inout this, term: char) -> bool = {
        cur_token: token_ptr = ();

        while valid() next _ = next()
        {
            if term == current() { break; }

            cur_token = nullptr;

            if !cur_token && valid() { cur_token = alternative_token::parse(this); }
            if !cur_token && valid() { cur_token = any_token::parse(this); }
            if !cur_token && valid() { cur_token = class_token::parse(this); }
            if !cur_token && valid() { cur_token = escape_token_parse(this); }
            if !cur_token && valid() { cur_token = global_group_reset_token_parse(this); }
            if !cur_token && valid() { cur_token = group_ref_token::parse(this); }
            if !cur_token && valid() { cur_token = group_token::parse(this); }
            if !cur_token && valid() { cur_token = hexadecimal_token_parse(this); }
            if !cur_token && valid() { cur_token = line_end_token_parse(this); }
            if !cur_token && valid() { cur_token = line_start_token_parse(this); }
            if !cur_token && valid() { cur_token = named_class_token_parse(this); }
            if !cur_token && valid() { cur_token = octal_token_parse(this); }
            if !cur_token && valid() { cur_token = range_token::parse(this); }
            if !cur_token && valid() { cur_token = special_range_token::parse(this); }
            if !cur_token && valid() { cur_token = start_match_parse(this); }
            if !cur_token && valid() { cur_token = word_boundary_token_parse(this); }

            // Everything else is matched as it is.
            if !cur_token && valid() { cur_token = char_token::parse(this); }

            if cur_token && valid() {
                add_token(cur_token);
            } else {
                return false;
            }
        }

        return true;
    }

    parse: (inout this, modifiers: std::string) -> bool = 
    {

        flags : expression_flags = ();
        if !parser_group_modifiers(modifiers, flags) { return false; }
        set_modifiers(flags);

        r := parse_until('\0');
        if r {
            root = cur_group_state..get_as_token();
        }

        return r;
    }

    //  Misc functions

    get_pos:   (this)                             = pos;
    get_range: (this, start: size_t, end: size_t) = std::string(regex..substr(start, end - start + 1));
    valid:     (this) -> bool                     = { return has_next() && !has_error; }

    error: (inout this, err: std::string) -> token_ptr = {
        has_error = true;
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (err)$");
        return nullptr;
    }
}


//  Context for one function generation. Generation of functions can be interleaved,
//  therefore we buffer the code for one function here.
//
generation_function_context: @struct<noforward> type = {
    code: std::string = "";
    tabs: std::string = "";

    add_tabs: (inout this, c: int) = {
        i: int = 0;
        while i < c next i += 1 {
            tabs += "  ";
        }
    }

    remove_tabs: (inout this, c: int) = {
        tabs = tabs..substr(0, (c as size_t) * 2);
    }
}


//  Context for generating the state machine.
generation_context: type = 
{
    gen_stack: std::vector<generation_function_context> = (1); // Element 0 contains all the code.

    matcher_func: int         = 0;
    reset_func:   int         = 0;
    temp_name:    int         = 0;
    entry_func:   std::string = "";

    //  Generation helpers
    //
    match_parameters: (this) -> std::string = { return "r.pos, ctx"; }

    //  Code generation.

    //  Add code line.
    add: (inout this, s: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$(s)$\n";
    }

    //  Add check for token. The check needs to be a function call that returns a boolean.
    add_check: (inout this, check: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$if !cpp2::regex::(check)$ { r.matched = false; break; }\n";
    }

    //  Add a stateful check. The check needs to return a `match_return`.
    add_statefull: (inout this, next_func: std::string, check: std::string) = 
    {
        end_func_statefull(check);

        name := next_func..substr(0, next_func..size() - 2);
        start_func_named(name);
    }

    protected start_func_named: (inout this, name: std::string) = 
    {
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): <Iter> (this, cur: Iter, forward ctx, other) -> cpp2::regex::match_return<Iter> = {\n";
        cur*.code += "(cur*.tabs)$    r := ctx..pass(cur);\n";
        cur*.code += "(cur*.tabs)$    do {\n";
        cur*..add_tabs(3);
    }

    protected start_func: (inout this) -> std::string = 
    {
        name := gen_func_name();
        start_func_named(name);
        return name + "()";
    }

    protected end_func_statefull: (inout this, s: std::string) = 
    {
        cur := get_current();
        cur*..remove_tabs(3);
        cur*.code += "\n";
        cur*.code += "(cur*.tabs)$    } while false;\n";
        cur*.code += "(cur*.tabs)$    if r.matched {\n";
        cur*.code += "(cur*.tabs)$      r = (s)$;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    else {\n";
        cur*.code += "(cur*.tabs)$      r.pos = ctx.end;\n";
        cur*.code += "(cur*.tabs)$    }\n";
        cur*.code += "(cur*.tabs)$    _ = ctx;\n";
        cur*.code += "(cur*.tabs)$    return r;\n";
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();
    }

    //  Generate the function for a token.
    generate_func: (inout this, token: token_ptr) -> std::string = 
    {
        name := start_func();
        token*..generate_code(this);
        end_func_statefull("other((match_parameters())$)");

        return name;
    }

    //  Generate the reset for a list of group identifiers.
    generate_reset: (inout this, groups: std::set<int>) -> std::string = 
    {
        if groups..empty() {
            return "cpp2::regex::no_reset()";
        }

        name := gen_reset_func_name();
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct<noforward> type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, inout ctx) = {\n";
        for groups do (g) {
            cur*.code += "(cur*.tabs)$  ctx..set_group_invalid((g)$);\n";
        }
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();

        return name + "()";
    }

    //  Name generation
    //
    protected gen_func_name: (inout this) -> std::string = {
        cur_id : = matcher_func;
        matcher_func += 1;
        return "func_(cur_id)$";
    }

    next_func_name: (inout this) -> std::string = {
        return gen_func_name() + "()";
    }

    protected gen_reset_func_name: (inout this) -> std::string = {
        cur_id : = reset_func;
        reset_func += 1;
        return "reset_(cur_id)$";
    }

    gen_temp: (inout this) -> std::string = {
        cur_id := temp_name;
        temp_name += 1;
        return "tmp_(cur_id)$";
    }

    //  Context management
    //
    new_context: (inout this) -> *generation_function_context = {
        gen_stack..push_back(generation_function_context());
        cur := get_current();
        cur*.tabs = "    ";

        return cur;
    }

    finish_context: (inout this) = {
        cur := get_current();
        base := get_base();
        base*.code += cur*.code;

        gen_stack..pop_back();
    }

    //  Misc functions
    //
    private get_current: (inout this) -> *generation_function_context = {
        return gen_stack..back()&;
    }

    private get_base: (inout this) -> *generation_function_context = {
        return gen_stack[0]&;
    }

    get_entry_func: (this) -> std::string = {
        return entry_func;
    }

    create_named_group_lookup: (this, named_groups: std::map<std::string, int>) -> std::string = 
    {
        res: std::string = "get_named_group_index: (name) -> int = {\n";

        //  Generate if selection.
        sep: std::string = "";
        for named_groups do (cur) {
            res += "(sep)$if name == \"(cur.first)$\" { return (cur.second)$; }";
            sep = "else ";
        }

        //  Generate else branch or return if list is empty.
        if named_groups..empty() {
            res += "  _ = name;\n";
            res += "  return -1;\n";
        }
        else {
            res += "  else { return -1; }\n";
        }
        res += "}\n";
        return res;
    }


    //  Run the generation for the token.
    run: (inout this, token: token_ptr) -> std::string = {
        entry_func = generate_func(token);

        return get_base()*.code;
    }
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen.
//
alternative_token: @polymorphic_base type = 
{
    this: regex_token_empty = ("");  // No code gen here. alternative_token_gen is created in the parse_context

    operator=:(out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx..current() != '|' { return nullptr; }

        if !ctx..has_token() { return ctx..error("Alternative with no content."); }
        ctx..next_alternative();
        return shared.new<alternative_token>();
    }
}

alternative_token_gen: @polymorphic_base type = 
{
    this: regex_token;

    alternatives: token_vec;

    operator=: (out this, a: token_vec) = {
        regex_token = gen_string(a);
        alternatives = a;
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        functions: std::string = "";

        for alternatives do (cur) {
            groups: std::set<int> = ();
            cur*..add_groups(groups);

            functions += ", " + ctx..generate_func(cur);
            functions += ", " + ctx..generate_reset(groups);
        }

        next_name := ctx..next_func_name();

        ctx..add_statefull(next_name, "cpp2::regex::alternative_token_matcher<char>::match((ctx..match_parameters())$, other, (next_name)$ (functions)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = 
    {
        for alternatives do (cur) {
            cur*..add_groups(groups);
        }
    }

    gen_string: (a: token_vec) -> std::string = 
    {
        r: std::string = "";
        sep: std::string = "";

        for a do (cur) {
            r += sep + cur*..to_string();
            sep = "|";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        s : int = cpp2::unchecked_narrow<int>(alternatives..size());

        reverse_vec: token_vec = ();
        reverse_vec..resize(s);

        i: int = 0;
        while i < s next (i += 1) {
            reverse_vec[i] = alternatives[i]*.reverse(); // We only reverse the alternatives, not the order in which they are checked.
        }
        return shared.new<alternative_token_gen>(reverse_vec);
    }
}


//  Regex syntax: .
//
any_token: @polymorphic_base type = 
{
    this: regex_token_check = (".");

    operator=:(out this, single_line: bool) = {
        regex_token_check = (".", "any_token_matcher<char, (single_line)$>");
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        if '.' != ctx..current() { return nullptr;}

        return shared.new<any_token>(ctx..get_modifiers()..has(expression_flags::single_line));
    }
}

//  Regex syntax: (?><matcher>)  Example: a(?>bc|c)c
//
atomic_group_token: @polymorphic_base type =
{
    this                 : regex_token = ("");

    public  inner_token : token_ptr   = nullptr;

    operator=: (out this) = {}

    reverse: (override this) -> token_ptr = {
        r := shared.new<atomic_group_token>();
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) =
    {
        inner_name := ctx..generate_func(inner_token);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::atomic_group_matcher<char>((ctx..match_parameters())$, (inner_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}

//  Regex syntax: a
//
char_token: @polymorphic_base type = 
{
    this: regex_token;

    token      : std::string;
    ignore_case: bool;

    operator=: (out this, t: char, ignore_case_: bool) = {
        regex_token = (std::string(1, t));
        token = t;
        ignore_case = ignore_case_;
    }

    operator=: (out this, t: std::string, ignore_case_: bool) = {
        regex_token = (t);
        token = t;
        ignore_case = ignore_case_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx..current(), ctx..get_modifiers()..has(expression_flags::case_insensitive));
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        if ignore_case {
            upper: std::string = token;
            lower: std::string = token;

            (copy i: size_t = 0) while i < token..size() next i += 1 {
                lower[i] = string_util::safe_tolower(token[i]);
                upper[i] = string_util::safe_toupper(token[i]);
            }

            if upper != lower {
                gen_case_insensitive(lower, upper, ctx);
            }
            else {
                gen_case_sensitive(ctx);
            }
        }
        else {
            gen_case_sensitive(ctx);
        }
    }

    gen_case_insensitive: (this, lower: std::string, upper: std::string, inout ctx: generation_context) = 
    {
        name: std::string = "str_(ctx..gen_temp())$";
        lower_name: std::string = "lower_(name)$";
        upper_name: std::string = "upper_(name)$";
        size := token..size();
        ctx..add("(lower_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(lower))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("(upper_name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(upper))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if !((lower_name)$[i] == r.pos[i] || (upper_name)$[i] == r.pos[i]) { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    gen_case_sensitive: (this, inout ctx: generation_context) = 
    {
        name: std::string = "str_(ctx..gen_temp())$";
        size := token..size();
        ctx..add("(name)$ : std::array<char, (size)$ + 1> = \"(add_escapes(token))$\";"); // TODO: Add constexpr when Issue https://github.com/hsutter/cppfront/issues/1104 is resolved.
        ctx..add("if std::distance(r.pos, ctx.end) < (size)$ {");
        ctx..add("    r.matched = false;");
        ctx..add("    break;");
        ctx..add("}");
        ctx..add("");
        ctx..add("(copy i : int = 0) while i < (size)$ next (i += 1) {");
        ctx..add("    if (name)$[i] != r.pos[i] { r.matched = false; }");
        ctx..add("}");
        ctx..add("");
        ctx..add("if r.matched { r.pos += (size)$; }");
        ctx..add("else { break; }");
    }

    add_escapes: (this, copy str: std::string) -> std::string = 
    {
        str = string_util::replace_all(str, "\\", "\\\\");
        str = string_util::replace_all(str, "\a", "\\a");
        str = string_util::replace_all(str, "\f", "\\f");
        str = string_util::replace_all(str, "\x1b", "\" \"\\x1b\" \""); // Generate a separated string. This prevents
                                                                        // situations like `\x1bblub` from generating
                                                                        // wrong hex characters.
        str = string_util::replace_all(str, "\n", "\\n");
        str = string_util::replace_all(str, "\r", "\\r");
        str = string_util::replace_all(str, "\t", "\\t");

        return str;
    }

    reverse: (override this) -> token_ptr = {
        reverse_str: std::string = token;
        std::reverse(reverse_str..begin(), reverse_str..end());
        return shared.new<char_token>(reverse_str, ignore_case);
    }

    append: (inout this, that) = {
        this.token += that.token;
        this.string_rep += that.string_rep;
    }
}


//  Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_token: @polymorphic_base type = 
{
    this            : regex_token = ();

    negate          : bool;
    case_insensitive: bool;
    class_str       : std::string;

    operator=: (out this, negate_: bool, case_insensitive_: bool, class_str_: std::string, str: std::string) = 
    {
        regex_token = str;
        negate = negate_;
        case_insensitive = case_insensitive_;
        class_str = class_str_;
    }

    //  TODO: Rework class generation: Generate check functions for classes.
    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '[' { return nullptr; }

        start_pos := ctx..get_pos();

        supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                       "lower", "print", "punct", "space", "upper", "word", "xdigit");

        classes: std::vector<std::string> = ();

        //  First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        is_negate := false;
        first     := true;
        range     := false;
        while ctx..next_in_class() && (ctx..current() != ']' || first) 
        {
            if ctx..current() == '^' 
            {
                is_negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }

            if ctx..current() == '[' && ctx..peek_in_class() == ':' 
            {
                //  We have a character class.
                _ = ctx..next_n(2);  // Skip [:

                name: std::string = "";
                if !ctx..grab_until(":]", out name) { return ctx..error("Could not find end of character class."); }
                if supported_classes..end() == std::find(supported_classes..begin(), supported_classes..end(), name) {
                    return ctx..error("Unsupported character class. Supported ones are: (string_util::join(supported_classes))$");
                }

                classes..push_back("[:(name)$:]");

                _ = ctx..next(); // Skip ':' pointing to the ending ']'.
            }
            else if ctx..current() == '\\' 
            {
                if ctx..next_no_skip()  && (ctx..current() != ']') 
                {
                    if  ' ' == ctx..current() 
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax) 
                        && ctx..get_modifiers()..has(expression_flags::perl_code_syntax_in_classes) 
                    {
                        classes..push_back(std::string(1, ctx..current()));
                    }
                    else {
                        name := "";
                        if      'd' == ctx..current() { name = "short_digits"; }
                        else if 'D' == ctx..current() { name = "short_not_digits"; }
                        else if 'h' == ctx..current() { name = "short_hor_space"; }
                        else if 'H' == ctx..current() { name = "short_not_hor_space"; }
                        else if 's' == ctx..current() { name = "short_space"; }
                        else if 'S' == ctx..current() { name = "short_not_space"; }
                        else if 'v' == ctx..current() { name = "short_ver_space"; }
                        else if 'V' == ctx..current() { name = "short_not_ver_space"; }
                        else if 'w' == ctx..current() { name = "short_word"; }
                        else if 'W' == ctx..current() { name = "short_not_word"; }
                        else {
                            return ctx..error("Unknown group escape.");
                        }
                        classes..push_back("[:(name)$:]");
                    }
                } else {
                    return ctx..error("Escape without a following character.");
                }
            }
            else if ctx..current() == '-' 
            {
                if first { // Literal if first entry.
                    classes..push_back("(ctx..current())$");
                } else {
                    range = true;
                }
            }
            else 
            {
                if range { // Modify last element to be a range.
                    classes..back() += "-(ctx..current())$";
                    range = false;
                }
                else {
                    classes..push_back("(ctx..current())$");
                }
            }

            first = false;
        }

        if ctx..current() != ']' {
            return ctx..error("Error end of character class definition before terminating ']'.");
        }
        end_pos := ctx..get_pos();

        if range { // If '-' is last entry treat it as a literal char.
            classes..push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur) 
        {
            if cur..starts_with("[:") {
                name := cur..substr(2, cur..size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur..size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner      := string_util::join(classes);
        string_rep := ctx..get_range(start_pos, end_pos);
        return shared.new<class_token>(
            is_negate, 
            ctx..get_modifiers()..has(expression_flags::case_insensitive), 
            inner, 
            string_rep
            );
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<class_token>(
            negate,
            case_insensitive,
            class_str,
            to_string()
            );
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        ctx..add_check("class_token_matcher<char, (negate)$, (case_insensitive)$, (class_str)$>::match((ctx..match_parameters())$)");
    }

    private create_matcher: (name: std::string, template_arguments: std::string) -> std::string = 
    {
        sep := ", ";
        if template_arguments..empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }
}


//  Regex syntax: \a or \n or \[
//
escape_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }


    if std::string::npos == std::string("afenrt^.[]()*{}?+|\\")..find(ctx..peek()) {
        return nullptr;
    }

    _ = ctx..next(); // Skip escape

    if std::string::npos != std::string("afenrt\\")..find(ctx..current()) 
    {
        // Escape of string special char
        t : char = '\0';
        if      'a' == ctx..current() { t = '\a'; }
        else if 'f' == ctx..current() { t = '\f'; }
        else if 'e' == ctx..current() { t = '\x1b'; }
        else if 'n' == ctx..current() { t = '\n'; }
        else if 'r' == ctx..current() { t = '\r'; }
        else if 't' == ctx..current() { t = '\t'; }
        else if '\\' == ctx..current() { t = '\\'; }
        else { return ctx..error("Internal: missing switch case for special escape."); }

        r: = shared.new<char_token>(t, false);
        r*..set_string("\\(ctx..current())$");
        return r;
    } 
    else 
    {
        // Escape of regex special char
        r := shared.new<char_token>(ctx..current(), false);
        r*..set_string("\\(ctx..current())$");
        return r;
    }

}


//  Regex syntax: \K Example: ab\Kcd
//
global_group_reset_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'K') { return nullptr; }

    _ = ctx..next(); // Skip escape.
    return shared.new<regex_token_code>("\\K", "ctx..set_group_start(0, r.pos);");
}


//  Regex syntax: \<number>  Example: \1
//                \g{name_or_number}
//                \k{name_or_number}
//                \k<name_or_number>
//                \k'name_or_number'
//
group_ref_token: @polymorphic_base type = 
{
    this            : regex_token = ();

    id              : int;
    case_insensitive: bool;
    reverse_eval    : bool;

    operator=:(out this, id_: int, case_insensitive_: bool, reverse_: bool, str: std::string) =
    {
        regex_token      = str;
        id               = id_;
        case_insensitive = case_insensitive_;
        reverse_eval     = reverse_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '\\' { return nullptr; }

        str : std::string = "\\";
        group : std::string = "";

        if '0' <= ctx..peek() <= '9' 
        {
            _ = ctx..next(); // Skip escape
            group = ctx..grab_number();

            if group..size() >= 3 as size_t 
            {
                // Octal syntax (\000) not a group ref matcher.
                number := 0;
                if !string_util::string_to_int(group, number, 8) { return ctx..error("Could not convert octal to int."); }

                number_as_char : char = unchecked_narrow<char>(number);

                token := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
                token*..set_string("\\(string_util::int_to_string<8>(number_as_char as int))$");

                return token;
            }

            str += group;
            // Regular group ref
        }
        else if 'g' == ctx..peek() 
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip g

            str += "g";

            if ctx..current() == '{' {
                str += "{";
                if !(ctx..next() && ctx..grab_until('}', out group)) { return ctx..error("No ending bracket."); }

                str += group + "}";
            }
            else {
                group = ctx..grab_number();
                str += group;
            }
        }
        else if 'k' == ctx..peek() 
        {
            _ = ctx..next(); // Skip escape
            if !ctx..next() { return ctx..error("Group escape without a following char."); } // Skip k

            str += "k";

            term_char := '\0';
            if ctx..current() == '{' { term_char = '}'; }
            else if ctx..current() == '<' { term_char = '>'; }
            else if ctx..current() == '\'' { term_char = '\''; }
            else {
                return ctx..error("Group escape has wrong operator.");
            }

            str += ctx..current();

            if !(ctx..next() && ctx..grab_until(term_char, out group)) { return ctx..error("No ending bracket."); }

            str += group + term_char;
        }
        else 
        {
            // No group ref matcher
            return nullptr;
        }

        // Parse the group
        group = string_util::trim_copy(group);
        group_id : int = 0;
        if string_util::string_to_int(group, group_id) 
        {
            if group_id < 0 {
                group_id = ctx..get_cur_group() + group_id;

                if group_id < 1 { // Negative and zero are no valid groups.
                    return ctx..error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                }
            }

            if group_id >= ctx..get_cur_group() {
                return ctx..error("Group reference is used before the group is declared.");
            }
        }
        else 
        {
            // Named group
            group_id = ctx..get_named_group(group);
            if -1 == group_id { return ctx..error("Group names does not exist. (Name is: (group)$)");}
        }

        return shared.new<group_ref_token>(group_id, ctx..get_modifiers()..has(expression_flags::case_insensitive), false, str);
    }

    reverse: (override this) -> token_ptr = {
        return shared.new<group_ref_token>(id, case_insensitive, !reverse_eval, to_string());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx..add_check("group_ref_token_matcher<char, (id)$, (case_insensitive)$, (reverse_eval)$>((ctx..match_parameters())$)");
    }
}


//  Regex syntax: (<tokens>)      Example: (abc)
//                (?<modifiers)            (?i)
//                (?<modifiers>:<tokens>)  (?i:abc)
//                (?<<name>>:<tokens>)     (?<start>:abc)
//                (?#<comment>)            (#Step 1 finished)
//                (?|<tokens>)             (?|(abc)|(cde))
//                (?=<tokens>)             (?=abc)
//                (?!<tokens>)             (?!abc)
//                (*<name>:<tokens)        (*pla:abc)
//
group_token: @polymorphic_base type = 
{
    this: regex_token = ();

    number:       int       = -1;
    reverse_eval: bool      = false;
    inner:        token_ptr = nullptr;

    parse_lookahead_lookbehind: (inout ctx: parse_context, syntax: std::string, lookahead: bool, positive: bool) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner*..to_string())$)");

        if !lookahead {
            r*.inner = r*.inner*..reverse();
        }

        return r;
    }

    parse_atomic_pattern: (inout ctx: parse_context, syntax: std::string) -> token_ptr =
    {
        _ = ctx..next(); // Skip last token defining the syntax

        r := shared.new<atomic_group_token>();

        old_state := ctx..start_group();
        if !ctx..parse_until(')') { return ctx..error("Group without a closing bracket."); }
        r*.inner_token = ctx..end_group(old_state);
        r*..set_string("((syntax)$(r*.inner_token*..to_string())$)");

        return r;
    }

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        if ctx..current() != '(' { return nullptr; }

        has_id              :=  !ctx..get_modifiers()..has(expression_flags::no_group_captures);
        has_pattern         := true;
        group_name          : std::string = "";
        group_name_brackets := true;
        modifiers           : std::string = "";
        modifiers_change_to : =  ctx..get_modifiers();

        //  Skip the '('
        if !ctx..next() { return ctx..error("Group without closing bracket."); }

        if ctx..current() == '?' 
        {
            //  Special group
            if !ctx..next_no_skip() { return ctx..error("Missing character after group opening.");  }

            if  ctx.current() == '<' && (ctx.peek() == '=' || ctx.peek() == '!')
            {
                // Lookbehind
                _ = ctx.next(); // Skip the '<'

                return parse_lookahead_lookbehind(ctx, "?<(ctx..current())$", false, ctx..current() == '=');
            }
            else if ctx..current() == '<' || ctx..current() == '\''
            {
                //  Named group
                end_char := ctx..current();
                if end_char == '<' {
                    end_char = '>';
                } else {
                    group_name_brackets = false;
                }
                has_id = true; // Force id for named groups.
                if !ctx..next() /* skip '<' */ { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..grab_until(end_char, out group_name) { return ctx..error("Missing ending bracket for named group.");  }
                if !ctx..next() { return ctx..error("Group without closing bracket."); }
            }
            else if ctx..current() == '#' 
            {
                //  Comment
                comment_str : std::string = "";
                _ = ctx..next(); // Skip #
                if !ctx..grab_until(")", out comment_str) { return ctx..error("Group without closing bracket."); }
                //  Do not add comment. Has problems with ranges.

                //  Pop token and add a list. This fixes comments between a token and a range
                if ctx..has_token() {
                    list : token_vec = ();
                    list..push_back(ctx..pop_token());
                    list..push_back(shared.new<regex_token_empty>("(?#(comment_str)$)"));

                    return shared.new<regex_token_list>(list);
                }
                else {
                    return shared.new<regex_token_empty>("(?#(comment_str)$)");
                }
            }
            else if ctx..current() == '|' 
            {
                //  Branch reset group

                if !ctx..next() /* skip '|' */ { return ctx..error("Missing ending bracket for named group.");  }

                old_parser_state := ctx..start_group();
                old_branch_state  := ctx..branch_reset_new_state();
                if !ctx..parse_until(')') { return nullptr; }
                ctx..branch_reset_restore_state(old_branch_state);
                inner_ := ctx..end_group(old_parser_state);

                list: token_vec = (shared.new<regex_token_empty>("(?|"), inner_, shared.new<regex_token_empty>(")"));
                return shared.new<regex_token_list>(list);
            }
            else if ctx..current() == '=' || ctx..current() == '!' 
            {
                // Lookahead
                return parse_lookahead_lookbehind(ctx, "?(ctx..current())$", true, ctx..current() == '=');
            }
            else if ctx..current() == '>'
            {
                // Atomic pattern
                return parse_atomic_pattern(ctx, "?(ctx..current())$");
            }
            else 
            {
                //  Simple modifier
                has_id = false;
                if !ctx..grab_until_one_of("):", out modifiers) { return ctx..error("Missing ending bracket for group."); }
                if !ctx..parser_group_modifiers(modifiers, modifiers_change_to) {
                     return nullptr;
                }

                if ')' == ctx..current() {
                    has_pattern = false;
                }
                else {
                    if !ctx..next() /* skip ':' */ { return ctx..error("Missing ending bracket for group.");  }
                }
            }
        }
        else if ctx..current() == '*' 
        {
            //  Named pattern
            _ = ctx..next(); // Skip *.
            name: std::string = "";
            if !ctx..grab_until(':', out name) { return ctx..error("Missing colon for named pattern.");  }

            if name == "pla" || name == "positive_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, true);
            }
            else if name == "nla" || name == "negative_lookahead" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", true, false);
            }
            else if name == "plb" || name == "positive_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, true);
            }
            else if name == "nlb" || name == "negative_lookbehind" {
                return parse_lookahead_lookbehind(ctx, "*(name)$:", false, false);
            }
            else if name == "atomic" {
                return parse_atomic_pattern(ctx, "*(name)$:");
            }
            else {
                return ctx..error("Unknown named group pattern: '(name)$'");
            }
        }

        if has_pattern 
        {
            //  Regular group

            r := shared.new<group_token>();
            if has_id {
                r*.number = ctx..next_group();

                if 0 != group_name..size() {
                    ctx..set_named_group(group_name, r*.number);
                }
            }

            old_state := ctx..start_group();
            ctx..set_modifiers(modifiers_change_to);
            if !ctx..parse_until(')') { return nullptr; }
            r*.inner = ctx..end_group(old_state);
            r*..set_string(gen_string(group_name, group_name_brackets, !has_id, modifiers, r*.inner));

            return r;
        }
        else 
        {
            //  Only a modifier
            ctx..set_modifiers(modifiers_change_to);

            return shared.new<regex_token_empty>("(?(modifiers)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<group_token>();
        r*.number = number;
        r*.reverse_eval = !reverse_eval;
        r*.inner = inner*.reverse();
        return r;
    }

    gen_string: (name: std::string, name_brackets: bool, has_modifier: bool, modifiers: std::string, inner_: token_ptr) -> std::string = 
    {
        start : std::string = "(";
        if 0 != name..size() {
            if name_brackets {
                start += "?<(name..data())$>";
            }
            else {
                start += "?'(name..data())$'";
            }
        }
        else if has_modifier {
            start += "?" + modifiers + ":";
        }

        return start + inner_*..to_string() + ")";
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
        }

        inner*..generate_code(ctx);
        if -1 != number {
            if reverse_eval {
                ctx..add("ctx..set_group_start((number)$, r.pos);");
            }
            else {
                ctx..add("ctx..set_group_end((number)$, r.pos);");
            }

            tmp_name := ctx..gen_temp();
            ctx..add("(tmp_name)$_func :=  :() = {");
            ctx..add("  if !r&$*.matched {");
            ctx..add("    ctx&$*..set_group_invalid((number)$);");
            ctx..add("  }");
            ctx..add("};");
            ctx..add("(tmp_name)$ :=  cpp2::regex::make_on_return((tmp_name)$_func);");
            ctx..add("_ = (tmp_name)$;"); // Logic is done in the destructor. Same behavior as for guard objects.
        }
    }

    add_groups: (override this, inout groups: std::set<int>) = 
    {
        inner*..add_groups(groups);
        if -1 != number {
            _ = groups..insert(number);
        }
    }
}


//  Regex syntax: \x<number> or \x{<number>}  Example: \x{62}
//
hexadecimal_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'x') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next() { return ctx..error("x escape without number.");}

    has_brackets := false;
    number_str: std::string = "";
    if '{' == ctx..current() {
        //  Bracketed
        has_brackets = true;
        _  = ctx..next(); // Skip '{'
        if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\x"); }
    }
    else {
        //  Grab two chars
        if !ctx..grab_n(2, out number_str) { return ctx..error("Missing hexadecimal digits after \\x."); }
    }

    number := 0;
    if !string_util::string_to_int(number_str, number, 16) { return ctx..error("Could not convert hexadecimal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = string_util::int_to_string<16>(number_as_char as int);
    if has_brackets {
        syntax = "{(syntax)$}";
    }
    syntax = "\\x(syntax)$";

    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: $  Example: aa$
//
line_end_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() == '$' || (ctx..current() == '\\' && ctx..peek() == '$') {
        if (ctx..current() == '\\') { _ = ctx..next(); } // Skip escape
        return shared.new<regex_token_check>("$", "line_end_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$, true>");
    }
    else if ctx..current() == '\\' && (ctx..peek() == 'z' || ctx..peek() == 'Z') {
        _ = ctx..next(); // Skip escape

        negate := ctx..current() == 'Z';
        return shared.new<regex_token_check>("\\(ctx..current())$", "line_end_token_matcher<char, false, (negate)$>");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: ^  Example: ^aa
//
line_start_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '^' && !(ctx..current() == '\\' && ctx..peek() == 'A') { return nullptr; }

    if ctx..current() == '\\' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\A", "line_start_token_matcher<char, false>");
    }
    else {
        return shared.new<regex_token_check>("^", "line_start_token_matcher<char, (ctx..get_modifiers()..has(expression_flags::multiple_lines))$>");
    }
}


//  Regex syntax: (?=) or (?!) or (*pla), etc.  Example: (?=AA)
//
//  Parsed in group_token.
//
lookahead_lookbehind_token: @polymorphic_base type =
{
    this: regex_token = ("");

    protected lookahead: bool;
    protected positive:  bool;
    public    inner   :  token_ptr = nullptr;

    operator=: (out this, lookahead_: bool, positive_: bool) = {
        lookahead = lookahead_;
        positive  = positive_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx..generate_func(inner);

        if lookahead {
            ctx..add_check("lookahead_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
        else {
            ctx..add_check("lookbehind_token_matcher<char, (positive)$>((ctx..match_parameters())$, (inner_name)$)");
        }
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<lookahead_lookbehind_token>(lookahead, positive);
        r*.inner = inner; // We do not reverse here. Nested lookahead and lookbehind stay as they are.

        return r;
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner*..add_groups(groups);
    }
}


// Named character classes
//
named_class_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }

    name := "";
    c_next := ctx..peek();

    if      'd' == c_next { name = "named_class_digits"; }
    else if 'D' == c_next { name = "named_class_not_digits"; }
    else if 'h' == c_next { name = "named_class_hor_space"; }
    else if 'H' == c_next { name = "named_class_not_hor_space"; }
    else if 'N' == c_next { name = "named_class_no_new_line"; }
    else if 's' == c_next { name = "named_class_space"; }
    else if 'S' == c_next { name = "named_class_not_space"; }
    else if 'v' == c_next { name = "named_class_ver_space"; }
    else if 'V' == c_next { name = "named_class_not_ver_space"; }
    else if 'w' == c_next { name = "named_class_word"; }
    else if 'W' == c_next { name = "named_class_not_word"; }
    else                  { return nullptr; }

    _ = ctx..next(); // Skip escape

    return shared.new<regex_token_check>("\\(ctx..current())$", "(name)$<char, (ctx..get_modifiers()..has(expression_flags::case_insensitive))$>::match");
}


//  Regex syntax: \o{<number>}  Example: \o{142}
//
octal_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if !(ctx..current() == '\\' && ctx..peek() == 'o') { return nullptr; }

    _ = ctx..next(); // Skip escape.

    if !ctx..next()          { return ctx..error("o escape without number.");}
    if ctx..current() != '{' { return ctx..error("Missing opening bracket for \\o."); }

    number_str: std::string = "";
    _  = ctx..next(); // Skip '{'
    if !ctx..grab_until('}', out number_str) { return ctx..error("No ending bracket for \\o"); }

    number := 0;
    if !string_util::string_to_int(number_str, number, 8) { return ctx..error("Could not convert octal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unchecked_narrow<char>(number);

    syntax: std::string = "\\o{(string_util::int_to_string<8>(number_as_char as int))$}";
    r := shared.new<char_token>(number_as_char, ctx..get_modifiers()..has(expression_flags::case_insensitive));
    r*..set_string(syntax);
    return r;
}


//  Regex syntax: <matcher>{min, max}  Example: a{2,4}
//
range_token: @polymorphic_base type = 
{
    this                 : regex_token = ("");

    protected min_count  : int         = -1;
    protected max_count  : int         = -1;
    protected kind       : int         = range_flags::greedy;
    protected inner_token: token_ptr   = nullptr;

    operator=: (out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        r := shared.new<range_token>();
        if ctx..current() == '{' 
        {
            if !ctx..has_token() { return ctx..error("'{' without previous element."); }

            inner: std::string = "";
            if !ctx..grab_until('}', out inner) { return ctx..error("Missing closing bracket '}'."); }

            inner = string_util::trim_copy(inner..substr(1)); // Remove '{' and white spaces.
            if inner..empty() { return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

            // Non-greedy or possessive
            r*..parse_modifier(ctx);

            // Get range arguments
            min_count_str: std::string = "-1";
            max_count_str: std::string = "-1";

            sep: size_t = inner..find(',');
            if sep == std::string::npos 
            {
                min_count_str = inner;
                max_count_str = inner;
                if !string_util::string_to_int(inner, r*.min_count) { return ctx..error("Could not convert range to number."); }
                r*.max_count = r*.min_count;
            }
            else 
            {
                inner_first: std::string = string_util::trim_copy(inner..substr(0, sep));
                inner_last: std::string = string_util::trim_copy(inner..substr(sep + 1));

                if (inner_first..empty() && inner_last..empty()) {
                    return ctx..error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                }

                if !inner_first..empty() {
                    min_count_str = inner_first;
                    if !string_util::string_to_int(inner_first, r*.min_count) { return ctx..error("Could not convert range to number."); }
                }
                if !inner_last..empty() {
                    max_count_str = inner_last;
                    if !string_util::string_to_int(inner_last, r*.max_count) { return ctx..error("Could not convert range to number."); }
                }
            }

            // Check validity of the range.
            if -1 != r*.min_count {
                if !(0 <= r*.min_count) {
                    return ctx..error("Min value in range is negative. Have (r*.min_count)$)");
                }
            }
            if -1 != r*.max_count {
                if !(0 <= r*.max_count) {
                    return ctx..error("Max value in range is negative. Have (r*.max_count)$)");
                }
                if -1 != r*.min_count {
                    if !(r*.min_count <= r*.max_count) {
                        return ctx..error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (r*.min_count)$ <= (r*.max_count)$");
                    }
                }
            }

            r*.inner_token = ctx..pop_token();
            r*.string_rep = r*.inner_token*..to_string() + r*..gen_range_string() + r*..gen_mod_string();

            return r;
        }

        return nullptr;
    }

    parse_modifier: (inout this, inout ctx: parse_context) = 
    {
        if ctx..peek() == '?' {
            kind = range_flags::not_greedy;
            _ = ctx..next();
        }
        else if ctx..peek() == '+' {
            kind = range_flags::possessive;
            _ = ctx..next();
        }
    }

    gen_mod_string: (this) -> std::string = 
    {
        if kind == range_flags::not_greedy {
            return "?";
        }
        else if kind == range_flags::possessive {
            return "+";
        }
        else {
            return "";
        }
    }

    gen_range_string: (this) -> std::string = 
    {
        r : std::string = "";
        if min_count == max_count {
            r += "{(min_count)$}";
        }
        else if min_count == -1 {
            r += "{,(max_count)$}";
        }
        else if max_count == -1 {
            r += "{(min_count)$,}";
        }
        else {
            r += "{(min_count)$,(max_count)$}";
        }

        return r;
    }

    reverse: (override this) -> token_ptr = {
        r := shared.new<range_token>();
        r*.min_count   = min_count;
        r*.max_count   = max_count;
        r*.kind        = kind;
        r*.inner_token = inner_token*.reverse();

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) = 
    {
        inner_name := ctx..generate_func(inner_token);
        groups: std::set<int> = ();
        inner_token*..add_groups(groups);
        reset_name := ctx..generate_reset(groups);

        next_name := ctx..next_func_name();
        ctx..add_statefull(next_name, "cpp2::regex::range_token_matcher<char, (min_count)$, (max_count)$, (kind)$>::match((ctx..match_parameters())$, (inner_name)$, (reset_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*..add_groups(groups);
    }
}


//  Regex syntax: *, +, or ?  Example: aa*
//
special_range_token: @polymorphic_base type = 
{
    this : range_token = ();

    parse: (inout ctx: parse_context) -> token_ptr = 
    {
        r := shared.new<special_range_token>();
        symbol: char = '\0';
        if ctx..current() == '*' {
            r*.min_count = 0;
            r*.max_count = -1;
            symbol = '*';
        }
        else if ctx..current() == '+' {
            r*.min_count = 1;
            r*.max_count = -1;
            symbol = '+';
        } else if ctx..current() == '?' {
            r*.min_count = 0;
            r*.max_count = 1;
            symbol = '?';
        } else {
            return nullptr;
        }

        if !ctx..has_token() { return ctx..error("'(ctx..current())$' without previous element."); }


        r*..parse_modifier(ctx);

        r*.inner_token = ctx..pop_token();
        r*.string_rep = r*.inner_token*..to_string() + symbol + r*..gen_mod_string();
        return r;
    }
}

//  Regex syntax: \G  Example: \Gaa
//
//  Forces the match and/or consecutive matches to start at the position of the last match.
//
start_match_parse: (inout ctx: parse_context) -> token_ptr =
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'G' {
        if 0 != ctx..get_pos() { return ctx..error("\\G is only supported at the first position in the regex."); }
        _ = ctx..next();
        ctx.is_start_match = true;
        return shared.new<regex_token_empty>("\\G");
    }
    else {
        return nullptr;
    }
}


//  Regex syntax: \b or \B  Example: \bword\b
//
//  Matches the start end end of word boundaries.
//
word_boundary_token_parse: (inout ctx: parse_context) -> token_ptr = 
{
    if ctx..current() != '\\' { return nullptr; }

    if ctx..peek() == 'b' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\b", "word_boundary_token_matcher<char, false>");
    }
    else if ctx..peek() == 'B' {
        _ = ctx..next();
        return shared.new<regex_token_check>("\\B", "word_boundary_token_matcher<char, true>");
    }
    else {
        return nullptr;
    }
}


//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

//  Parser and generator for regular expressions.
regex_generator: <Error_out> type = 
{
    regex:           std::string_view;
    modifier:        std::string = "";
    modifier_escape: std::string = "";

    error_out:       Error_out;

    source:          std::string = "";

    operator=: (out this, r: std::string_view, e: Error_out) = {
        regex = r;
        error_out = e;
    }

    parse:(inout this) -> std::string = 
    {
        // Extract modifiers and adapt regex.
        extract_modifiers();

        parse_ctx: parse_context = (regex, error_out);
        if !parse_ctx..parse(modifier) {
            return "";
        }

        source += "{\n";
        source += "  context: <Iter> type == cpp2::regex::match_context<CharT, Iter, (parse_ctx..get_cur_group())$>;";

        gen_ctx: generation_context = ();
        source += gen_ctx..run(parse_ctx..get_as_token());
        source += "  entry: <Iter> (cur: Iter, inout ctx: context<Iter>) -> cpp2::regex::match_return<Iter> = {\n";
        source += "    ctx..set_group_start(0, cur);\n";
        source += "    r := (gen_ctx..get_entry_func())$(cur, ctx, cpp2::regex::true_end_func());\n";
        source += "    if r.matched { ctx..set_group_end(0, r.pos); }\n";
        source += "    return r;\n";
        source += "  }\n";

        source += gen_ctx..create_named_group_lookup(parse_ctx.named_groups);
        source += "  is_start_match: () -> bool == (parse_ctx.is_start_match)$;";

        string := parse_ctx..get_as_token()*..to_string();
        source += "  to_string: () -> std::string = { return R\"((modifier_escape)$(string)$(modifier_escape)$(modifier)$)\"; }\n";

        source += "}\n";

        _ = parse_ctx;

        return source;
    }

    private extract_modifiers: (inout this) = 
    {
        if regex..find_first_of("'/") == 0 {
            mod_token: char = regex[0];

            end_pos := regex..rfind(mod_token);
            if end_pos != 0 {
                // Found valid start end escape
                modifier = regex..substr(end_pos + 1);
                modifier_escape = mod_token;
                regex = regex..substr(1, end_pos - 1);
            }
        }
    }
}

generate_regex: <Err> (regex: std::string_view, err: Err) -> std::string = 
{
    parser: regex_generator<Err> = (regex, err);
    r := parser..parse();
    _ = parser;
    return r;
}



regex_gen: (inout t: meta::type_declaration) =
{
    has_default := false;
    exact_name  := "regex";
    prefix      := "regex_";
    expressions : std::map<std::string, std::string> = ();

    for t.get_member_objects() do (inout m)
    {
        name: std::string = m.name();

        if name.starts_with(prefix) || name == exact_name
        {
            if !m.has_initializer() {
                t.error("Regular expression must have an initializer.");
            }
            m.mark_for_removal_from_enclosing_type();

            if name == exact_name {
                if has_default {
                    t.error("Type can only contain one default named regular expression.");
                }
                has_default = true;
            }

            expr: std::string = m.initializer();
            if expr.starts_with("R\"(") && expr.ends_with(")\"") {
                expr = expr.substr(3, expr.size() - 5);
            }
            else if string_util::is_escaped(expr) {
                expr = expr.substr(1, expr.size() - 2);
            }
            else {
                t.error("Unknown string format '(expr)$'");
            }

            expressions[name] = expr;
        }
    }

    t.remove_marked_members();

    for expressions do (expr) {
        regular_expression := generate_regex(expr.second, :(message) = t$.error(message););

        if !regular_expression..empty() {
            t.add_member("public (expr.first)$_matcher: <CharT> type = (regular_expression)$");
            t.add_member("public (expr.first)$: cpp2::regex::regular_expression<char, (expr.first)$_matcher<char>> = ();\n");
        }
    }

    t.add_runtime_support_include( "cpp2regex.h" );
}


//-----------------------------------------------------------------------
//
//  apply_metafunctions
//
apply_metafunctions: (
    inout n     : declaration_node,
    inout rtype : type_declaration,
    error
    )
    -> bool
= {
    assert( n.is_type() );

    //  Check for _names reserved for the metafunction implementation
    if !n.metafunctions.empty()
    {
        for  rtype.get_members()
        do   (m)
        {
            m.require( 
                !m.name().starts_with("_") || m.name().ssize() == 1,
                "a type that applies a metafunction cannot have a body that declares "
                "a name that starts with '_' - those names are reserved for the "
                "metafunction implementation"
            );
        }
    }

    //  For each metafunction, apply it
    for n.metafunctions
    do  (meta)
    {
        //  Convert the name and any template arguments to strings
        //  and record that in rtype
        name := meta*.to_string();
        name = name.substr(0, name.find('<'));

        args: std::vector<std::string> = ();
        for meta*.template_arguments()
        do  (arg)
            args.push_back( arg.to_string() );

        rtype.set_metafunction_name( name, args );

        //  Dispatch
        //
        if name == "interface" {
            interface( rtype );
        }
        else if name == "polymorphic_base" {
            polymorphic_base( rtype );
        }
        else if name == "ordered" {
            ordered( rtype );
        }
        else if name == "weakly_ordered" {
            weakly_ordered( rtype );
        }
        else if name == "partially_ordered" {
            partially_ordered( rtype );
        }
        else if name == "copyable" {
            copyable( rtype );
        }
        else if name == "copy_constructible" {
            copy_constructible( rtype );
        }
        else if name == "hashable" {
            hashable( rtype );
        }
        else if name == "basic_value" {
            basic_value( rtype );
        }
        else if name == "value" {
            value( rtype );
        }
        else if name == "weakly_ordered_value" {
            weakly_ordered_value( rtype );
        }
        else if name == "partially_ordered_value" {
            partially_ordered_value( rtype );
        }
        else if name == "cpp1_rule_of_zero" {
            cpp1_rule_of_zero( rtype );
        }
        else if name == "struct" {
            cpp2_struct( rtype );
        }
        else if name == "enum" {
            cpp2_enum( rtype );
        }
        else if name == "flag_enum" {
            flag_enum( rtype );
        }
        else if name == "union" {
            cpp2_union( rtype );
        }
        else if name == "print" {
            print( rtype );
        }
        else if name == "noisy" {
            noisy( rtype );
        }
        else if name == "python" {
            python( rtype );
        }
        else if name == "javascript" {
            javascript( rtype );
        }
        else if name == "autodiff" {
            autodiff( rtype );
        }
        else if name == "regex" {
            regex_gen( rtype );
        }
        else if name == "sample_traverser" {
            sample_traverser( rtype );
        }
        else {
            error( "unrecognized metafunction name: " + name );
            error( 
                "the current supported names are listed at "
                "https://hsutter.github.io/cppfront/cpp2/metafunctions/#built-in-metafunctions"
            );
            return false;
        }
    }

    return true;
}


}

}
