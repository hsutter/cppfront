//  Copyright 2022-2025 Herb Sutter
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//  
//  Part of the Cppfront Project, under the Apache License v2.0 with LLVM Exceptions.
//  See https://github.com/hsutter/cppfront/blob/main/LICENSE for license information.


//===========================================================================
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression list
//
expression_list: @copy_constructible type =
{
    this: reflection_base<expression_list_node> = ();

    operator=: (
        out this,
        n_: *expression_list_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_list_node> = (n_, s);
    }

    is_empty          : (this) -> bool = n*.is_empty          ();
    is_fold_expression: (this) -> bool = n*.is_fold_expression();

    get_expressions: (this)
        -> std::vector<expression>
    = {
        ret: std::vector<expression> = ();
        for n*.get_expressions() do (expr) {
            _ = ret.emplace_back(expression(expr.expr.get(), this));
        }
        return ret;
    }

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Prefix expressions
//
prefix_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<prefix_expression_node> = ();

    operator=: (
        out this,
        n_: *prefix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<prefix_expression_node> = (n_, s);
    }

    get_ops: (this) -> std::vector<std::string> = {
        ret: std::vector<std::string> = ();
        for n*.ops do (op) {
            _ = ret.emplace_back(op*.to_string());
        }
        return ret;
    }

    get_postfix_expression: (this) -> postfix_expression = (this.n*.expr.get(), this);

    is_fold_expression            : (this) -> bool = n*.is_fold_expression            ();
    is_identifier                 : (this) -> bool = n*.is_identifier                 ();
    is_id_expression              : (this) -> bool = n*.is_id_expression              ();
    is_unqualified_id             : (this) -> bool = n*.is_unqualified_id             ();
    is_expression_list            : (this) -> bool = n*.is_expression_list            ();
    is_literal                    : (this) -> bool = n*.is_literal                    ();
    is_result_a_temporary_variable: (this) -> bool = n*.is_result_a_temporary_variable();

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Postfix expressions
//
postfix_expression: @copy_constructible type =
{
    this: reflection_base<postfix_expression_node> = ();

    operator=: (
        out this,
        n_: *postfix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<postfix_expression_node> = (n_, s);
    }

    get_primary_expression: (this) -> primary_expression = (this.n*.expr.get(), this);

    term_t: @copy_constructible type = {
        private term_: * const postfix_expression_node::term;
        private cs_  : * const compiler_services;

        operator=: (out this, forward term, forward cs) = { term_ = term; cs_ = cs; }

        get_op            : (this) -> std::string_view  = term_*.op*.as_string_view();

        //  If op is        More is contained in the        Notes
        //
        //  .               id_expression                   member selection
        //  [ (             expression_list                 subscript or function call
        //  ...             expression                      fold expression

        is_id_expression   : (this) -> bool            = term_*.id_expr  .get() != nullptr;
        is_expression_list : (this) -> bool            = term_*.expr_list.get() != nullptr;
        is_expression      : (this) -> bool            = term_*.last_expr.get() != nullptr;

        get_id_expression  : (this) -> id_expression   = (term_*.id_expr  .get(), cs_*);
        get_expression_list: (this) -> expression_list = (term_*.expr_list.get(), cs_*);
        get_expression     : (this) -> expression      = (term_*.last_expr.get(), cs_*);
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t&, this& ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();

    get_first_token_ignoring_this: (this) -> std::string_view = {
        ptok := n*.get_first_token_ignoring_this();
        if ptok { return ptok*; }
        return "";
    }

    starts_with_function_call_with_num_parameters: (this, num: int) -> bool = n*.starts_with_function_call_with_n_parameters(num);
    is_result_a_temporary_variable               : (this) -> bool           = n*.is_result_a_temporary_variable             ();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
               }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Expression list
//
expression_list: @copy_constructible type =
{
    this: reflection_base<expression_list_node> = ();

    operator=: (
        out this,
        n_: *expression_list_node,
        s : compiler_services
    )
    = {
        reflection_base<expression_list_node> = (n_, s);
    }

    is_empty          : (this) -> bool = n*.is_empty          ();
    is_fold_expression: (this) -> bool = n*.is_fold_expression();

    get_expressions: (this)
        -> std::vector<expression>
    = {
        ret: std::vector<expression> = ();
        for n*.get_expressions() do (expr) {
            _ = ret.emplace_back(expression(expr.expr.get(), this));
        }
        return ret;
    }

    to_string: (this) -> std::string = n*.to_string();
}


//-----------------------------------------------------------------------
//  Prefix expressions
//
prefix_expression: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<prefix_expression_node> = ();

    operator=: (
        out this,
        n_: *prefix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<prefix_expression_node> = (n_, s);
    }

    get_ops: (this) -> std::vector<std::string> = {
        ret: std::vector<std::string> = ();
        for n*.ops do (op) {
            _ = ret.emplace_back(op*.to_string());
        }
        return ret;
    }

    get_postfix_expression: (this) -> postfix_expression = (this.n*.expr.get(), this);

    is_fold_expression            : (this) -> bool = n*.is_fold_expression            ();
    is_identifier                 : (this) -> bool = n*.is_identifier                 ();
    is_id_expression              : (this) -> bool = n*.is_id_expression              ();
    is_unqualified_id             : (this) -> bool = n*.is_unqualified_id             ();
    is_expression_list            : (this) -> bool = n*.is_expression_list            ();
    is_literal                    : (this) -> bool = n*.is_literal                    ();
    is_result_a_temporary_variable: (this) -> bool = n*.is_result_a_temporary_variable();

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();
    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Postfix expressions
//
postfix_expression: @copy_constructible type =
{
    this: reflection_base<postfix_expression_node> = ();

    operator=: (
        out this,
        n_: *postfix_expression_node,
        s : compiler_services
    )
    = {
        reflection_base<postfix_expression_node> = (n_, s);
    }

    get_primary_expression: (this) -> primary_expression = (this.n*.expr.get(), this);

    term_t: @copy_constructible type = {
        private term_: * const postfix_expression_node::term;
        private cs_  : * const compiler_services;

        operator=: (out this, forward term, forward cs) = { term_ = term; cs_ = cs; }

        get_op            : (this) -> std::string_view  = term_*.op*.as_string_view();

        //  If op is        More is contained in the        Notes
        //
        //  .               id_expression                   member selection
        //  [ (             expression_list                 subscript or function call
        //  ...             expression                      fold expression

        is_id_expression   : (this) -> bool            = term_*.id_expr  .get() != nullptr;
        is_expression_list : (this) -> bool            = term_*.expr_list.get() != nullptr;
        is_expression      : (this) -> bool            = term_*.last_expr.get() != nullptr;

        get_id_expression  : (this) -> id_expression   = (term_*.id_expr  .get(), cs_*);
        get_expression_list: (this) -> expression_list = (term_*.expr_list.get(), cs_*);
        get_expression     : (this) -> expression      = (term_*.last_expr.get(), cs_*);
    }

    get_terms: (this) -> _ = {
        ret: std::vector<term_t> = ();
        for this.n*.ops do (t) { _ = ret.emplace_back( t&, this& ); }
        return ret;
    }

    is_fold_expression: (this) -> bool = n*.is_fold_expression();
    is_identifier     : (this) -> bool = n*.is_identifier     ();
    is_id_expression  : (this) -> bool = n*.is_id_expression  ();
    is_unqualified_id : (this) -> bool = n*.is_unqualified_id ();
    is_expression_list: (this) -> bool = n*.is_expression_list();
    is_literal        : (this) -> bool = n*.is_literal        ();

    as_identifier     : (this) -> std::string     = n*.get_identifier()*.to_string();
    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = n*.get_literal()*.to_string();

    get_first_token_ignoring_this: (this) -> std::string_view = {
        ptok := n*.get_first_token_ignoring_this();
        if ptok { return ptok*; }
        return "";
    }

    starts_with_function_call_with_num_parameters: (this, num: int) -> bool = n*.starts_with_function_call_with_n_parameters(num);
    is_result_a_temporary_variable               : (this) -> bool           = n*.is_result_a_temporary_variable             ();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression< "bit-or"         , bit_xor_expression_node        >;
logical_and_expression    : type == binary_expression< "logical-and"    , bit_or_expression_node         >;
logical_or_expression     : type == binary_expression< "logical-or"     , logical_and_expression_node    >;
assignment_expression     : type == binary_expression< "assignment"     , logical_or_expression_node     >;

binary_expression: @copy_constructible <Name: String, Term> type =
{
    this: reflection_base<binary_expression_node<Name, Term>> = ();

    operator=: (
        out this,
        n_: *binary_expression_node<Name, Term>,
        s : compiler_services
    )
    = {
        reflection_base<binary_expression_node<Name, Term>> = (n_, s);
    }

    is_fold_expression      : (this) -> bool = this.n*.is_fold_expression      ();
    lhs_is_id_expression    : (this) -> bool = this.n*.lhs_is_id_expression    ();
    is_standalone_expression: (this) -> bool = this.n*.is_standalone_expression();
    terms_size              : (this) -> int  = this.n*.terms_size              ();
    is_identifier           : (this) -> bool = this.n*.is_identifier           ();
    is_id_expression        : (this) -> bool = this.n*.is_id_expression        ();
    is_unqualified_id       : (this) -> bool = this.n*.is_unqualified_id       ();
    is_expression_list      : (this) -> bool = this.n*.is_expression_list      ();
    is_literal              : (this) -> bool = this.n*.is_literal              ();

    term_t: @copyable <T> type = {
        op:   std::string;
        term: T;

        operator=: (out this, forward o, forward ptr, forward cs) = { op = o; term = (ptr, cs); }

        get_op:   (this) -> std::string = op;
        get_term: (this) -> T           = term;
    }

    get_terms: (this) -> _ = {
        if constexpr std::is_same_v<Term, is_as_expression_node> {
            ret: std::vector<term_t<is_as_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, multiplicative_expression_node> {
            ret: std::vector<term_t<multiplicative_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, additive_expression_node      > {
            ret: std::vector<term_t<additive_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, shift_expression_node         > {
            ret: std::vector<term_t<shift_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, compare_expression_node       > {
            ret: std::vector<term_t<compare_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, relational_expression_node    > {
            ret: std::vector<term_t<relational_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, equality_expression_node      > {
            ret: std::vector<term_t<equality_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_and_expression_node       > {
            ret: std::vector<term_t<bit_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_xor_expression_node       > {
            ret: std::vector<term_t<bit_xor_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, bit_or_expression_node        > {
            ret: std::vector<term_t<bit_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_and_expression_node   > {
            ret: std::vector<term_t<logical_and_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
        if constexpr std::is_same_v<Term, logical_or_expression_node    > {
            ret: std::vector<term_t<logical_or_expression>> = ();
            _ = ret.emplace_back( "", this.n*.expr.get(), this );
            for this.n*.terms do (t) { _ = ret.emplace_back( t.op*, t.expr.get(), this ); }
            return ret;
        }
    }

    as_expression_list: (this) -> expression_list = (this.n*.get_expression_list(), this);
    as_literal        : (this) -> std::string     = this.n*.get_literal()*.to_string();

    //  Get the postfix-expression, if that's the entire expression (not actually binary)
    get_if_only_a_postfix_expression: (this) -> postfix_expression = (this.n*.get_if_only_a_postfix_expression_node(), this);
    //  Get left-hand postfix-expression
    get_lhs_postfix_expression      : (this) -> postfix_expression = (this.n*.get_postfix_expression_node()          , this);
    //  Get first right-hand postfix-expression, if there is one
    get_second_postfix_expression   : (this) -> postfix_expression = (this.n*.get_second_postfix_expression_node()   , this);

    is_result_a_temporary_variable  : (this) -> bool               = this.n*.is_result_a_temporary_variable();

    to_string: (this) -> std::string = this.n*.to_string();
}


//-----------------------------------------------------------------------
//  Coroutine metaclasses for advanced async programming
//  Inspired by C++20 coroutines and Kotlin's suspend functions
//  Supports MLIR-based optimizations for locality and JIT compilation
//
//-----------------------------------------------------------------------

// Base metaclass for async operations
async_base: (inout t: meta::type_declaration) =
{
    // Enforce no copy/move for async types
    t.add_member( "operator=: (out this, that) = delete;" );
    t.add_member( "operator=: (move this, that) = delete;" );
    
    // Require a resume() function
    t.add_member( "resume: (inout this) -> void;" );
    
    // Add coroutine traits
    t.add_member( "operator co_await: (this) -> awaiter = { return awaiter{this}; }" );
    
    // Add MLIR optimization hints for locality recalibration on resume
    t.add_extra_cpp1_code( "// MLIR pass: optimize locality on resume\n" );
    t.add_extra_build_step( "mlir-opt --optimize-locality input.mlir -o optimized.mlir\n" );
}

// Specific metaclass for coroutines
coroutine: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Enforce coroutine_handle-like interface
    t.add_member( "handle: std::coroutine_handle<> = nullptr;" );
    
    // Generate state machine boilerplate
    t.add_member( "operator=: (out this) = { /* Initialize coroutine state */ }" );
    
    t.add_member( "destroy: (inout this) = { if handle { handle.destroy(); } }" );
    
    // MLIR: Generate coroutine state machine with optimized suspension points
    t.add_extra_cpp1_code( "// MLIR: coroutine state machine generation\n" );
}

// Metaclass for suspendable functions
suspendable: (inout t: meta::type_declaration) =
{
    t.polymorphic_base();
    
    // Mark as suspendable
    t.add_member( "is_suspendable: bool = true;" );
    
    // Generate suspension points
    t.add_member( "suspend: (inout this) -> void = { /* Implementation would generate co_await */ }" );
    
    // MLIR: Optimize suspension points for locality
    t.add_extra_cpp1_code( "// MLIR: suspend point optimization\n" );
}

// Metaclass for continuations
continuation: (inout t: meta::type_declaration) =
{
    t.async_base();
    
    // Continuation state
    t.add_member( "state: int = 0;" );
    
    // Resume from continuation
    t.add_member( "resume: (inout this) -> void = { state += 1; }" );
    
    // MLIR: Continuation optimization
    t.add_extra_cpp1_code( "// MLIR: continuation flow optimization\n" );
}

// Metaclass for generators (yield-based)
generator: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Yield support
    t.add_member( "yield: (inout this, value: auto) -> void = { /* Generate co_yield */ }" );
    
    // Iterator interface
    t.add_member( "begin: (this) -> iterator;" );
    t.add_member( "end: (this) -> iterator;" );
    
    // MLIR: Generator optimization
    t.add_extra_cpp1_code( "// MLIR: generator yield optimization\n" );
}

// Metaclass for async tasks
task: (inout t: meta::type_declaration) =
{
    t.coroutine();
    
    // Result type
    t.add_member( "result: auto;" );
    
    // Get result (blocking)
    t.add_member( "get: (inout this) -> auto = { /* Wait for completion */ return result; }" );
    
    // MLIR: Task completion optimization
    t.add_extra_cpp1_code( "// MLIR: task scheduling optimization\n" );
}

//-----------------------------------------------------------------------
//  Reflection and meta
//===========================================================================

#include "parse.h"
#include "cpp2regex.h"
using namespace cpp2::regex;

cpp2: namespace = {

meta: namespace = {


//-----------------------------------------------------------------------
//
//  Compiler services
//
//-----------------------------------------------------------------------
//

compiler_services: @polymorphic_base @copy_constructible type =
{
    //  Common data members
    //
    errors               : *std::vector<error_entry>;
    includes             : *std::set<std::string>;
    extra_cpp1           : *std::vector<std::string>;
    extra_build          : *std::vector<std::string>;
    file_name            : std::string;
    errors_original_size : int;
    generated_tokens     : *stable_vector<token>;
    parser               : cpp2::parser;
    metafunction_name    : std::string = ();
    metafunction_args    : std::vector<std::string> = ();
    metafunctions_used   : bool = false;

    //  Constructor
    //
    operator=: (
        out this,
        errors_          : *std::vector<error_entry>,
        includes_        : *std::set<std::string>,
        extra_cpp1_      : *std::vector<std::string>,
        extra_build_     : *std::vector<std::string>,
        filename         : std::string,
        generated_tokens_: *stable_vector<token>
    )
    = {
        errors               = errors_;
        includes             = includes_;
        extra_cpp1           = extra_cpp1_;
        extra_build          = extra_build_;
        file_name            = filename;
        errors_original_size = cpp2::unchecked_narrow<int>(std::ssize(errors*));
        generated_tokens     = generated_tokens_;
        parser               = (errors*, includes*, extra_cpp1*, extra_build*, file_name);
    }

    //  Common API
    //
    filename: (this) -> std::string_view = file_name;

    set_metafunction_name: (inout this, name: std::string_view, args: std::vector<std::string>) = {
        metafunction_name  = name;
        metafunction_args  = args;
        metafunctions_used = args.empty();
    }

    get_metafunction_name: (this) -> std::string_view = metafunction_name;

    get_argument: (inout this, index: int) -> std::string = {
        metafunctions_used = true;
        if (0 <= index < metafunction_args.ssize()) {
            return metafunction_args[index];
        }
        return "";
    }

    get_arguments: (inout this) -> std::vector<std::string> = {
        metafunctions_used = true;
        return metafunction_args;
    }

    arguments_were_used: (this) -> bool = metafunctions_used;

    protected parse_statement: (
        inout this,
        copy source: std::string_view
    )
        -> (ret: std::unique_ptr<statement_node>)
    = {
        original_source := source;

        generated_lines.push_back( std::vector<source_line>() );
        lines := generated_lines.back()&;

        add_line := :(s: std::string_view) = {
            _ = lines$*.emplace_back( s, source_line::category::cpp2 );
        };

        //  First split this string into source_lines
        //
        (copy newline_pos := source.find('\n'))
        if  source.ssize() > 1
            && newline_pos != source.npos
        {
            while newline_pos != source.npos
            {
                add_line( source.substr(0, newline_pos) );
                source.remove_prefix( newline_pos+1 );
                newline_pos = source.find('\n');
            }
        }

        if !source.empty() {
            add_line( source );
        }

        //  Now lex this source fragment to generate
        //  a single grammar_map entry, whose .second
        //  is the vector of tokens
        _ = generated_lexers.emplace_back( errors* );
        tokens := generated_lexers.back()&;
        tokens*.lex( lines*, true );

        assert( std::ssize(tokens* .get_map()) == 1 );

        //  Now parse this single declaration from
        //  the lexed tokens
        ret = parser.parse_one_declaration(
                tokens*.get_map().begin()*.second,
                generated_tokens*
              );
        if !ret {
            error( "parse failed - the source string is not a valid statement:\n(original_source)$");
        }
    }

    add_runtime_support_include: (inout this, s: std::string_view, angles: bool = false) = {
        inc: std::string = s;
        if angles {
            inc = "<" + inc + ">";
        }
        else {
            inc = "\"" + inc + "\"";
        }
        _=includes*.emplace( inc );
    }

    add_extra_cpp1_code : (inout this, s: std::string) = extra_cpp1 *.push_back( s );
    add_extra_build_step: (inout this, s: std::string) = extra_build*.push_back( s+"\n" );

    position: (virtual this)
        -> source_position
    = {
        return ();
    }

    //  Error diagnosis and handling, integrated with compiler output
    //  Unlike a contract violation, .requires continues further processing
    //
    require:(
        this,
        b   : bool,
        msg : std::string_view
    )
    = {
        if !b {
            error( msg );
        }
    }

    error: (this, msg: std::string_view)
    = {
        message := msg as std::string;
        if !metafunction_name.empty() {
            message = "while applying @(metafunction_name)$ - (message)$";
        }
        _ = errors*.emplace_back( position(), message);
    }

    //  Enable custom contracts on this object, integrated with compiler output
    //  Unlike .requires, a contract violation stops further processing
    //
    report_violation: (this, msg) = {
        error(msg);
        throw( std::runtime_error(
            "  ==> programming bug found in metafunction @(metafunction_name)$ "
            "- contract violation - see previous errors"
        ) );
    }

    is_active:(this) = true;
}


//-----------------------------------------------------------------------
//
//  All reflection types are wrappers around a pointer to node
//
//-----------------------------------------------------------------------
//

reflection_base: @polymorphic_base @copy_constructible <T> type =
{
    this: compiler_services = ();

    protected n: *T;

    protected operator=: (
        out this,
        n_: *T,
        s : compiler_services
    )
    = {
        compiler_services = s;
        n = n_;
        assert( n, "a meta:: reflection must point to a valid node, not null" );
    }

    position: (override this) -> source_position = n*.position();

    print: (this) -> std::string = n*.pretty_print_visualize(0);
}


//-----------------------------------------------------------------------
//
//  Declarations
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  All declarations
//
declaration: @polymorphic_base @copy_constructible type =
{
    this: reflection_base<declaration_node> = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<declaration_node> = (n_, s);
    }

    is_public        : (this) -> bool = n*.is_public();
    is_protected     : (this) -> bool = n*.is_protected();
    is_private       : (this) -> bool = n*.is_private();
    is_default_access: (this) -> bool = n*.is_default_access();

    default_to_public   : (inout this) = _ = n*.make_public();
    default_to_protected: (inout this) = _ = n*.make_protected();
    default_to_private  : (inout this) = _ = n*.make_private();

    make_public      : (inout this) -> bool = n*.make_public();
    make_protected   : (inout this) -> bool = n*.make_protected();
    make_private     : (inout this) -> bool = n*.make_private();

    has_name         : (this)                      -> bool = n*.has_name();
    has_name         : (this, s: std::string_view) -> bool = n*.has_name(s);

    name: (this) -> std::string_view = {
        if has_name() { return n*.name()*.as_string_view(); }
        else          { return ""; }
    }

    has_initializer: (this) -> bool = n*.has_initializer();

    get_initializer: (this) -> statement = (n*.initializer.get(), this);

    is_global        : (this) -> bool = n*.is_global();
    is_function      : (this) -> bool = n*.is_function();
    is_object        : (this) -> bool = n*.is_object();
    is_base_object   : (this) -> bool = n*.is_base_object();
    is_member_object : (this) -> bool = n*.is_member_object();
    is_type          : (this) -> bool = n*.is_type();
    is_namespace     : (this) -> bool = n*.is_namespace();
    is_alias         : (this) -> bool = n*.is_alias();

    is_type_alias      : (this) -> bool = n*.is_type_alias();
    is_namespace_alias : (this) -> bool = n*.is_namespace_alias();
    is_object_alias    : (this) -> bool = n*.is_object_alias();

    is_function_expression : (this) -> bool = n*.is_function_expression();

    as_function           : (this) -> function_declaration  = (n, this);
    as_object             : (this) -> object_declaration    = (n, this);
    as_type               : (this) -> type_declaration      = (n, this);
    as_nonglobal_namespace: (this) -> namespace_declaration = (n, this);
    as_alias              : (this) -> alias_declaration     = (n, this);

    get_parent  : (this) -> declaration           = declaration(n*.parent_declaration, this);

    parent_is_function           : (this) -> bool = n*.parent_is_function();
    parent_is_object             : (this) -> bool = n*.parent_is_object();
    parent_is_type               : (this) -> bool = n*.parent_is_type();
    parent_is_nonglobal_namespace: (this) -> bool = n*.parent_is_nonglobal_namespace();
    parent_is_alias              : (this) -> bool = n*.parent_is_alias();

    parent_is_type_alias      : (this) -> bool = n*.parent_is_type_alias();
    parent_is_namespace_alias : (this) -> bool = n*.parent_is_namespace_alias();
    parent_is_object_alias    : (this) -> bool = n*.parent_is_object_alias();

    parent_is_polymorphic: (this) -> bool = n*.parent_is_polymorphic();

    mark_for_removal_from_enclosing_type: (inout this)
        pre<type_safety>( parent_is_type() )        // this precondition should be sufficient ...
    = {
        test := n*.type_member_mark_for_removal();
        assert( test );                             // ... to ensure this assert is true
    }
}


//-----------------------------------------------------------------------
//  Function declarations
//
function_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_function() );
    }

    index_of_parameter_named     : (this, s: std::string_view) -> int  = n*.index_of_parameter_named(s);
    has_parameter_named          : (this, s: std::string_view) -> bool = n*.has_parameter_named(s);
    has_return_named             : (this, s: std::string_view) -> bool = n*.has_return_named(s);
    has_parameter_or_return_named: (this, s: std::string_view) -> bool = n*.has_parameter_or_return_named(s);
    has_in_parameter_named       : (this, s: std::string_view) -> bool = n*.has_in_parameter_named(s);
    has_in_ref_parameter_named   : (this, s: std::string_view) -> bool = n*.has_in_ref_parameter_named(s);
    has_copy_parameter_named     : (this, s: std::string_view) -> bool = n*.has_copy_parameter_named(s);
    has_inout_parameter_named    : (this, s: std::string_view) -> bool = n*.has_inout_parameter_named(s);
    has_out_parameter_named      : (this, s: std::string_view) -> bool = n*.has_out_parameter_named(s);
    has_move_parameter_named     : (this, s: std::string_view) -> bool = n*.has_move_parameter_named(s);
    has_forward_parameter_named  : (this, s: std::string_view) -> bool = n*.has_forward_parameter_named(s);
    first_parameter_name         : (this) -> std::string               = n*.first_parameter_name();

    has_parameter_with_name_and_pass: (this, s: std::string_view, pass: passing_style) -> bool
                                                  = n*.has_parameter_with_name_and_pass(s, pass);
    is_function_with_this        : (this) -> bool = n*.is_function_with_this();
    is_virtual                   : (this) -> bool = n*.is_virtual_function();
    is_defaultable               : (this) -> bool = n*.is_defaultable_function();
    is_constructor               : (this) -> bool = n*.is_constructor();
    is_default_constructor       : (this) -> bool = n*.is_default_constructor();
    is_move                      : (this) -> bool = n*.is_move();
    is_swap                      : (this) -> bool = n*.is_swap();
    is_constructor_with_that     : (this) -> bool = n*.is_constructor_with_that();
    is_constructor_with_in_that  : (this) -> bool = n*.is_constructor_with_in_that();
    is_constructor_with_move_that: (this) -> bool = n*.is_constructor_with_move_that();
    is_assignment                : (this) -> bool = n*.is_assignment();
    is_assignment_with_that      : (this) -> bool = n*.is_assignment_with_that();
    is_assignment_with_in_that   : (this) -> bool = n*.is_assignment_with_in_that();
    is_assignment_with_move_that : (this) -> bool = n*.is_assignment_with_move_that();
    is_destructor                : (this) -> bool = n*.is_destructor();

    is_copy_or_move              : (this) -> bool = is_constructor_with_that() || is_assignment_with_that();

    has_declared_return_type     : (this) -> bool = n*.has_declared_return_type();
    has_deduced_return_type      : (this) -> bool = n*.has_deduced_return_type();
    has_bool_return_type         : (this) -> bool = n*.has_bool_return_type();
    has_non_void_return_type     : (this) -> bool = n*.has_non_void_return_type();

    has_compound_body            : (this) -> bool = n*.is_function_with_compound_body();

    get_body                     : (this) -> statement          = (n*.get_function_body(), this);
    get_compound_body            : (this) -> compound_statement = (n*.get_function_compound_body(), this);
    get_unnamed_return_type      : (this) -> std::string        = n*.unnamed_return_type_to_string();
    get_signature                : (this) -> std::string        = n*.signature_to_string();

    is_binary_comparison_function: (this) -> bool = n*.is_binary_comparison_function();

    get_parameters: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_parameters() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    get_returns: (this)
        -> std::vector<parameter_declaration>
    = {
        ret: std::vector<parameter_declaration> = ();
        for n*.get_function_returns() do (param) {
            _ = ret.emplace_back( param, this );
        }
        return ret;
    }

    //  Modifying operations
    //
    default_to_virtual           : (inout this) = _ = n*.make_function_virtual();

    make_virtual                 : (inout this) -> bool = n*.make_function_virtual();

    add_initializer: (inout this, source: std::string_view)
        pre<this> (!has_initializer(), "cannot add an initializer to a function that already has one")
        pre<this> (parent_is_type(),   "cannot add an initializer to a function that isn't in a type scope")
    = {
        stmt := parse_statement(source);
        if !(stmt as bool) {
            error( "cannot add an initializer that is not a valid statement");
            return;
        }
        require (n*.add_function_initializer(move stmt),
                 std::string("unexpected error while attempting to add initializer"));
    }
}


//-----------------------------------------------------------------------
//  Object declarations
//
object_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_object() );
    }

    is_const         : (this) -> bool = n*.is_const();
    has_wildcard_type: (this) -> bool = n*.has_wildcard_type();

    type: (this) -> std::string = {
        ret := n*.object_type();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this type: " + ret);
        return ret;
    }

    initializer: (this) -> std::string = {
        ret := n*.object_initializer();
        require( !contains(ret, "(*ERROR*)"),
                 "cannot to_string this initializer: " + ret);
        return ret;
    }
}


//-----------------------------------------------------------------------
//  Type and namespace declarations
//
type_or_namespace_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_type() || n*.is_namespace() );
    }

    reserve_names: (this, name: std::string_view, forward etc...) =
    {                           // etc is not declared ':string_view' for compatibility with GCC 10.x
        for get_members()
        do  (m) {
            m.require( !m.has_name( name ),
                       "in a '(get_metafunction_name())$' type, the name '(name)$' "
                       "is reserved for use by the '(get_metafunction_name())$' implementation"
            );
        }
        if constexpr !CPP2_PACK_EMPTY(etc) {
            reserve_names( etc... );
        }
    }

    get_member_functions: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_functions_needing_initializer: (this)
        -> std::vector<function_declaration>
    = {
        ret: std::vector<function_declaration> = ();
        for n*.get_nested_declarations(declaration_node::functions)
        do  (d)
        if  !d*.has_initializer()
            && !d*.is_virtual_function()
            && !d*.is_defaultable_function()
        {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_objects: (this)
        -> std::vector<object_declaration>
    = {
        ret: std::vector<object_declaration> = ();
        for n*.get_nested_declarations(declaration_node::objects) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_types: (this)
        -> std::vector<type_declaration>
    = {
        ret: std::vector<type_declaration> = ();
        for n*.get_nested_declarations(declaration_node::types) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_member_aliases: (this)
        -> std::vector<alias_declaration>
    = {
        ret: std::vector<alias_declaration> = ();
        for n*.get_nested_declarations(declaration_node::aliases) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    get_members: (this)
        -> std::vector<declaration>
    = {
        ret: std::vector<declaration> = ();
        for n*.get_nested_declarations(declaration_node::all) do (d) {
            _ = ret.emplace_back( d, this );
        }
        return ret;
    }

    add_member: (inout this, source: std::string_view)
    = {
        decl := parse_statement(source);
        if !(decl as bool) {
            error("the provided source string is not a valid statement");
            return;
        }
        if !decl*.is_declaration() {
            error("cannot add a member that is not a declaration");
        }
        require( n*.add_type_or_namespace_member(move decl),
                 std::string("unexpected error while attempting to add member:\n") + source );
    }
}


type_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_type() );
    }


    is_polymorphic: (this)       -> bool = n*.is_polymorphic();
    is_final      : (this)       -> bool = n*.is_type_final();
    make_final    : (inout this) -> bool = n*.make_type_final();

    query_declared_value_set_functions: (this)
        -> (
            out_this_in_that     : bool,
            out_this_move_that   : bool,
            inout_this_in_that   : bool,
            inout_this_move_that : bool
            )
    = {
        declared := n*.find_declared_value_set_functions();
        out_this_in_that     = declared.out_this_in_that     != nullptr;
        out_this_move_that   = declared.out_this_move_that   != nullptr;
        inout_this_in_that   = declared.inout_this_in_that   != nullptr;
        inout_this_move_that = declared.inout_this_move_that != nullptr;
        // NOLINT(performance-move-const-arg)
    }

    disable_member_function_generation: (inout this) = n*.type_disable_member_function_generation();
    disable_ref_qualifier_generation  : (inout this) = n*.type_disable_ref_qualifier_generation();

    //  At some point we may want to allow this also for namespaces, but for now only types
    remove_marked_members: (inout this) = n*.type_remove_marked_members();
    remove_all_members   : (inout this) = n*.type_remove_all_members();
}


namespace_declaration: @copy_constructible type =
{
    this: type_or_namespace_declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        type_or_namespace_declaration = (n_, s);
        assert( n*.is_namespace() );
    }
}


//-----------------------------------------------------------------------
//  Alias declarations
//
alias_declaration: @copy_constructible type =
{
    this: declaration = ();

    operator=: (
        out this,
        n_: *declaration_node,
        s : compiler_services
    ) =
    {
        declaration = (n_, s);
        assert( n*.is_alias() );
    }
}


//-----------------------------------------------------------------------
//  Parameter declarations
//
parameter_declaration: @copy_constructible type =
{
    this: reflection_base<parameter_declaration_node> = ();

    operator=: (
        out this,
        n_: *parameter_declaration_node,
        s : compiler_services
    )
    = {
        reflection_base<parameter_declaration_node> = (n_, s);
    }

    get_declaration  : (this) -> object_declaration = (n*.declaration.get(), this);
    get_passing_style: (this) -> passing_style      = n*.pass;

    is_implicit: (this) -> bool = n*.mod == parameter_declaration_node::modifier::implicit ;
    is_virtual : (this) -> bool = n*.mod == parameter_declaration_node::modifier::virtual_ ;
    is_override: (this) -> bool = n*.mod == parameter_declaration_node::modifier::override_;
    is_final   : (this) -> bool = n*.mod == parameter_declaration_node::modifier::final_   ;
}


//-----------------------------------------------------------------------
// 
//  Expressions
//
//-----------------------------------------------------------------------
//

//-----------------------------------------------------------------------
//  Binary expressions
//
multiplicative_expression : type == binary_expression< "multiplicative" , is_as_expression_node          >;
additive_expression       : type == binary_expression< "additive"       , multiplicative_expression_node >;
shift_expression          : type == binary_expression< "shift"          , additive_expression_node       >;
compare_expression        : type == binary_expression< "compare"        , shift_expression_node          >;
relational_expression     : type == binary_expression< "relational"     , compare_expression_node        >;
equality_expression       : type == binary_expression< "equality"       , relational_expression_node     >;
bit_and_expression        : type == binary_expression< "bit-and"        , equality_expression_node       >;
bit_xor_expression        : type == binary_expression< "bit-xor"        , bit_and_expression_node        >;
bit_or_expression         : type == binary_expression<