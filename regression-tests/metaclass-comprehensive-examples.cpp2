// Comprehensive metaclass examples from Herb Sutter's cppfront
// Based on P0707 and cppfront regression tests

// ===== INTERFACE METACLASS =====
shape: @interface type = {
    area: (this) -> double;
    scale: (inout this, factor: double);
}

// ===== VALUE TYPE METACLASSES =====
point: @value type = {
    x: double = 0.0;
    y: double = 0.0;
}

widget: @value type = {
    val: int = 0;
    operator=: (out this, i: int) = { val = i; }
}

weakly_ordered_widget: @weakly_ordered_value type = {
    val: int = 0;
    operator=: (out this, i: int) = { val = i; }
}

partially_ordered_widget: @partially_ordered_value type = {
    val: int = 0;
    operator=: (out this, i: int) = { val = i; }
}

// ===== POLYMORPHIC BASE METACLASS =====
polymorphic_base_example: @polymorphic_base type = {
    id: int = 0;
    work: (virtual this);
}

// ===== ENUM METACLASSES =====
skat_game: @enum type = {
    diamonds := 9;
    hearts;  // 10
    spades;  // 11
    clubs;   // 12
    grand    := 20;
    null     := 23;
}

janus: @enum type = {
    past;
    future;

    flip: (inout this) == {
        if this == past { this = future; }
        else { this = past; }
    }
}

file_attributes: @flag_enum<u8> type = {
    cached;     // 1
    current;    // 2
    obsolete;   // 4
    cached_and_current := cached | current;
}

// ===== UNION METACLASS =====
name_or_number: @union type = {
    name: std::string;
    num : i32;
}

name_or_other: @union <T:type> type = {
    name  : std::string;
    other : T;

    to_string: (this) -> std::string = {
        if is_name()       { return name(); }
        else if is_other() { return other() as std::string; }
        else               { return "invalid value"; }
    }
}

// ===== STRUCT METACLASS =====
simple_struct: @struct type = {
    x: int;
    y: int;
}

// ===== REGEX METACLASS =====
name_matcher: @regex type = {
    regex := R"((\w+) (\w+))";  // for example: Margaret Hamilton
}

// ===== CONCRETE TYPE IMPLEMENTING INTERFACE =====
circle: type = {
    center: point;
    radius: double = 1.0;

    this: shape = {
        area: (this) -> double = {
            return 3.14159 * radius * radius;
        }
        scale: (inout this, factor: double) = {
            radius *= factor;
        }
    }

    operator=: (out this, c: point, r: double) = {
        center = c;
        radius = r;
    }
}

// ===== POLYMORPHIC TYPE =====
concrete_poly: type = {
    this: polymorphic_base_example = {
        work: (override this) = {
            std::cout << "Working with id: (id)$\n";
        }
    }
}

// ===== TEST FUNCTIONS =====
test_value_types: () = {
    // Test @value
    p: point = (1.0, 2.0);
    w: widget = 42;

    // Test comparisons (generated by @value)
    if p == point{1.0, 2.0} {
        std::cout << "Points are equal\n";
    }

    // Test @weakly_ordered_value
    ww1: weakly_ordered_widget = 10;
    ww2: weakly_ordered_widget = 20;
    if ww1 < ww2 {
        std::cout << "Weak ordering works\n";
    }
}

test_enums: () = {
    // Test @enum
    game: skat_game = skat_game::hearts;
    std::cout << "Game: (game.to_string())$\n";

    // Test @enum with member function
    j: janus = janus::past;
    j.flip();
    std::cout << "Janus: (j.to_string())$\n";

    // Test @flag_enum
    flags: file_attributes = file_attributes::cached | file_attributes::current;
    if flags.has(file_attributes::cached) {
        std::cout << "Has cached flag\n";
    }
}

test_union: () = {
    // Test @union
    val: name_or_number = ();
    val.set_name("Test");
    if val.is_name() {
        std::cout << "Name: (val.name())$\n";
    }

    // Test templated @union
    other_val: name_or_other<int> = ();
    other_val.set_other(123);
    std::cout << "Other: (other_val.to_string())$\n";
}

test_interface: () = {
    // Test @interface implementation
    c: circle = (point{0.0, 0.0}, 5.0);
    std::cout << "Area: (c.area())$\n";
    c.scale(2.0);
    std::cout << "Scaled area: (c.area())$\n";
}

test_polymorphic: () = {
    // Test @polymorphic_base
    poly: concrete_poly = ();
    poly.work();
}

test_regex: () = {
    // Test @regex
    matcher: name_matcher = ();
    result := matcher.regex.match("John Doe");
    if result.matched {
        std::cout << "First name: (result.group(1))$\n";
        std::cout << "Last name: (result.group(2))$\n";
    }
}

main: () -> int = {
    std::cout << "=== Testing Metaclass Examples ===\n\n";

    test_value_types();
    std::cout << "\n";

    test_enums();
    std::cout << "\n";

    test_union();
    std::cout << "\n";

    test_interface();
    std::cout << "\n";

    test_polymorphic();
    std::cout << "\n";

    test_regex();
    std::cout << "\n";

    std::cout << "=== All metaclass tests completed ===\n";
    return 0;
}
