ad_order : int  == 6;
ad_type  : type == cpp2::taylor<double, ad_order>;

ad_name: namespace = {

func_outer: (x: double, y: double) -> (ret: double) = {
  ret = x + y;
}

type_outer: type = {
  public a: double = 0.0;

  add: (this, b: double) -> double = {
    return a + b;
  }
}

ad_test: @autodiff<"order=6"> @print type = {

    add_1: (x: double, y: double) -> (r: double) = {
        r = x + y;
    }

    add_2: (x: double, y: double) -> (r: double) = {
        r = x + y + x;
    }

    sub_1: (x: double, y: double) -> (r: double) = {
        r = x - y;
    }

    sub_2: (x: double, y: double) -> (r: double) = {
        r = x - y - x;
    }

    add_sub_2: (x: double, y: double) -> (r: double) = {
        r = x + y - x;
    }

    mul_1: (x: double, y: double) -> (r: double) = {
        r = x * y;
    }

    mul_2: (x: double, y: double) -> (r: double) = {
        r = x * y * x;
    }

    div_1: (x: double, y: double) -> (r: double) = {
        r = x / y;
    }

    div_2: (x: double, y: double) -> (r: double) = {
        r = x / y / y;
    }

    mul_div_2: (x: double, y: double) -> (r: double) = {
        r = x * y / x;
    }

    mul_add: (x: double, y: double) -> (r: double) = {
        r = x * (x + y);
    }

    add_mul: (x: double, y: double) -> (r: double) = {
        r = x + x * y;
    }

    prefix_add: (x: double, y: double) -> (r: double) = {
        r = +x + y;
    }

    prefix_sub: (x: double, y: double) -> (r: double) = {
        r = -x + y;
    }

    func: (x: double, y: double) -> (ret: double) = {
      ret = x + y;
    }

    func_call: (x: double, y: double) -> (r: double) = {
      r = x * func(x, y);
    }

    func_outer_call: (x: double, y: double) -> (r: double) = {
      r = x * func_outer(x, y);
    }

    sin_call: (x: double, y: double) -> (r: double) = {
      r = sin(x - y);
    }

    if_branch: (x: double, y: double) -> (r: double) = {
      r = x;

      if x < 0.0 {
        r = y;
      }
    }

    if_else_branch: (x: double, y: double) -> (r: double) = {
      if x < 0.0 {
        r = y;
      }
      else {
        r = x;
      }
    }

    direct_return: (x: double, y: double) -> double = {
      return x + y;
    }

    intermediate_var: (x: double, y: double) -> (r: double) = {
      t: double = x + y;

      r = t;
    }

    intermediate_passive_var: (x: double, y: double) -> (r: double) = {
      i: int = (); // TODO: Handle as passive when type information on call side is available.
      r = x + y;
      i = 2;

      _ = i;
    }

    intermediate_untyped: (x: double, y: double) -> (r: double) = {
      t := 0.0;
      t = x + y;

      r = t;
    }

    intermediate_default_init: (x: double, y: double) -> (r: double) = {
      t: double = ();
      t = x + y;

      r = t;
    }

    intermediate_no_init: (x: double, y: double) -> (r: double) = {
      t: double;
      t = x + y;

      r = t;
    }

    while_loop: (x: double, y: double) -> (r: double) = {
      i: int = 0;

      r = x;
      while i < 2 next (i += 1) {
        r = r + y ;
      }
    }

    do_while_loop: (x: double, y: double) -> (r: double) = {
      i: int = 0;

      r = x;
      do {
        r = r + y ;
      }
      next (i += 1)
      while i < 2;
    }

    for_loop: (x: double, y: double) -> (r: double) = {
      v: std::vector<double> = ();

      v.push_back(x);
      v.push_back(y);

      r = 0.0;
      for v
      do (t)
      {
        r = r + t;
      }
    }

    type_outer_use: (x: double, y: double) -> (r: double) = {
      t : type_outer = ();
      t.a = x;

      r = t.a + y;
    }

    type_outer_call: (x: double, y: double) -> (r: double) = {
      t : type_outer = ();
      t.a = x;

      r = t.add(y);
    }
}
}

write_output: (func: std::string, x: double, x_d: ad_type, y: double, y_d: ad_type, ret) = {
    std::cout << "diff((func)$) at (x = (x)$, x_d = (x_d)$, y = (y)$, y_d = (y_d)$):" << std::endl;
    std::cout << "  r = (ret.r)$" << std::endl;
    (copy i:=1)
    while i <= ad_order next i += 1 {
      std::cout << "  d(i)$ = (ret.r_d[i])$" << std::endl;
    }
}

main: () = {


    x:   double  = 2.0;
    x_d: ad_type = 1.0;
    y:   double  = 3.0;
    y_d: ad_type = 2.0;

    write_output("x + y", x, x_d, y, y_d, ad_name::ad_test::add_1_d(x, x_d, y, y_d));
    write_output("x + y + x", x, x_d, y, y_d, ad_name::ad_test::add_2_d(x, x_d, y, y_d));
    write_output("x - y", x, x_d, y, y_d, ad_name::ad_test::sub_1_d(x, x_d, y, y_d));
    write_output("x - y - x", x, x_d, y, y_d, ad_name::ad_test::sub_2_d(x, x_d, y, y_d));
    write_output("x + y - x", x, x_d, y, y_d, ad_name::ad_test::add_sub_2_d(x, x_d, y, y_d));
    write_output("x * y", x, x_d, y, y_d, ad_name::ad_test::mul_1_d(x, x_d, y, y_d));
    write_output("x * y * x", x, x_d, y, y_d, ad_name::ad_test::mul_2_d(x, x_d, y, y_d));
    write_output("x / y", x, x_d, y, y_d, ad_name::ad_test::div_1_d(x, x_d, y, y_d));
    write_output("x / y / y", x, x_d, y, y_d, ad_name::ad_test::div_2_d(x, x_d, y, y_d));
    write_output("x * y / x", x, x_d, y, y_d, ad_name::ad_test::mul_div_2_d(x, x_d, y, y_d));
    write_output("x * (x + y)", x, x_d, y, y_d, ad_name::ad_test::mul_add_d(x, x_d, y, y_d));
    write_output("x + x * y", x, x_d, y, y_d, ad_name::ad_test::add_mul_d(x, x_d, y, y_d));
    write_output("+x + y)", x, x_d, y, y_d, ad_name::ad_test::prefix_add_d(x, x_d, y, y_d));
    write_output("-x + y)", x, x_d, y, y_d, ad_name::ad_test::prefix_sub_d(x, x_d, y, y_d));
    write_output("x * func(x, y)", x, x_d, y, y_d, ad_name::ad_test::func_call_d(x, x_d, y, y_d));
    write_output("x * func_outer(x, y)", x, x_d, y, y_d, ad_name::ad_test::func_outer_call_d(x, x_d, y, y_d));
    write_output("sin(x - y)", x, x_d, y, y_d, ad_name::ad_test::sin_call_d(x, x_d, y, y_d));
    write_output("if branch", x, x_d, y, y_d, ad_name::ad_test::if_branch_d(x, x_d, y, y_d));
    write_output("if else branch", x, x_d, y, y_d, ad_name::ad_test::if_else_branch_d(x, x_d, y, y_d));
    write_output("direct return", x, x_d, y, y_d, ad_name::ad_test::direct_return_d(x, x_d, y, y_d));
    write_output("intermediate var", x, x_d, y, y_d, ad_name::ad_test::intermediate_var_d(x, x_d, y, y_d));
    write_output("intermediate passive var", x, x_d, y, y_d, ad_name::ad_test::intermediate_passive_var_d(x, x_d, y, y_d));
    write_output("intermediate untyped", x, x_d, y, y_d, ad_name::ad_test::intermediate_untyped_d(x, x_d, y, y_d));
    write_output("intermediate default init", x, x_d, y, y_d, ad_name::ad_test::intermediate_default_init_d(x, x_d, y, y_d));
    write_output("intermediate no init", x, x_d, y, y_d, ad_name::ad_test::intermediate_no_init_d(x, x_d, y, y_d));
    write_output("while loop", x, x_d, y, y_d, ad_name::ad_test::while_loop_d(x, x_d, y, y_d));
    write_output("do while loop", x, x_d, y, y_d, ad_name::ad_test::do_while_loop_d(x, x_d, y, y_d));
    write_output("for loop", x, x_d, y, y_d, ad_name::ad_test::for_loop_d(x, x_d, y, y_d));
    write_output("tye_outer.a + y", x, x_d, y, y_d, ad_name::ad_test::type_outer_use_d(x, x_d, y, y_d));
    write_output("type_outer.add(y)", x, x_d, y, y_d, ad_name::ad_test::type_outer_call_d(x, x_d, y, y_d));
}
