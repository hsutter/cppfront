f_inout: (inout x: int) -> _ = {
    x *= 2;
    return x;
}

issue_350: () = {
    x := 21;

    l1 := :(forward x) = {
        std::cout << f_inout(forward x) << std::endl;
    };

    l1(x);

    x++;
}

issue_440: () = {
  i: int;
  if true {
    i = 1;
  }
  i = 2;
}

issue_683: (args) = {
    for args do (n) {
        _ = n;
    }

    n: int;
    n = 0;
}

issue_825: () = {
  _ = :(copy b) _ = b;
  _ = :(move c) _ = c;
  _ = :(forward d) _ = d;
}

issue_832: () = {
  i := 0;
  while i { }
}

make_copy: (copy x) x;

issue_847_0: (copy v: std::vector<std::unique_ptr<int>>) = { for v.make_copy() do (_) { } }
issue_847_1: (move v: std::vector<std::unique_ptr<int>>) = { for v.make_copy() do (_) { } }
issue_847_2: (forward v) = { for v.make_copy() do (_) { } }
issue_847_3: (copy x: int) = { for (x) do (_) { } }

f_inout: (inout _: std::unique_ptr<int>) = { }
f_inout: (inout _) = { }
f_copy: (copy _...) = { }

issue_857: type = {
  a: std::unique_ptr<int>;
  b: std::unique_ptr<int>;
  operator=: (out this, move that) = { }
  operator=: (move this) = {
    f_inout(a);
    f_copy(this.b);
  }
  f: (move this) = f_copy(this);
  f: (move this, move that) = f_copy(this, that);
  g: (move this) = f_copy(this.a);
  g: (move this, move that) = f_copy(this.a, that.a);
  h: (inout this) = f_inout(a);
  i: (move this) = f_copy(a);
  j: (move this) = f_copy(a);
  k: (move this) = {
    f_inout(a);
    f_copy(b);
  }
  l: (move this) = k();
  m: (move this) = this.k();
  n: (_) = { }
  n: (move this) = { }
  o0:(move this) = n();
  o1:(move this) = this.n();
  o2:(move this) = 0.n();
  o3:(move this) = n(0);
  o4:(move this) = n(this);
  p0: (move this) = {
    f_inout(a);
    f_copy(this.a);
  }
  p1: (move this) = {
    f_inout(this.a);
    f_copy(a);
  }
  p2: (move this) = {
    f_inout(a);
    f_copy(this);
  }
  p3: (move this) = {
    f_inout(this);
    f_copy(a);
  }
  q: (move this) = {
    h();
    n();
  }
// FIXME Lack of implicit moves in sibling selections.
// Not a `this` problem: <https://cpp2.godbolt.org/z/hbeje4c3M>.
//z: (move this, move that) = {
///*f */      if true { f_copy(this); }
///*f */ else if true { f_copy(this, that); }
///*g */ else if true { f_copy(this.a); }
///*g */ else if true { f_copy(this.a, that.a); }
///*i */ else if true { f_copy(a); }
///*j */ else if true { f_copy(a); }
///*k */ else if true { f_copy(a, b); }
///*l */ else if true { k(); }
///*m */ else if true { this.k(); }
///*o1*/ else if true { n(); }
///*o2*/ else if true { this.n(); }
///*o3*/ else if true { n(0); }
///*o4*/ else         { n(this); }
//}
}

issue_857_2: @struct type = {
  a: std::unique_ptr<int>; // OK: No error about 'a' being unused.
}

gi: int = 0;
issue_857_3: @struct type = {
  i: std::add_lvalue_reference_t<int> = gi;
  f: (move this) = _ = f_inout(i); // OK: The implicit `this` is moved, not `i`.
}

issue_857_4: @struct type = {
   f: std::add_pointer_t<int()>;
   g: std::add_pointer_t<int(int)>;
  mf: std::add_pointer_t<int()>;    // TODO Use `std::move_only_function`.
  mg: std::add_pointer_t<int(int)>; // Ditto.
  h0: (move this) = _ = mf();
  h1: (move this) = _ = this.mf();
  h2: (move this, that) = _ = that.mf();
  h3: (move this, that) = _ = that.f;
  h4: (move this, x: int) = _ = x.mg();
  h5: (move this, x: int) = _ = f() + x.g();      // FIXME #313.
  h6: (move this, x: int) = _ = x.g() + f();      // FIXME #313.
  h7: (move this, x: int) = _ = this.f() + x.g(); // FIXME #313.
  h8: (move this, x: int) = _ = x.g() + this.f(); // FIXME #313.
  i0: (move this, x: int) = {
    _ = f();
    _ = x.mg();
  }
  i1: (move this, x: int) = {
    _ = x.g();
    _ = mf();
  }
  i2: (move this, x: int) = {
    _ = this.f();
    _ = x.mg();
  }
  i3: (move this, x: int) = {
    _ = x.g();
    _ = this.mf();
  }
}

issue_869: @union type = {
  i: int;
}

issue_884_3: () = {
  x := new<int>(0);
  if true { }
  if true { }
  {
    { f_inout(x); }
    f_copy(x);
  }
}

issue_884: () = {
  x := new<int>(0);
  if true { }
  {
    { f_inout(x); }
    f_copy(x);
  }
}

issue_884_2: () = {
  x := new<int>(0);
  if true { }
  {
    f_inout(x);
  }
  f_copy(x);
}

issue_888_0: (copy r: std::string, copy size: int) = {
  _ = r.size();
}
// TODO Use `std::move_only_function`.
issue_888_1: (copy _: std::string, copy size: std::add_pointer_t<int(int)>) = {
  _ = 0.size();
}

draw: () = {
  pos       := 0;
  vertex    := :(_) = { }; // TODO Use `std::move_only_function`.
  _ = (pos).vertex();
}

enum_0: () = {
  underlying_type: int;
  if true { }
  underlying_type = 0;
}

enum_1: () = {
  underlying_type: int;
  if true {
    underlying_type = 0;
  }
  underlying_type = 0;
}

union: type = {
  destroy: (inout this) = { }
  operator=: (move this) = {
    destroy();
    _ = this;
  }
}

my_string: @struct type = {
  string: std::string;
  size: std::size_t = string.size();
}

main: (args) = {
  issue_683(args);
  issue_847_2(std::vector<std::unique_ptr<int>>());
  enum_0();
//enum_1(); // FIXME "Contract violation".
}
