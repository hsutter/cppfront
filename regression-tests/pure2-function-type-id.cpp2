main: () = {
  postfix_operators();

  // Variables with type of a mix of `*`/`const` to `() throws -> void`.
  f0: * () throws = :()       = {};
  f1: const * () throws       = f0;
  f2: * const () throws       = f0;
  f3: const * const () throws = f0;

  // Uninitialized.
  f4: * () throws;
  f4 = f0;

  f10: * * () throws             = f0&;
  f11: const * * () throws       = f10;
  f12: * const * () throws       = f10;
  f13: const * const * () throws = f10;

  i: i32                = 0;
  i0: * i32             = i&;
  i1: const * i32       = i0;
  i2: * const i32       = i0;
  i3: const * const i32 = i0;

  // Assert consistent '*'/'const' with non-function type variables.
  static_assert((std::is_const_v<decltype(f10)>) == std::is_const_v<decltype(i0)>);
  static_assert((std::is_const_v<decltype(f11)>) == std::is_const_v<decltype(i1)>);
  static_assert((std::is_const_v<decltype(f12)>) == std::is_const_v<decltype(i2)>);
  static_assert((std::is_const_v<decltype(f13)>) == std::is_const_v<decltype(i3)>);
  _ = f10;
  _ = f11;
  _ = f12;
  _ = f13;
  _ = i0;
  _ = i1;
  _ = i2;
  _ = i3;

  // Variables with various kinds of parameter.
  f5: * (_: i32) throws = :(x: i32) = {};
  f6: * (_: std::any) throws = :(x: std::any) = {};
  f7: * (move _: i32) throws = :(move x: i32) = {};
  f8: * (out _: i32) throws = :(copy x) = {};

  // In alternative.
  [[assert: inspect f0 -> bool {
    is ()          = (std::terminate(), false);
    is () throws   = (std::terminate(), false);
    is * () throws = true;
    is _           = false;
  }]]
  [[assert: inspect f0* -> bool {
    is () throws = true;
    is _         = false;
  }]]

  // As block variable.
  (f: * () throws = f0) { }
  (f: () throws   = f0*) { }

  // As local function parameter.
  _ = :(f: () throws) = {};
  _ = :(f: * () throws) = {};
  _ = :(f: * () throws -> * () throws) = {};
  _ = :(f: * () throws -> * () throws -> * () throws) = {};

  // In local function return type.
  _ = :() -> forward() throws = f0$*;
  _ = :() -> * () throws = nullptr;
  _ = :() -> * () throws -> * () throws = nullptr;

  // Without `throws`.
  _ = :* (copy _: std::string_view, copy _: CPP2_MESSAGE_PARAM) = cpp2::report_and_terminate;

  // As template argument.
  _ = :std::type_identity_t<* () throws> = f0;
  static_assert(std::is_function_v<() throws>);
}

// As non-local function parameter.
g: (f: () throws)                  = { }
g: (f: * () throws)                = { }
g: (f: * () throws -> * () throws) = { }
// As template parameter.
g: <V: * () throws> ()                = { }
g: <V: * () throws -> * () throws> () = { }

// In non-local function return type.
g1: () -> * () throws                      = nullptr;
g1: <V: bool> () -> * () throws requires V = { return nullptr; }
g2: () -> * () throws -> * () throws       = nullptr;

// clang-format off
// Test case from #343.
f2: () -> std::function<(_: std::string) throws -> std::string> = {
  return :(s: std::string) -> std::string = { return s + " World!"; };
}

// Adapted from <https://github.com/hsutter/cppfront/wiki/Design-note%3A-Postfix-operators>.
            f:   (x: i32)        -> * (_: i32) throws -> std::string = +:(x: i32) -> std::string = "";
postfix_operators: () = {
  [[assert: f is (_: i32) throws -> * (_: i32) throws -> std::string]]
  //             /                  |  |
  //            /                   |  |
  [[assert: f(42)        is         * (_: i32) throws -> std::string]]
  //               ________________/   |
  //              /                    |
  [[assert: f(42)*         is         (_: i32) throws -> std::string]]
  //                   _______________/
  //                  /
  [[assert: (f(42)*)(1)                is                std::string]]
} // clang-format on
