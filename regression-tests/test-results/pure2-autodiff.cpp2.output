pure2-autodiff.cpp2...

ad_test:/* @autodiff @print */ type = 
{
    add_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y;
        return;
    }

    add_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y + x;
        return;
    }

    sub_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x - y;
        return;
    }

    sub_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x - y - x;
        return;
    }

    add_sub_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y - x;
        return;
    }

    mul_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y;
        return;
    }

    mul_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y * x;
        return;
    }

    div_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x / y;
        return;
    }

    div_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x / y / y;
        return;
    }

    mul_div_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y / x;
        return;
    }

    mul_add:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * (x + y);
        return;
    }

    add_mul:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + x * y;
        return;
    }

    prefix_add:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = +x + y;
        return;
    }

    prefix_sub:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = -x + y;
        return;
    }

    func:(
        in x: double, 
        in y: double, 
    ) -> (out ret: double, ) = 
    {
        ret = x + y;
        return;
    }

    func_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * func(x, y);
        return;
    }

    func_outer_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * func_outer(x, y);
        return;
    }

    sin_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = sin(x - y);
        return;
    }

    if_branch:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x;
        if x < 0.0
        {
            r = y;
        }
        return;
    }

    if_else_branch:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        if x < 0.0
        {
            r = y;
        }
        else 
        {
            r = x;
        }
        return;
    }

    direct_return:(
        in x: double, 
        in y: double, 
    ) -> move double = 
    {
        return x + y;
    }

    intermediate_var:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: double = x + y;
        r = t;
        return;
    }

    intermediate_passive_var:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        i: int = ();
        r = x + y;
        i = 2;
        _ = i;
        return;
    }

    intermediate_untyped:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: _ = 0.0;
        t = x + y;
        r = t;
        return;
    }

    intermediate_default_init:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: double = ();
        t = x + y;
        r = t;
        return;
    }

    intermediate_no_init:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: double;
        t = x + y;
        r = t;
        return;
    }

    while_loop:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x;
        (
            copy i: int = 0, 
            copy t: double = 0.0, 
        )
        while i < 2
        next (i += 1)
            {
                t = y;
                r = r + t;
            }
        return;
    }

    do_while_loop:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x;
        (copy i: _ = 0, )
        do 
            {
                r = r + y;
            }
        next (i += 1)
        while i < 2;
        return;
    }

    for_loop:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        v: std::vector<double> = ();
        v.push_back(x);
        v.push_back(y);
        r = 0.0;
        for v
        do (in t: _)
            {
                r = r + t;
            }
        return;
    }

    type_outer_use:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: type_outer = ();
        t.a = x;
        r = t.a + y;
        return;
    }

    type_outer_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        t: type_outer = ();
        t.a = x;
        r = t.add(y);
        return;
    }

    add_1_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d + y_d;
        r = x + y;
        return;
    }

    add_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d + y_d + x_d;
        r = x + y + x;
        return;
    }

    sub_1_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d - y_d;
        r = x - y;
        return;
    }

    sub_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d - y_d - x_d;
        r = x - y - x;
        return;
    }

    add_sub_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d + y_d - x_d;
        r = x + y - x;
        return;
    }

    mul_1_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = y * x_d + x * y_d;
        r = x * y;
        return;
    }

    mul_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: _ = y * x_d + x * y_d;
        temp_1: _ = x * y;
        r_d = x * temp_1_d + temp_1 * x_d;
        r = temp_1 * x;
        return;
    }

    div_1_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d / y + -x * y_d / (y * y);
        r = x / y;
        return;
    }

    div_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: _ = x_d / y + -x * y_d / (y * y);
        temp_1: _ = x / y;
        r_d = temp_1_d / y + -temp_1 * y_d / (y * y);
        r = temp_1 / y;
        return;
    }

    mul_div_2_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: _ = y * x_d + x * y_d;
        temp_1: _ = x * y;
        r_d = temp_1_d / x + -temp_1 * x_d / (x * x);
        r = temp_1 / x;
        return;
    }

    mul_add_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: double = x_d + y_d;
        temp_1: double = x + y;
        r_d = temp_1 * x_d + x * temp_1_d;
        r = x * temp_1;
        return;
    }

    add_mul_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: double = y * x_d + x * y_d;
        temp_1: double = x * y;
        r_d = x_d + temp_1_d;
        r = x + temp_1;
        return;
    }

    prefix_add_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: double = +x_d;
        temp_1: double = +x;
        r_d = temp_1_d + y_d;
        r = temp_1 + y;
        return;
    }

    prefix_sub_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: double = -x_d;
        temp_1: double = -x;
        r_d = temp_1_d + y_d;
        r = temp_1 + y;
        return;
    }

    func_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out ret: double = 0.0, 
            out ret_d: double = 0.0, 
        ) = 
    {
        ret_d = x_d + y_d;
        ret = x + y;
        return;
    }

    func_call_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1: _ = func_d(x, x_d, y, y_d);
        temp_2_d: double = temp_1.ret_d;
        temp_2: double = func(x, y);
        r_d = temp_2 * x_d + x * temp_2_d;
        r = x * temp_2;
        return;
    }

    func_outer_call_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1: _ = func_outer_d(x, x_d, y, y_d);
        temp_2_d: double = temp_1.ret_d;
        temp_2: double = func_outer(x, y);
        r_d = temp_2 * x_d + x * temp_2_d;
        r = x * temp_2;
        return;
    }

    sin_call_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        temp_1_d: double = x_d - y_d;
        temp_1: double = x - y;
        r_d = cos(temp_1) * temp_1_d;
        r = sin(temp_1);
        return;
    }

    if_branch_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d;
        r = x;
        if x < 0.0
        {
            r_d = y_d;
            r = y;
        }
        else 
        {
        }
        return;
    }

    if_else_branch_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        if x < 0.0
        {
            r_d = y_d;
            r = y;
        }
        else 
        {
            r_d = x_d;
            r = x;
        }
        return;
    }

    direct_return_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = (), 
            out r_d: double = (), 
        ) = 
    {
        r_d = x_d + y_d;
        r = x + y;
        return;
    }

    intermediate_var_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: double = x_d + y_d;
        t: double = x + y;
        r_d = t_d;
        r = t;
        return;
    }

    intermediate_passive_var_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        i: int = ();
        r_d = x_d + y_d;
        r = x + y;
        i = 2;
        _ = i;
        return;
    }

    intermediate_untyped_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: _ = double();
        t: _ = 0.0;
        t_d = x_d + y_d;
        t = x + y;
        r_d = t_d;
        r = t;
        return;
    }

    intermediate_default_init_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: double = ();
        t: double = ();
        t_d = x_d + y_d;
        t = x + y;
        r_d = t_d;
        r = t;
        return;
    }

    intermediate_no_init_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: double;
        t: double;
        t_d = x_d + y_d;
        t = x + y;
        r_d = t_d;
        r = t;
        return;
    }

    while_loop_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d;
        r = x;
        (
            copy i: int = 0, 
            copy t: double = 0.0, 
            copy t_d: double = (), 
        )
        while i < 2
        next (i += 1)
            {
                t_d = y_d;
                t = y;
                r_d = r_d + t_d;
                r = r + t;
            }
        return;
    }

    do_while_loop_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x_d;
        r = x;
        (copy i: _ = 0, )
        do 
            {
                r_d = r_d + y_d;
                r = r + y;
            }
        next (i += 1)
        while i < 2;
        return;
    }

    for_loop_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        v_d: std::vector<double> = ();
        v: std::vector<double> = ();
        v_d.push_back(x_d);
        v.push_back(x);
        v_d.push_back(y_d);
        v.push_back(y);
        r_d = ();
        r = 0.0;
        (copy t_d_iter: _ = v_d.begin(), )
        for v
        next (t_d_iter++)
        do (in t: _)
            {
                (in t_d: _ = t_d_iter*, )
                {
                    r_d = r_d + t_d;
                    r = r + t;
                }
            }
        return;
    }

    type_outer_use_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: type_outer_d = ();
        t: type_outer = ();
        t_d.a_d = x_d;
        t.a = x;
        temp_1_d: double = t_d.a_d;
        temp_1: double = t.a;
        r_d = temp_1_d + y_d;
        r = temp_1 + y;
        return;
    }

    type_outer_call_d:(
        in x: double, 
        in x_d: double, 
        in y: double, 
        in y_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        t_d: type_outer_d = ();
        t: type_outer = ();
        t_d.a_d = x_d;
        t.a = x;
        temp_1: _ = t.add_d(t_d, y, y_d);
        r_d = temp_1.r_d;
        r = t.add(y);
        return;
    }
}


ad_test_reverse:/* @autodiff<"reverse"> @print */ type = 
{
    add_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y;
        return;
    }

    add_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y + x;
        return;
    }

    sub_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x - y;
        return;
    }

    sub_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x - y - x;
        return;
    }

    add_sub_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + y - x;
        return;
    }

    mul_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y;
        return;
    }

    mul_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y * x;
        return;
    }

    div_1:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x / y;
        return;
    }

    div_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x / y / y;
        return;
    }

    mul_div_2:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * y / x;
        return;
    }

    mul_add:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * (x + y);
        return;
    }

    add_mul:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x + x * y;
        return;
    }

    sin_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = sin(x - y);
        return;
    }

    func:(
        in x: double, 
        in y: double, 
    ) -> (out ret: double, ) = 
    {
        ret = x + y;
        return;
    }

    func_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * func(x, y);
        return;
    }

    func_outer_call:(
        in x: double, 
        in y: double, 
    ) -> (out r: double, ) = 
    {
        r = x * func_outer(x, y);
        return;
    }

    add_1_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x + y;
        x_b += r_b;
        y_b += r_b;
        r_b = 0.0;
        return;
    }

    add_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x + y + x;
        x_b += r_b;
        y_b += r_b;
        x_b += r_b;
        r_b = 0.0;
        return;
    }

    sub_1_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x - y;
        x_b += r_b;
        y_b -= r_b;
        r_b = 0.0;
        return;
    }

    sub_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x - y - x;
        x_b += r_b;
        y_b -= r_b;
        x_b -= r_b;
        r_b = 0.0;
        return;
    }

    add_sub_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x + y - x;
        x_b += r_b;
        y_b += r_b;
        x_b -= r_b;
        r_b = 0.0;
        return;
    }

    mul_1_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x * y;
        x_b += y * r_b;
        y_b += x * r_b;
        r_b = 0.0;
        return;
    }

    mul_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: _ = 0.0;
        temp_1: _ = x * y;
        r = temp_1 * x;
        temp_1_b += x * r_b;
        x_b += temp_1 * r_b;
        r_b = 0.0;
        x_b += y * temp_1_b;
        y_b += x * temp_1_b;
        temp_1_b = 0.0;
        return;
    }

    div_1_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        r = x / y;
        x_b += r_b / y;
        y_b -= x * r_b / (y * y);
        r_b = 0.0;
        return;
    }

    div_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: _ = 0.0;
        temp_1: _ = x / y;
        r = temp_1 / y;
        temp_1_b += r_b / y;
        y_b -= temp_1 * r_b / (y * y);
        r_b = 0.0;
        x_b += temp_1_b / y;
        y_b -= x * temp_1_b / (y * y);
        temp_1_b = 0.0;
        return;
    }

    mul_div_2_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: _ = 0.0;
        temp_1: _ = x * y;
        r = temp_1 / x;
        temp_1_b += r_b / x;
        x_b -= temp_1 * r_b / (x * x);
        r_b = 0.0;
        x_b += y * temp_1_b;
        y_b += x * temp_1_b;
        temp_1_b = 0.0;
        return;
    }

    mul_add_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: double = 0.0;
        temp_1: double = x + y;
        r = x * temp_1;
        x_b += temp_1 * r_b;
        temp_1_b += x * r_b;
        r_b = 0.0;
        x_b += temp_1_b;
        y_b += temp_1_b;
        temp_1_b = 0.0;
        return;
    }

    add_mul_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: double = 0.0;
        temp_1: double = x * y;
        r = x + temp_1;
        x_b += r_b;
        temp_1_b += r_b;
        r_b = 0.0;
        x_b += y * temp_1_b;
        y_b += x * temp_1_b;
        temp_1_b = 0.0;
        return;
    }

    sin_call_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_1_b: double = 0.0;
        temp_1: double = x - y;
        r = sin(temp_1);
        temp_1_b += cos(temp_1) * r_b;
        r_b = 0.0;
        x_b += temp_1_b;
        y_b -= temp_1_b;
        temp_1_b = 0.0;
        return;
    }

    func_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout ret_b: double, 
    ) -> (out ret: double = 0.0, ) = 
    {
        ret = x + y;
        x_b += ret_b;
        y_b += ret_b;
        ret_b = 0.0;
        return;
    }

    func_call_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_2_b: double = 0.0;
        temp_2: double = func(x, y);
        r = x * temp_2;
        x_b += temp_2 * r_b;
        temp_2_b += x * r_b;
        r_b = 0.0;
        _ = func_b(x, x_b, y, y_b, temp_2_b);
        temp_2_b = 0.0;
        return;
    }

    func_outer_call_b:(
        in x: double, 
        inout x_b: double, 
        in y: double, 
        inout y_b: double, 
        inout r_b: double, 
    ) -> (out r: double = 0.0, ) = 
    {
        temp_2_b: double = 0.0;
        temp_2: double = func_outer(x, y);
        r = x * temp_2;
        x_b += temp_2 * r_b;
        temp_2_b += x * r_b;
        r_b = 0.0;
        _ = func_outer_b(x, x_b, y, y_b, temp_2_b);
        temp_2_b = 0.0;
        return;
    }
}


ad_test_twice:/* @autodiff @autodiff<"suffix=_d2"> @print */ type = 
{
    mul_1:(in x: double, ) -> (out r: double, ) = 
    {
        r = x * x;
        return;
    }

    mul_1_d:(
        in x: double, 
        in x_d: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d: double = 0.0, 
        ) = 
    {
        r_d = x * x_d + x * x_d;
        r = x * x;
        return;
    }

    mul_1_d2:(
        in x: double, 
        in x_d2: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d2: double = 0.0, 
        ) = 
    {
        r_d2 = x * x_d2 + x * x_d2;
        r = x * x;
        return;
    }

    mul_1_d_d2:(
        in x: double, 
        in x_d2: double, 
        in x_d: double, 
        in x_d_d2: double, 
    ) -> (
            out r: double = 0.0, 
            out r_d2: double = 0.0, 
            out r_d: double = 0.0, 
            out r_d_d2: double = 0.0, 
        ) = 
    {
        temp_1_d2: double = x_d * x_d2 + x * x_d_d2;
        temp_1: double = x * x_d;
        temp_2_d2: double = x_d * x_d2 + x * x_d_d2;
        temp_2: double = x * x_d;
        r_d_d2 = temp_1_d2 + temp_2_d2;
        r_d = temp_1 + temp_2;
        r_d2 = x * x_d2 + x * x_d2;
        r = x * x;
        return;
    }
}


ad_test_2:/* @autodiff<"order=2"> @print */ type = 
{
    f:(in x: double, ) -> (out y: double, ) = 
    {
        if x < -3
        {
            y = x * x;
        }
        else 
        {
            if x < 3
            {
                y = x + sin(x) + 10;
            }
            else 
            {
                y = sin(x) * x * x;
            }
        }
        return;
    }

    f_d:(
        in x: double, 
        in x_d: cpp2::taylor<double, 2>, 
    ) -> (
            out y: double = 0.0, 
            out y_d: cpp2::taylor<double, 2> = 0.0, 
        ) = 
    {
        if x < -3
        {
            y_d = x_d..mul(x_d, x, x);
            y = x * x;
        }
        else 
        {
            if x < 3
            {
                temp_1_d: cpp2::taylor<double, 2> = x_d.sin(x);
                temp_1: double = sin(x);
                y_d = x_d + temp_1_d;
                y = x + temp_1 + 10;
            }
            else 
            {
                temp_3_d: cpp2::taylor<double, 2> = x_d.sin(x);
                temp_3: double = sin(x);
                temp_4_d: _ = temp_3_d..mul(x_d, temp_3, x);
                temp_4: _ = temp_3 * x;
                y_d = temp_4_d..mul(x_d, temp_4, x);
                y = temp_4 * x;
            }
        }
        return;
    }
}
 ok (all Cpp2, passes safety checks)

